<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Pac-Man Battle Arena</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');
    
    :root {
      --bg-dark: #000011;
      --maze-blue: #0066ff;
      --pac-yellow: #ffff00;
      --pac-red: #ff0000;
      --ghost-red: #ff0000;
      --ghost-pink: #ffb8ff;
      --ghost-cyan: #00ffff;
      --ghost-orange: #ffb852;
      --power-pellet: #ffffff;
      --dot: #ffcc00;
      --text-light: #ffffff;
      --neon-glow: #00ffff;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    html, body {
      height: 100%;
      background: var(--bg-dark);
      color: var(--text-light);
      font-family: 'Orbitron', monospace;
      overflow: hidden;
      user-select: none;
      -webkit-user-select: none;
      touch-action: none;
    }

    #gameContainer {
      position: fixed;
      inset: 0;
      display: grid;
      place-items: center;
      background: 
        radial-gradient(circle at 25% 25%, rgba(0, 102, 255, 0.1) 0%, transparent 50%),
        radial-gradient(circle at 75% 75%, rgba(255, 255, 0, 0.1) 0%, transparent 50%);
    }

    canvas {
      border: 3px solid var(--maze-blue);
      border-radius: 10px;
      background: var(--bg-dark);
      box-shadow: 
        0 0 30px rgba(0, 102, 255, 0.5),
        inset 0 0 20px rgba(0, 102, 255, 0.2);
    }

    .overlay {
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
      background: rgba(0, 0, 17, 0.9);
      backdrop-filter: blur(8px);
    }

    .menu-card {
      background: linear-gradient(135deg, rgba(0, 102, 255, 0.1), rgba(255, 255, 0, 0.1));
      border: 3px solid var(--maze-blue);
      border-radius: 20px;
      padding: 40px;
      text-align: center;
      max-width: 600px;
      width: 90vw;
      box-shadow: 
        0 0 40px rgba(0, 102, 255, 0.4),
        inset 0 0 20px rgba(0, 102, 255, 0.1);
    }

    .title {
      font-size: 3rem;
      font-weight: 900;
      margin-bottom: 20px;
      background: linear-gradient(45deg, var(--pac-yellow), var(--pac-red), var(--ghost-cyan));
      background-size: 300% 300%;
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      animation: gradient-shift 2s ease-in-out infinite;
      text-shadow: 0 0 30px rgba(255, 255, 0, 0.6);
    }

    @keyframes gradient-shift {
      0%, 100% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
    }

    .subtitle {
      color: var(--text-light);
      margin-bottom: 30px;
      font-size: 1.2rem;
      opacity: 0.9;
    }

    .game-modes {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 20px;
      margin-bottom: 30px;
    }

    .mode-option {
      background: linear-gradient(135deg, rgba(255, 255, 0, 0.1), rgba(0, 255, 255, 0.1));
      border: 2px solid transparent;
      border-radius: 15px;
      padding: 20px;
      cursor: pointer;
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
    }

    .mode-option.active {
      border-color: var(--pac-yellow);
      background: linear-gradient(135deg, rgba(255, 255, 0, 0.2), rgba(0, 255, 255, 0.2));
      transform: scale(1.05);
      box-shadow: 0 0 25px rgba(255, 255, 0, 0.4);
    }

    .mode-option:hover {
      transform: translateY(-3px);
      box-shadow: 0 10px 25px rgba(0, 102, 255, 0.3);
    }

    .mode-title {
      font-weight: 700;
      font-size: 1.3rem;
      margin-bottom: 10px;
      color: var(--pac-yellow);
    }

    .mode-desc {
      font-size: 0.9rem;
      opacity: 0.8;
      line-height: 1.4;
    }

    .btn {
      background: linear-gradient(135deg, var(--pac-yellow), var(--ghost-cyan));
      border: none;
      border-radius: 12px;
      padding: 15px 30px;
      color: var(--bg-dark);
      font-family: inherit;
      font-weight: 700;
      font-size: 1.2rem;
      cursor: pointer;
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
      margin: 10px;
      text-transform: uppercase;
    }

    .btn:hover {
      transform: translateY(-3px) scale(1.05);
      box-shadow: 0 15px 30px rgba(255, 255, 0, 0.4);
    }

    .btn:active {
      transform: translateY(-1px) scale(1.02);
    }

    .controls-info {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 15px;
      margin-bottom: 25px;
    }

    .control-section {
      background: rgba(0, 0, 0, 0.4);
      border: 1px solid rgba(0, 102, 255, 0.3);
      border-radius: 10px;
      padding: 15px;
    }

    .control-title {
      color: var(--ghost-cyan);
      font-weight: 700;
      margin-bottom: 10px;
      font-size: 1.1rem;
    }

    .kbd {
      display: inline-block;
      padding: 4px 8px;
      background: rgba(0, 102, 255, 0.2);
      border: 1px solid rgba(0, 102, 255, 0.4);
      border-radius: 5px;
      font-size: 0.9rem;
      margin: 2px;
      font-weight: 600;
    }

    .hud {
      position: absolute;
      top: 20px;
      left: 20px;
      right: 20px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-weight: 700;
      pointer-events: none;
      z-index: 10;
    }

    .score-panel {
      background: rgba(0, 0, 17, 0.8);
      border: 2px solid var(--maze-blue);
      border-radius: 10px;
      padding: 15px 20px;
      backdrop-filter: blur(5px);
    }

    .player-info {
      margin-bottom: 8px;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .player-icon {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      display: inline-block;
    }

    .player1-icon { background: var(--pac-yellow); }
    .player2-icon { background: var(--pac-red); }

    .game-stats {
      display: flex;
      gap: 20px;
      align-items: center;
      font-size: 1.1rem;
    }

    .back-btn {
      position: absolute;
      top: 20px;
      right: 20px;
      background: rgba(255, 0, 64, 0.2);
      border: 2px solid #ff0040;
      border-radius: 10px;
      padding: 12px 18px;
      color: #ff0040;
      font-family: inherit;
      font-weight: 700;
      cursor: pointer;
      transition: all 0.3s ease;
      z-index: 20;
    }

    .back-btn:hover {
      background: rgba(255, 0, 64, 0.3);
      transform: translateY(-2px);
      box-shadow: 0 8px 20px rgba(255, 0, 64, 0.3);
    }

    .paused-overlay {
      position: absolute;
      inset: 0;
      background: rgba(0, 0, 17, 0.8);
      display: none;
      align-items: center;
      justify-content: center;
      font-size: 2.5rem;
      font-weight: 900;
      color: var(--pac-yellow);
      text-shadow: 0 0 30px rgba(255, 255, 0, 0.8);
      backdrop-filter: blur(5px);
    }

    .ready-overlay {
      position: absolute;
      inset: 0;
      background: rgba(0, 0, 17, 0.7);
      display: none;
      align-items: center;
      justify-content: center;
      font-size: 3rem;
      font-weight: 900;
      color: var(--pac-yellow);
      text-shadow: 0 0 40px rgba(255, 255, 0, 1);
      animation: pulse 2s ease-in-out infinite;
    }

    @keyframes pulse {
      0%, 100% { transform: scale(1); opacity: 1; }
      50% { transform: scale(1.1); opacity: 0.8; }
    }

    .touch-controls {
      position: absolute;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      display: none;
      grid-template-columns: repeat(3, 60px);
      grid-template-rows: repeat(3, 60px);
      gap: 5px;
    }

    .touch-btn {
      background: rgba(0, 102, 255, 0.3);
      border: 2px solid var(--maze-blue);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.5rem;
      color: var(--maze-blue);
      font-weight: 700;
      cursor: pointer;
      transition: all 0.2s ease;
      user-select: none;
      -webkit-user-select: none;
      touch-action: manipulation;
    }

    .touch-btn:active {
      background: rgba(0, 102, 255, 0.5);
      transform: scale(0.9);
    }

    .touch-btn.up { grid-column: 2; grid-row: 1; }
    .touch-btn.left { grid-column: 1; grid-row: 2; }
    .touch-btn.right { grid-column: 3; grid-row: 2; }
    .touch-btn.down { grid-column: 2; grid-row: 3; }

    @media (max-width: 768px) {
      .touch-controls {
        display: grid;
      }
      
      .menu-card {
        padding: 25px;
      }
      
      .title {
        font-size: 2.2rem;
      }
      
      .game-modes {
        grid-template-columns: 1fr;
        gap: 15px;
      }
      
      .controls-info {
        grid-template-columns: 1fr;
      }
    }

    .power-pellet-glow {
      animation: power-glow 0.5s ease-in-out infinite alternate;
    }

    @keyframes power-glow {
      0% { box-shadow: 0 0 10px var(--power-pellet); }
      100% { box-shadow: 0 0 20px var(--power-pellet), 0 0 30px var(--power-pellet); }
    }

    .frightened-mode {
      animation: frightened-flash 0.2s ease-in-out infinite;
    }

    @keyframes frightened-flash {
      0% { filter: brightness(1); }
      100% { filter: brightness(0.5) hue-rotate(180deg); }
    }
  </style>
</head>
<body>
  <div id="gameContainer">
    <canvas id="gameCanvas" width="960" height="720"></canvas>
    
    <div class="hud" id="hud" style="display: none;">
      <div class="score-panel">
        <div class="player-info">
          <span class="player-icon player1-icon"></span>
          <span>P1: <span id="player1Score">0</span></span>
        </div>
        <div class="player-info" id="player2Info" style="display: none;">
          <span class="player-icon player2-icon"></span>
          <span>P2: <span id="player2Score">0</span></span>
        </div>
      </div>
      <div class="game-stats">
        <div>Level: <span id="levelDisplay">1</span></div>
        <div>Lives: <span id="livesDisplay">3</span></div>
        <div>Bonus: <span id="bonusDisplay">0</span></div>
      </div>
    </div>

    <button class="back-btn" onclick="goHome()" title="Back to Main Menu">
      ‚Üê HOME
    </button>

    <div class="paused-overlay" id="pausedOverlay">
      <div>PAUSED<br><small style="font-size: 1rem;">Press P or Start to resume</small></div>
    </div>

    <div class="ready-overlay" id="readyOverlay">
      READY!
    </div>

    <div class="touch-controls" id="touchControls">
      <div class="touch-btn up" data-dir="up">‚Üë</div>
      <div class="touch-btn left" data-dir="left">‚Üê</div>
      <div class="touch-btn right" data-dir="right">‚Üí</div>
      <div class="touch-btn down" data-dir="down">‚Üì</div>
    </div>

    <!-- Menu overlay -->
    <div class="overlay" id="menuOverlay">
      <div class="menu-card">
        <h1 class="title">PAC-BATTLE</h1>
        <p class="subtitle">Navigate the maze, collect dots, avoid ghosts!</p>
        
        <div class="game-modes">
          <div class="mode-option active" data-mode="classic">
            <div class="mode-title">üü° CLASSIC</div>
            <div class="mode-desc">Single player vs AI ghosts<br>Traditional Pac-Man experience</div>
          </div>
          <div class="mode-option" data-mode="versus">
            <div class="mode-title">‚öîÔ∏è VERSUS</div>
            <div class="mode-desc">2 players compete<br>Race to collect the most dots</div>
          </div>
          <div class="mode-option" data-mode="cooperative">
            <div class="mode-title">ü§ù CO-OP</div>
            <div class="mode-desc">2 players team up<br>Work together against ghosts</div>
          </div>
        </div>

        <div class="controls-info">
          <div class="control-section">
            <div class="control-title">Player 1 Controls</div>
            <div>
              <span class="kbd">‚Üë</span><span class="kbd">‚Üì</span><span class="kbd">‚Üê</span><span class="kbd">‚Üí</span> or 
              <span class="kbd">W</span><span class="kbd">A</span><span class="kbd">S</span><span class="kbd">D</span>
            </div>
          </div>
          <div class="control-section">
            <div class="control-title">Player 2 Controls</div>
            <div>
              <span class="kbd">I</span><span class="kbd">J</span><span class="kbd">K</span><span class="kbd">L</span> or 
              üéÆ Gamepad
            </div>
          </div>
          <div class="control-section">
            <div class="control-title">Game Controls</div>
            <div>
              <span class="kbd">P</span> Pause ‚Ä¢ <span class="kbd">F</span> Fullscreen<br>
              <span class="kbd">R</span> Restart Level
            </div>
          </div>
        </div>

        <button class="btn" onclick="startGame()">START GAME</button>
      </div>
    </div>

    <!-- Game Over overlay -->
    <div class="overlay hidden" id="gameOverOverlay">
      <div class="menu-card">
        <h1 class="title">GAME OVER</h1>
        <div id="finalStats" style="margin: 25px 0; font-size: 1.3rem;"></div>
        <div style="display: flex; gap: 15px; justify-content: center; flex-wrap: wrap;">
          <button class="btn" onclick="restartGame()">PLAY AGAIN</button>
          <button class="btn" onclick="showMenu()">MAIN MENU</button>
        </div>
      </div>
    </div>
  </div>

  <script>
    // Game configuration
    const CONFIG = {
      CELL_SIZE: 24,
      MAZE_WIDTH: 40,
      MAZE_HEIGHT: 30,
      PLAYER_SPEED: 150, // ms between moves
      GHOST_SPEED: 180,
      FRIGHTENED_DURATION: 8000, // 8 seconds
      POINTS: {
        DOT: 10,
        POWER_PELLET: 50,
        GHOST: 200,
        FRUIT: 100
      },
      COLORS: {
        wall: '#0066ff',
        dot: '#ffcc00',
        powerPellet: '#ffffff',
        player1: '#ffff00',
        player2: '#ff0000',
        ghosts: ['#ff0000', '#ffb8ff', '#00ffff', '#ffb852'],
        ghostFrightened: '#0000ff',
        ghostEyes: '#ffffff'
      }
    };

    // Maze layout (1 = wall, 0 = path, 2 = dot, 3 = power pellet, 4 = ghost spawn)
    const MAZE_LAYOUT = [
      [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
      [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
      [1,3,1,1,1,1,2,1,1,1,1,1,2,1,1,1,1,1,2,1,1,2,1,1,1,1,1,2,1,1,1,1,1,2,1,1,1,1,3,1],
      [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
      [1,2,1,1,1,1,2,1,1,2,1,1,1,1,1,1,2,1,1,1,1,1,1,2,1,1,1,1,1,1,2,1,1,2,1,1,1,1,2,1],
      [1,2,2,2,2,2,2,1,1,2,2,2,2,1,1,2,2,2,2,1,1,2,2,2,2,1,1,2,2,2,2,1,1,2,2,2,2,2,2,1],
      [1,1,1,1,1,1,2,1,1,1,1,1,0,1,1,2,1,1,2,1,1,2,1,1,2,1,1,0,1,1,1,1,1,2,1,1,1,1,1,1],
      [0,0,0,0,0,1,2,1,1,2,2,2,2,2,2,2,1,1,2,1,1,2,1,1,2,2,2,2,2,2,2,1,1,2,1,0,0,0,0,0],
      [1,1,1,1,1,1,2,1,1,2,1,1,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,1,1,2,1,1,2,1,1,1,1,1,1],
      [2,2,2,2,2,2,2,2,2,2,1,4,0,0,4,0,0,0,0,0,0,0,0,0,0,4,0,0,4,1,2,2,2,2,2,2,2,2,2,2],
      [1,1,1,1,1,1,2,1,1,2,1,0,0,0,0,0,1,1,1,0,0,1,1,1,0,0,0,0,0,1,2,1,1,2,1,1,1,1,1,1],
      [0,0,0,0,0,1,2,1,1,2,1,1,1,1,1,0,1,0,0,0,0,0,0,1,0,1,1,1,1,1,2,1,1,2,1,0,0,0,0,0],
      [1,1,1,1,1,1,2,1,1,2,2,2,2,2,2,2,1,0,0,0,0,0,0,1,2,2,2,2,2,2,2,1,1,2,1,1,1,1,1,1],
      [1,2,2,2,2,2,2,2,2,2,1,1,1,1,1,2,1,1,1,1,1,1,1,1,2,1,1,1,1,1,2,2,2,2,2,2,2,2,2,1],
      [1,2,1,1,1,1,2,1,1,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,2,1,1,2,1,1,1,1,2,1],
      [1,3,2,2,1,1,2,2,2,2,1,1,2,1,1,1,1,1,2,1,1,2,1,1,1,1,1,2,1,1,2,2,2,2,1,1,2,2,3,1],
      [1,1,1,2,1,1,2,1,1,1,1,1,2,1,1,2,2,2,2,2,2,2,2,2,2,1,1,2,1,1,1,1,1,2,1,1,2,1,1,1],
      [1,2,2,2,2,2,2,1,1,2,2,2,2,1,1,2,1,1,1,1,1,1,1,1,2,1,1,2,2,2,2,1,1,2,2,2,2,2,2,1],
      [1,2,1,1,1,1,1,1,1,2,1,1,1,1,1,2,1,1,2,2,2,2,1,1,2,1,1,1,1,1,2,1,1,1,1,1,1,1,2,1],
      [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,1,1,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
      [1,1,1,2,1,1,1,1,1,2,1,1,1,1,1,1,1,1,2,1,1,2,1,1,1,1,1,1,1,1,2,1,1,1,1,1,2,1,1,1],
      [1,3,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,1],
      [1,2,1,1,1,1,2,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,2,1,1,1,1,1,2,1],
      [1,2,2,2,2,1,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,1,2,2,2,2,2,1],
      [1,1,1,1,2,1,2,1,1,2,1,1,1,1,1,1,1,2,1,1,1,1,2,1,1,1,1,1,1,1,2,1,1,2,1,2,1,1,1,1],
      [1,2,2,2,2,2,2,1,1,2,2,2,2,1,1,2,2,2,2,1,1,2,2,2,2,1,1,2,2,2,2,1,1,2,2,2,2,2,2,1],
      [1,2,1,1,1,1,1,1,1,1,1,1,2,1,1,2,1,1,2,1,1,2,1,1,2,1,1,2,1,1,1,1,1,1,1,1,1,1,2,1],
      [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
      [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
    ];

    // Game state
    let gameState = {
      running: false,
      paused: false,
      mode: 'classic', // classic, versus, cooperative
      level: 1,
      players: [],
      ghosts: [],
      maze: [],
      dots: [],
      powerPellets: [],
      score: [0, 0],
      lives: 3,
      dotsRemaining: 0,
      frightendMode: false,
      frightendTimer: 0,
      bonusPoints: 0,
      gameSpeed: CONFIG.PLAYER_SPEED,
      lastUpdateTime: 0,
      pausePressed: false,
      fullscreenPressed: false,
      restartPressed: false
    };

    // Input handling
    class InputManager {
      constructor() {
        this.keys = new Set();
        this.touchDir = null;
        this.setupEventListeners();
      }

      setupEventListeners() {
        document.addEventListener('keydown', (e) => {
          this.keys.add(e.code);
          if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Space'].includes(e.code)) {
            e.preventDefault();
          }
        });

        document.addEventListener('keyup', (e) => {
          this.keys.delete(e.code);
        });

        // Touch controls
        document.querySelectorAll('.touch-btn').forEach(btn => {
          btn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            this.touchDir = btn.dataset.dir;
          });
          
          btn.addEventListener('touchend', (e) => {
            e.preventDefault();
            this.touchDir = null;
          });
        });
      }

      getPlayerInput(playerIndex) {
        // Gamepad support for player 2
        if (playerIndex === 1) {
          const gamepad = navigator.getGamepads()[0];
          if (gamepad) {
            const threshold = 0.5;
            if (gamepad.axes[1] < -threshold || gamepad.buttons[12]?.pressed) return 'up';
            if (gamepad.axes[1] > threshold || gamepad.buttons[13]?.pressed) return 'down';
            if (gamepad.axes[0] < -threshold || gamepad.buttons[14]?.pressed) return 'left';
            if (gamepad.axes[0] > threshold || gamepad.buttons[15]?.pressed) return 'right';
          }
          
          // Keyboard for player 2
          if (this.keys.has('KeyI')) return 'up';
          if (this.keys.has('KeyK')) return 'down';
          if (this.keys.has('KeyJ')) return 'left';
          if (this.keys.has('KeyL')) return 'right';
        } else {
          // Player 1 keyboard and touch
          if (this.keys.has('ArrowUp') || this.keys.has('KeyW')) return 'up';
          if (this.keys.has('ArrowDown') || this.keys.has('KeyS')) return 'down';
          if (this.keys.has('ArrowLeft') || this.keys.has('KeyA')) return 'left';
          if (this.keys.has('ArrowRight') || this.keys.has('KeyD')) return 'right';
          if (this.touchDir) return this.touchDir;
        }
        return null;
      }

      isPausePressed() {
        if (this.keys.has('KeyP')) return true;
        const gamepad = navigator.getGamepads()[0];
        return gamepad?.buttons[9]?.pressed; // Start button
      }

      isFullscreenPressed() {
        return this.keys.has('KeyF');
      }

      isRestartPressed() {
        return this.keys.has('KeyR');
      }
    }

    // Audio system
    class AudioManager {
      constructor() {
        this.context = null;
        this.enabled = false;
      }

      async init() {
        try {
          this.context = new (window.AudioContext || window.webkitAudioContext)();
          if (this.context.state === 'suspended') {
            await this.context.resume();
          }
          this.enabled = true;
        } catch (e) {
          console.warn('Audio not available');
        }
      }

      playTone(frequency, duration = 0.1, type = 'square', volume = 0.1) {
        if (!this.enabled || !this.context) return;

        const oscillator = this.context.createOscillator();
        const gainNode = this.context.createGain();

        oscillator.connect(gainNode);
        gainNode.connect(this.context.destination);

        oscillator.frequency.value = frequency;
        oscillator.type = type;
        gainNode.gain.value = volume;

        oscillator.start();
        oscillator.stop(this.context.currentTime + duration);
      }

      playChomp() {
        this.playTone(800, 0.1, 'square', 0.1);
        setTimeout(() => this.playTone(600, 0.1, 'square', 0.1), 50);
      }

      playPowerPellet() {
        this.playTone(200, 0.1, 'sine', 0.15);
        setTimeout(() => this.playTone(300, 0.1, 'sine', 0.15), 100);
        setTimeout(() => this.playTone(400, 0.2, 'sine', 0.15), 200);
      }

      playGhostEaten() {
        this.playTone(1000, 0.2, 'sine', 0.15);
        setTimeout(() => this.playTone(800, 0.2, 'sine', 0.15), 100);
      }

      playDeath() {
        for (let i = 0; i < 8; i++) {
          setTimeout(() => {
            this.playTone(800 - i * 100, 0.1, 'sawtooth', 0.1);
          }, i * 100);
        }
      }

      playLevelComplete() {
        for (let i = 0; i < 5; i++) {
          setTimeout(() => {
            this.playTone(400 + i * 200, 0.2, 'sine', 0.1);
          }, i * 150);
        }
      }
    }

    // Game entities
    class Player {
      constructor(x, y, color, playerIndex) {
        this.x = x;
        this.y = y;
        this.targetX = x;
        this.targetY = y;
        this.direction = { x: 0, y: 0 };
        this.nextDirection = { x: 0, y: 0 };
        this.color = color;
        this.playerIndex = playerIndex;
        this.alive = true;
        this.score = 0;
        this.animFrame = 0;
        this.moving = false;
      }

      update() {
        if (!this.alive) return;

        // Try to change direction if requested
        if (this.nextDirection.x !== 0 || this.nextDirection.y !== 0) {
          const newX = this.x + this.nextDirection.x;
          const newY = this.y + this.nextDirection.y;
          if (this.canMoveTo(newX, newY)) {
            this.direction = { ...this.nextDirection };
            this.nextDirection = { x: 0, y: 0 };
          }
        }

        // Continue moving in current direction
        if (this.direction.x !== 0 || this.direction.y !== 0) {
          const newX = this.x + this.direction.x;
          const newY = this.y + this.direction.y;
          
          if (this.canMoveTo(newX, newY)) {
            this.x = newX;
            this.y = newY;
            this.moving = true;
            this.animFrame = (this.animFrame + 1) % 8;
            
            // Handle tunnel wrapping
            if (this.x < 0) this.x = CONFIG.MAZE_WIDTH - 1;
            if (this.x >= CONFIG.MAZE_WIDTH) this.x = 0;
            
            this.collectItems();
          } else {
            this.moving = false;
            this.direction = { x: 0, y: 0 };
          }
        }
      }

      canMoveTo(x, y) {
        if (y < 0 || y >= CONFIG.MAZE_HEIGHT) return false;
        if (x < 0 || x >= CONFIG.MAZE_WIDTH) return true; // Tunnel
        return gameState.maze[y][x] !== 1; // Not a wall
      }

      collectItems() {
        const pos = this.y * CONFIG.MAZE_WIDTH + this.x;
        
        // Collect dots
        if (gameState.dots.has(pos)) {
          gameState.dots.delete(pos);
          this.score += CONFIG.POINTS.DOT;
          gameState.dotsRemaining--;
          audio.playChomp();
        }
        
        // Collect power pellets
        if (gameState.powerPellets.has(pos)) {
          gameState.powerPellets.delete(pos);
          this.score += CONFIG.POINTS.POWER_PELLET;
          audio.playPowerPellet();
          
          // Activate frightened mode
          gameState.frightendMode = true;
          gameState.frightendTimer = CONFIG.FRIGHTENED_DURATION;
          gameState.ghosts.forEach(ghost => {
            if (ghost.mode !== 'eaten') {
              ghost.mode = 'frightened';
              ghost.reverseDirection();
            }
          });
        }
      }

      setDirection(newDir) {
        this.nextDirection = newDir;
      }

      render(ctx) {
        if (!this.alive) return;

        const x = this.x * CONFIG.CELL_SIZE + CONFIG.CELL_SIZE / 2;
        const y = this.y * CONFIG.CELL_SIZE + CONFIG.CELL_SIZE / 2;
        const radius = CONFIG.CELL_SIZE * 0.4;

        ctx.fillStyle = this.color;
        ctx.shadowColor = this.color;
        ctx.shadowBlur = 15;

        // Draw Pac-Man with opening mouth animation
        ctx.beginPath();
        
        if (this.moving) {
          const mouthAngle = Math.PI * 0.7 * (Math.sin(this.animFrame * 0.5) * 0.5 + 0.5);
          let startAngle = 0;
          
          // Adjust mouth direction based on movement
          if (this.direction.x > 0) startAngle = 0; // Right
          else if (this.direction.x < 0) startAngle = Math.PI; // Left
          else if (this.direction.y < 0) startAngle = -Math.PI/2; // Up
          else if (this.direction.y > 0) startAngle = Math.PI/2; // Down
          
          ctx.arc(x, y, radius, startAngle + mouthAngle/2, startAngle - mouthAngle/2);
          ctx.lineTo(x, y);
        } else {
          ctx.arc(x, y, radius, 0, Math.PI * 2);
        }
        
        ctx.fill();
        ctx.shadowBlur = 0;
      }
    }

    class Ghost {
      constructor(x, y, color, type) {
        this.x = x;
        this.y = y;
        this.color = color;
        this.type = type;
        this.direction = { x: 0, y: -1 }; // Start moving up
        this.mode = 'chase'; // chase, scatter, frightened, eaten
        this.modeTimer = 0;
        this.target = { x: 0, y: 0 };
        this.animFrame = 0;
      }

      update() {
        this.animFrame = (this.animFrame + 1) % 16;
        
        // Update mode timer
        this.modeTimer++;
        
        // Switch between chase and scatter modes
        if (this.mode === 'chase' && this.modeTimer > 1000) {
          this.mode = 'scatter';
          this.modeTimer = 0;
        } else if (this.mode === 'scatter' && this.modeTimer > 500) {
          this.mode = 'chase';
          this.modeTimer = 0;
        }
        
        // Choose target based on mode and type
        this.chooseTarget();
        
        // Move towards target
        this.move();
        
        // Handle tunnel wrapping
        if (this.x < 0) this.x = CONFIG.MAZE_WIDTH - 1;
        if (this.x >= CONFIG.MAZE_WIDTH) this.x = 0;
        
        // Check collision with players
        this.checkPlayerCollision();
      }

      chooseTarget() {
        const player = gameState.players[0]; // Primary target is player 1
        
        if (this.mode === 'frightened') {
          // Random movement when frightened
          this.target = {
            x: Math.floor(Math.random() * CONFIG.MAZE_WIDTH),
            y: Math.floor(Math.random() * CONFIG.MAZE_HEIGHT)
          };
        } else if (this.mode === 'eaten') {
          // Return to ghost house
          this.target = { x: 19, y: 9 };
          if (this.x === 19 && this.y === 9) {
            this.mode = 'chase';
          }
        } else if (this.mode === 'scatter') {
          // Go to corner
          const corners = [
            { x: 2, y: 2 },
            { x: CONFIG.MAZE_WIDTH - 3, y: 2 },
            { x: 2, y: CONFIG.MAZE_HEIGHT - 3 },
            { x: CONFIG.MAZE_WIDTH - 3, y: CONFIG.MAZE_HEIGHT - 3 }
          ];
          this.target = corners[this.type % 4];
        } else {
          // Chase mode - different strategy per ghost
          switch (this.type) {
            case 0: // Red ghost - direct chase
              this.target = { x: player.x, y: player.y };
              break;
            case 1: // Pink ghost - ambush 4 tiles ahead
              this.target = {
                x: player.x + player.direction.x * 4,
                y: player.y + player.direction.y * 4
              };
              break;
            case 2: // Cyan ghost - complex targeting
              const redGhost = gameState.ghosts[0];
              const vectorX = (player.x + player.direction.x * 2) - redGhost.x;
              const vectorY = (player.y + player.direction.y * 2) - redGhost.y;
              this.target = {
                x: redGhost.x + vectorX * 2,
                y: redGhost.y + vectorY * 2
              };
              break;
            case 3: // Orange ghost - chase if far, scatter if close
              const distance = Math.abs(this.x - player.x) + Math.abs(this.y - player.y);
              if (distance > 8) {
                this.target = { x: player.x, y: player.y };
              } else {
                this.target = { x: 2, y: CONFIG.MAZE_HEIGHT - 3 };
              }
              break;
          }
        }
      }

      move() {
        const directions = [
          { x: 0, y: -1 }, // Up
          { x: 1, y: 0 },  // Right
          { x: 0, y: 1 },  // Down
          { x: -1, y: 0 }  // Left
        ];

        let bestDirection = this.direction;
        let bestDistance = Infinity;

        for (const dir of directions) {
          // Don't reverse direction unless in frightened mode
          if (dir.x === -this.direction.x && dir.y === -this.direction.y && this.mode !== 'frightened') {
            continue;
          }

          const newX = this.x + dir.x;
          const newY = this.y + dir.y;

          if (this.canMoveTo(newX, newY)) {
            const distance = Math.abs(newX - this.target.x) + Math.abs(newY - this.target.y);
            
            if (this.mode === 'frightened') {
              // In frightened mode, prefer directions away from target
              if (distance > bestDistance) {
                bestDistance = distance;
                bestDirection = dir;
              }
            } else {
              // Normal mode, move towards target
              if (distance < bestDistance) {
                bestDistance = distance;
                bestDirection = dir;
              }
            }
          }
        }

        this.direction = bestDirection;
        this.x += this.direction.x;
        this.y += this.direction.y;
      }

      canMoveTo(x, y) {
        if (y < 0 || y >= CONFIG.MAZE_HEIGHT) return false;
        if (x < 0 || x >= CONFIG.MAZE_WIDTH) return true; // Tunnel
        return gameState.maze[y][x] !== 1; // Not a wall
      }

      reverseDirection() {
        this.direction.x *= -1;
        this.direction.y *= -1;
      }

      checkPlayerCollision() {
        for (const player of gameState.players) {
          if (player.alive && player.x === this.x && player.y === this.y) {
            if (this.mode === 'frightened') {
              // Ghost eaten
              this.mode = 'eaten';
              player.score += CONFIG.POINTS.GHOST;
              audio.playGhostEaten();
            } else if (this.mode !== 'eaten') {
              // Player caught
              player.alive = false;
              gameState.lives--;
              audio.playDeath();
              
              if (gameState.lives <= 0) {
                endGame();
              } else {
                respawnPlayer(player);
              }
            }
          }
        }
      }

      render(ctx) {
        const x = this.x * CONFIG.CELL_SIZE;
        const y = this.y * CONFIG.CELL_SIZE;
        const size = CONFIG.CELL_SIZE * 0.9;

        if (this.mode === 'eaten') {
          // Just draw eyes when eaten
          ctx.fillStyle = CONFIG.COLORS.ghostEyes;
          ctx.fillRect(x + size * 0.2, y + size * 0.3, size * 0.2, size * 0.2);
          ctx.fillRect(x + size * 0.6, y + size * 0.3, size * 0.2, size * 0.2);
          return;
        }

        // Ghost body color
        let bodyColor = this.color;
        if (this.mode === 'frightened') {
          // Flash between blue and white when frightened time is running out
          if (gameState.frightendTimer < 2000 && Math.floor(Date.now() / 200) % 2) {
            bodyColor = '#ffffff';
          } else {
            bodyColor = CONFIG.COLORS.ghostFrightened;
          }
        }

        ctx.fillStyle = bodyColor;
        ctx.shadowColor = bodyColor;
        ctx.shadowBlur = 10;

        // Draw ghost body (rounded top, wavy bottom)
        ctx.beginPath();
        ctx.arc(x + size/2, y + size/2, size/2, Math.PI, 0);
        ctx.lineTo(x + size, y + size * 0.8);
        
        // Wavy bottom
        const waveOffset = this.animFrame * 0.3;
        for (let i = 0; i <= 4; i++) {
          const waveX = x + (i / 4) * size;
          const waveY = y + size * 0.8 + Math.sin(waveOffset + i) * size * 0.1;
          ctx.lineTo(waveX, waveY);
        }
        
        ctx.lineTo(x, y + size * 0.8);
        ctx.closePath();
        ctx.fill();

        // Draw eyes
        ctx.fillStyle = CONFIG.COLORS.ghostEyes;
        ctx.shadowBlur = 0;
        ctx.fillRect(x + size * 0.2, y + size * 0.3, size * 0.15, size * 0.2);
        ctx.fillRect(x + size * 0.65, y + size * 0.3, size * 0.15, size * 0.2);

        // Eye pupils
        ctx.fillStyle = '#000000';
        const pupilOffsetX = this.direction.x * 2;
        const pupilOffsetY = this.direction.y * 2;
        ctx.fillRect(x + size * 0.22 + pupilOffsetX, y + size * 0.35 + pupilOffsetY, size * 0.06, size * 0.08);
        ctx.fillRect(x + size * 0.67 + pupilOffsetX, y + size * 0.35 + pupilOffsetY, size * 0.06, size * 0.08);
      }
    }

    // Initialize game systems
    const input = new InputManager();
    const audio = new AudioManager();

    // Canvas setup
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    ctx.imageSmoothingEnabled = false;

    // Game functions
    function initializeGame() {
      // Copy maze layout
      gameState.maze = MAZE_LAYOUT.map(row => [...row]);
      
      // Initialize collections
      gameState.dots = new Set();
      gameState.powerPellets = new Set();
      gameState.dotsRemaining = 0;
      
      // Setup maze items
      for (let y = 0; y < CONFIG.MAZE_HEIGHT; y++) {
        for (let x = 0; x < CONFIG.MAZE_WIDTH; x++) {
          const cell = gameState.maze[y][x];
          const pos = y * CONFIG.MAZE_WIDTH + x;
          
          if (cell === 2) {
            gameState.dots.add(pos);
            gameState.dotsRemaining++;
            gameState.maze[y][x] = 0; // Convert to path
          } else if (cell === 3) {
            gameState.powerPellets.add(pos);
            gameState.maze[y][x] = 0; // Convert to path
          }
        }
      }

      // Create players
      gameState.players = [];
      gameState.players.push(new Player(19, 23, CONFIG.COLORS.player1, 0));
      
      if (gameState.mode === 'versus' || gameState.mode === 'cooperative') {
        gameState.players.push(new Player(20, 23, CONFIG.COLORS.player2, 1));
      }

      // Create ghosts
      gameState.ghosts = [];
      for (let i = 0; i < 4; i++) {
        const ghost = new Ghost(19 + (i - 1.5), 9, CONFIG.COLORS.ghosts[i], i);
        gameState.ghosts.push(ghost);
      }

      // Reset game state
      gameState.score = [0, 0];
      gameState.lives = 3;
      gameState.frightendMode = false;
      gameState.frightendTimer = 0;
      gameState.bonusPoints = 0;

      // Show ready screen
      showReady();
    }

    function showReady() {
      const readyOverlay = document.getElementById('readyOverlay');
      readyOverlay.style.display = 'flex';
      
      setTimeout(() => {
        readyOverlay.style.display = 'none';
        gameState.running = true;
        startGameLoop();
      }, 2000);
    }

    function respawnPlayer(player) {
      player.x = 19;
      player.y = 23;
      player.alive = true;
      player.direction = { x: 0, y: 0 };
      player.nextDirection = { x: 0, y: 0 };
      
      // Reset ghosts to non-frightened mode
      gameState.frightendMode = false;
      gameState.frightendTimer = 0;
      gameState.ghosts.forEach(ghost => {
        if (ghost.mode === 'frightened') {
          ghost.mode = 'chase';
        }
      });
      
      setTimeout(() => showReady(), 1000);
    }

    function updateGame() {
      if (!gameState.running || gameState.paused) return;

      // Update frightened timer
      if (gameState.frightendMode) {
        gameState.frightendTimer -= 16; // Assuming 60fps
        if (gameState.frightendTimer <= 0) {
          gameState.frightendMode = false;
          gameState.ghosts.forEach(ghost => {
            if (ghost.mode === 'frightened') {
              ghost.mode = 'chase';
            }
          });
        }
      }

      // Update players
      gameState.players.forEach(player => {
        if (player.alive) {
          player.update();
        }
      });

      // Update ghosts
      gameState.ghosts.forEach(ghost => ghost.update());

      // Check win condition
      if (gameState.dotsRemaining <= 0) {
        levelComplete();
      }

      // Update score display
      updateScoreDisplay();
    }

    function handleInput() {
      if (!gameState.running) return;

      // Check pause
      if (input.isPausePressed() && !gameState.pausePressed) {
        gameState.paused = !gameState.paused;
        document.getElementById('pausedOverlay').style.display = gameState.paused ? 'flex' : 'none';
        gameState.pausePressed = true;
      } else if (!input.isPausePressed()) {
        gameState.pausePressed = false;
      }

      // Check fullscreen
      if (input.isFullscreenPressed() && !gameState.fullscreenPressed) {
        toggleFullscreen();
        gameState.fullscreenPressed = true;
      } else if (!input.isFullscreenPressed()) {
        gameState.fullscreenPressed = false;
      }

      // Check restart
      if (input.isRestartPressed() && !gameState.restartPressed) {
        restartLevel();
        gameState.restartPressed = true;
      } else if (!input.isRestartPressed()) {
        gameState.restartPressed = false;
      }

      if (gameState.paused) return;

      // Handle player input
      gameState.players.forEach((player, index) => {
        if (!player.alive) return;

        const inputDir = input.getPlayerInput(index);
        if (inputDir) {
          let direction;
          
          switch (inputDir) {
            case 'up': direction = { x: 0, y: -1 }; break;
            case 'down': direction = { x: 0, y: 1 }; break;
            case 'left': direction = { x: -1, y: 0 }; break;
            case 'right': direction = { x: 1, y: 0 }; break;
          }
          
          if (direction) {
            player.setDirection(direction);
          }
        }
      });
    }

    function render() {
      // Clear canvas
      ctx.fillStyle = CONFIG.COLORS.wall;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Draw maze walls
      ctx.fillStyle = CONFIG.COLORS.wall;
      for (let y = 0; y < CONFIG.MAZE_HEIGHT; y++) {
        for (let x = 0; x < CONFIG.MAZE_WIDTH; x++) {
          if (gameState.maze[y][x] === 1) {
            ctx.fillRect(x * CONFIG.CELL_SIZE, y * CONFIG.CELL_SIZE, CONFIG.CELL_SIZE, CONFIG.CELL_SIZE);
          }
        }
      }

      // Draw dots
      ctx.fillStyle = CONFIG.COLORS.dot;
      for (const pos of gameState.dots) {
        const x = pos % CONFIG.MAZE_WIDTH;
        const y = Math.floor(pos / CONFIG.MAZE_WIDTH);
        const centerX = x * CONFIG.CELL_SIZE + CONFIG.CELL_SIZE / 2;
        const centerY = y * CONFIG.CELL_SIZE + CONFIG.CELL_SIZE / 2;
        
        ctx.beginPath();
        ctx.arc(centerX, centerY, 2, 0, Math.PI * 2);
        ctx.fill();
      }

      // Draw power pellets
      ctx.fillStyle = CONFIG.COLORS.powerPellet;
      ctx.shadowColor = CONFIG.COLORS.powerPellet;
      ctx.shadowBlur = 10;
      for (const pos of gameState.powerPellets) {
        const x = pos % CONFIG.MAZE_WIDTH;
        const y = Math.floor(pos / CONFIG.MAZE_WIDTH);
        const centerX = x * CONFIG.CELL_SIZE + CONFIG.CELL_SIZE / 2;
        const centerY = y * CONFIG.CELL_SIZE + CONFIG.CELL_SIZE / 2;
        const size = 6 + Math.sin(Date.now() * 0.01) * 2;
        
        ctx.beginPath();
        ctx.arc(centerX, centerY, size, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.shadowBlur = 0;

      // Draw ghosts
      gameState.ghosts.forEach(ghost => ghost.render(ctx));

      // Draw players
      gameState.players.forEach(player => player.render(ctx));
    }

    function updateScoreDisplay() {
      if (gameState.players.length > 0) {
        document.getElementById('player1Score').textContent = gameState.players[0].score;
        gameState.score[0] = gameState.players[0].score;
      }
      
      if (gameState.players.length > 1) {
        document.getElementById('player2Score').textContent = gameState.players[1].score;
        document.getElementById('player2Info').style.display = 'block';
        gameState.score[1] = gameState.players[1].score;
      }
      
      document.getElementById('levelDisplay').textContent = gameState.level;
      document.getElementById('livesDisplay').textContent = gameState.lives;
      document.getElementById('bonusDisplay').textContent = gameState.bonusPoints;
    }

    function levelComplete() {
      gameState.running = false;
      audio.playLevelComplete();
      
      // Calculate bonus points
      gameState.bonusPoints += 1000 * gameState.level;
      gameState.players.forEach(player => {
        player.score += gameState.bonusPoints;
      });
      
      // Next level
      gameState.level++;
      
      setTimeout(() => {
        initializeGame();
      }, 2000);
    }

    function restartLevel() {
      gameState.running = false;
      gameState.paused = false;
      document.getElementById('pausedOverlay').style.display = 'none';
      initializeGame();
    }

    function endGame() {
      gameState.running = false;
      
      let statsHtml = '';
      if (gameState.mode === 'versus') {
        const winner = gameState.players[0].score > gameState.players[1].score ? 0 : 1;
        statsHtml += `<div style="color: ${CONFIG.COLORS[winner === 0 ? 'player1' : 'player2']}; font-size: 1.8rem; margin-bottom: 15px;">Player ${winner + 1} Wins!</div>`;
      }
      
      statsHtml += `<div style="font-size: 1.4rem; margin-bottom: 15px;">Level ${gameState.level} Complete</div>`;
      statsHtml += '<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">';
      
      gameState.players.forEach((player, index) => {
        statsHtml += `
          <div style="padding: 15px; border: 2px solid ${player.color}; border-radius: 10px;">
            <div style="color: ${player.color}; font-weight: 700; font-size: 1.2rem;">Player ${index + 1}</div>
            <div style="margin-top: 8px;">Score: ${player.score}</div>
            <div>Level: ${gameState.level}</div>
          </div>
        `;
      });
      statsHtml += '</div>';
      
      document.getElementById('finalStats').innerHTML = statsHtml;
      document.getElementById('gameOverOverlay').classList.remove('hidden');
    }

    // Game loop
    let lastTime = 0;
    function gameLoop(currentTime) {
      if (currentTime - lastTime >= gameState.gameSpeed) {
        handleInput();
        updateGame();
        lastTime = currentTime;
      }
      
      render();
      
      if (gameState.running) {
        requestAnimationFrame(gameLoop);
      }
    }

    function startGameLoop() {
      requestAnimationFrame(gameLoop);
    }

    // UI functions
    function showMenu() {
      gameState.running = false;
      document.getElementById('menuOverlay').classList.remove('hidden');
      document.getElementById('gameOverOverlay').classList.add('hidden');
      document.getElementById('hud').style.display = 'none';
    }

    function startGame() {
      audio.init();
      gameState.running = false; // Will be set to true after ready screen
      gameState.paused = false;
      document.getElementById('menuOverlay').classList.add('hidden');
      document.getElementById('gameOverOverlay').classList.add('hidden');
      document.getElementById('pausedOverlay').style.display = 'none';
      document.getElementById('hud').style.display = 'flex';
      
      initializeGame();
    }

    function restartGame() {
      gameState.level = 1;
      startGame();
    }

    function goHome() {
      window.location.href = '../index.html';
    }

    async function toggleFullscreen() {
      try {
        if (!document.fullscreenElement) {
          await canvas.requestFullscreen();
        } else {
          await document.exitFullscreen();
        }
      } catch (e) {
        console.warn('Fullscreen not supported');
      }
    }

    // Game mode selection
    document.querySelectorAll('.mode-option').forEach(option => {
      option.addEventListener('click', () => {
        document.querySelectorAll('.mode-option').forEach(opt => opt.classList.remove('active'));
        option.classList.add('active');
        gameState.mode = option.dataset.mode;
      });
    });

    // Initialize
    showMenu();
    
    // Handle visibility change to pause game
    document.addEventListener('visibilitychange', () => {
      if (document.hidden && gameState.running && !gameState.paused) {
        gameState.paused = true;
        document.getElementById('pausedOverlay').style.display = 'flex';
      }
    });
  </script>
</body>
</html>
