<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Pac-Man Battle Arena</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');
    
    :root {
      --bg-dark: #000011;
      --maze-blue: #0066ff;
      --pac-yellow: #ffff00;
      --pac-red: #ff0000;
      --ghost-red: #ff0000;
      --ghost-pink: #ffb8ff;
      --ghost-cyan: #00ffff;
      --ghost-orange: #ffb852;
      --power-pellet: #ffffff;
      --dot: #ffcc00;
      --text-light: #ffffff;
      --neon-glow: #00ffff;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    html, body {
      height: 100%;
      background: var(--bg-dark);
      color: var(--text-light);
      font-family: 'Orbitron', monospace;
      overflow: hidden;
      user-select: none;
      -webkit-user-select: none;
      touch-action: none;
    }

    #gameContainer {
      position: fixed;
      inset: 0;
      display: grid;
      grid-template-rows: auto 1fr auto;
      grid-template-columns: 1fr;
      background: 
        radial-gradient(circle at 25% 25%, rgba(0, 102, 255, 0.1) 0%, transparent 50%),
        radial-gradient(circle at 75% 75%, rgba(255, 255, 0, 0.1) 0%, transparent 50%);
      padding: 0;
      box-sizing: border-box;
      overflow: hidden;
      height: 100vh;
      width: 100vw;
    }

    .game-header {
      grid-row: 1;
      grid-column: 1;
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 15px 20px;
      background: rgba(0, 0, 17, 0.95);
      border-bottom: 2px solid var(--maze-blue);
      backdrop-filter: blur(15px);
      z-index: 100;
      box-shadow: 0 2px 20px rgba(0, 102, 255, 0.3);
    }

    .game-area {
      grid-row: 2;
      grid-column: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 20px;
      overflow: hidden;
      position: relative;
      min-height: 0;
      min-width: 0;
      height: 100%;
      width: 100%;
    }

    .game-area.hidden {
      display: none;
    }

    .game-area canvas {
      width: 100% !important;
      height: 100% !important;
      max-width: 100%;
      max-height: 100%;
      object-fit: fill;
      display: block;
    }

    .game-footer {
      grid-row: 3;
      grid-column: 1;
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 10px 20px;
      background: rgba(0, 0, 17, 0.95);
      border-top: 2px solid var(--maze-blue);
      backdrop-filter: blur(15px);
      z-index: 100;
      box-shadow: 0 -2px 20px rgba(0, 102, 255, 0.3);
    }

    canvas {
      border: 3px solid var(--maze-blue);
      border-radius: 10px;
      background: var(--bg-dark);
      box-shadow: 
        0 0 30px rgba(0, 102, 255, 0.5),
        inset 0 0 20px rgba(0, 102, 255, 0.2);
      max-width: 100%;
      max-height: 100%;
      width: auto;
      height: auto;
      object-fit: contain;
    }

    .overlay {
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
      background: rgba(0, 0, 17, 0.9);
      backdrop-filter: blur(8px);
      z-index: 200;
    }

    .overlay.hidden {
      display: none;
    }

    .menu-card {
      background: linear-gradient(135deg, rgba(0, 102, 255, 0.1), rgba(255, 255, 0, 0.1));
      border: 3px solid var(--maze-blue);
      border-radius: 20px;
      padding: 40px;
      text-align: center;
      max-width: 600px;
      width: 90vw;
      max-height: 90vh;
      overflow-y: auto;
      box-shadow: 
        0 0 40px rgba(0, 102, 255, 0.4),
        inset 0 0 20px rgba(0, 102, 255, 0.1);
    }

    .title {
      font-size: 3rem;
      font-weight: 900;
      margin-bottom: 20px;
      background: linear-gradient(45deg, var(--pac-yellow), var(--pac-red), var(--ghost-cyan));
      background-size: 300% 300%;
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      animation: gradient-shift 2s ease-in-out infinite;
      text-shadow: 0 0 30px rgba(255, 255, 0, 0.6);
    }

    @keyframes gradient-shift {
      0%, 100% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
    }

    .subtitle {
      color: var(--text-light);
      margin-bottom: 30px;
      font-size: 1.2rem;
      opacity: 0.9;
    }

    .game-modes {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 20px;
      margin-bottom: 30px;
    }

    .mode-option {
      background: linear-gradient(135deg, rgba(255, 255, 0, 0.1), rgba(0, 255, 255, 0.1));
      border: 2px solid transparent;
      border-radius: 15px;
      padding: 20px;
      cursor: pointer;
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
    }

    .mode-option.active {
      border-color: var(--pac-yellow);
      background: linear-gradient(135deg, rgba(255, 255, 0, 0.2), rgba(0, 255, 255, 0.2));
      transform: scale(1.05);
      box-shadow: 0 0 25px rgba(255, 255, 0, 0.4);
    }

    .mode-option:hover {
      transform: translateY(-3px);
      box-shadow: 0 10px 25px rgba(0, 102, 255, 0.3);
    }

    .mode-title {
      font-weight: 700;
      font-size: 1.3rem;
      margin-bottom: 10px;
      color: var(--pac-yellow);
    }

    .mode-desc {
      font-size: 0.9rem;
      opacity: 0.8;
      line-height: 1.4;
    }

    .btn {
      background: linear-gradient(135deg, var(--pac-yellow), var(--ghost-cyan));
      border: none;
      border-radius: 12px;
      padding: 15px 30px;
      color: var(--bg-dark);
      font-family: inherit;
      font-weight: 700;
      font-size: 1.2rem;
      cursor: pointer;
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
      margin: 10px;
      text-transform: uppercase;
    }

    .btn:hover {
      transform: translateY(-3px) scale(1.05);
      box-shadow: 0 15px 30px rgba(255, 255, 0, 0.4);
    }

    .btn:active {
      transform: translateY(-1px) scale(1.02);
    }

    .controls-info {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 15px;
      margin-bottom: 25px;
    }

    .control-section {
      background: rgba(0, 0, 0, 0.4);
      border: 1px solid rgba(0, 102, 255, 0.3);
      border-radius: 10px;
      padding: 15px;
    }

    .control-title {
      color: var(--ghost-cyan);
      font-weight: 700;
      margin-bottom: 10px;
      font-size: 1.1rem;
    }

    .kbd {
      display: inline-block;
      padding: 4px 8px;
      background: rgba(0, 102, 255, 0.2);
      border: 1px solid rgba(0, 102, 255, 0.4);
      border-radius: 5px;
      font-size: 0.9rem;
      margin: 2px;
      font-weight: 600;
    }

    .hud {
      display: none;
    }

    .score-panel {
      background: rgba(0, 0, 17, 0.9);
      border: 2px solid var(--maze-blue);
      border-radius: 10px;
      padding: 15px 20px;
      backdrop-filter: blur(10px);
      box-shadow: 0 0 20px rgba(0, 102, 255, 0.3);
    }

    .player-info {
      margin-bottom: 8px;
      display: flex;
      align-items: center;
      gap: 10px;
      font-weight: 700;
      color: var(--text-light);
    }

    .player-info:last-child {
      margin-bottom: 0;
    }

    .player-icon {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      display: inline-block;
    }

    .player1-icon { background: var(--pac-yellow); }
    .player2-icon { background: var(--pac-red); }

    .game-stats {
      display: flex;
      gap: 20px;
      align-items: center;
      font-size: 1.1rem;
      background: rgba(0, 0, 17, 0.9);
      border: 2px solid var(--maze-blue);
      border-radius: 10px;
      padding: 15px 20px;
      backdrop-filter: blur(10px);
      box-shadow: 0 0 20px rgba(0, 102, 255, 0.3);
      font-weight: 700;
      color: var(--text-light);
    }

    .game-stats > div {
      display: flex;
      align-items: center;
      gap: 5px;
    }

    .back-btn {
      background: rgba(255, 0, 64, 0.2);
      border: 2px solid #ff0040;
      border-radius: 10px;
      padding: 12px 18px;
      color: #ff0040;
      font-family: inherit;
      font-weight: 700;
      cursor: pointer;
      transition: all 0.3s ease;
    }

    .back-btn:hover {
      background: rgba(255, 0, 64, 0.3);
      transform: translateY(-2px);
      box-shadow: 0 8px 20px rgba(255, 0, 64, 0.3);
    }

    .paused-overlay {
      position: absolute;
      inset: 0;
      background: rgba(0, 0, 17, 0.8);
      display: none;
      align-items: center;
      justify-content: center;
      font-size: 2.5rem;
      font-weight: 900;
      color: var(--pac-yellow);
      text-shadow: 0 0 30px rgba(255, 255, 0, 0.8);
      backdrop-filter: blur(5px);
      z-index: 150;
    }

    .ready-overlay {
      position: absolute;
      inset: 0;
      background: rgba(0, 0, 17, 0.7);
      display: none;
      align-items: center;
      justify-content: center;
      font-size: 3rem;
      font-weight: 900;
      color: var(--pac-yellow);
      text-shadow: 0 0 40px rgba(255, 255, 0, 1);
      animation: pulse 2s ease-in-out infinite;
      z-index: 150;
    }

    @keyframes pulse {
      0%, 100% { transform: scale(1); opacity: 1; }
      50% { transform: scale(1.1); opacity: 0.8; }
    }

    .touch-controls {
      display: none;
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      grid-template-columns: repeat(3, 1fr);
      gap: 10px;
      z-index: 1000;
    }

    .touch-btn {
      width: 60px;
      height: 60px;
      background: rgba(0, 102, 255, 0.3);
      border: 2px solid var(--maze-blue);
      border-radius: 50%;
      color: white;
      font-size: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      user-select: none;
      touch-action: manipulation;
      transition: all 0.2s ease;
    }

    .touch-btn:active {
      background: rgba(0, 102, 255, 0.6);
      transform: scale(0.95);
    }

    .touch-btn.up { grid-column: 2; }
    .touch-btn.left { grid-column: 1; grid-row: 2; }
    .touch-btn.right { grid-column: 3; grid-row: 2; }
    .touch-btn.down { grid-column: 2; grid-row: 3; }

    /* Responsive design */
    @media (max-width: 768px) {
      .game-header {
        padding: 10px 15px;
        flex-direction: column;
        gap: 10px;
      }

      .game-area {
        padding: 10px;
      }

      .game-footer {
        padding: 8px 15px;
      }

      .touch-controls {
        display: grid;
      }
      
      .menu-card {
        padding: 25px;
        width: 95vw;
        max-height: 95vh;
      }
      
      .title {
        font-size: 2.2rem;
      }
      
      .game-modes {
        grid-template-columns: 1fr;
        gap: 15px;
      }
      
      .controls-info {
        grid-template-columns: 1fr;
      }

      .btn {
        padding: 12px 24px;
        font-size: 1rem;
        margin: 8px;
      }

      .mode-option {
        padding: 15px;
      }

      .mode-title {
        font-size: 1.1rem;
      }

      .mode-desc {
        font-size: 0.8rem;
      }

      .game-stats {
        flex-direction: column;
        gap: 10px;
        font-size: 1rem;
      }

      .score-panel {
        padding: 10px 15px;
      }
    }

    @media (max-width: 480px) {
      .game-header {
        padding: 8px 10px;
        flex-direction: column;
        gap: 8px;
      }

      .game-area {
        padding: 5px;
      }

      .game-footer {
        padding: 5px 10px;
      }

      .title {
        font-size: 1.8rem;
      }

      .menu-card {
        padding: 20px;
        width: 98vw;
      }

      .score-panel,
      .game-stats {
        padding: 10px 15px;
        font-size: 0.9rem;
      }

      .game-stats {
        flex-direction: column;
        gap: 8px;
      }
    }

    @media (max-height: 600px) {
      .menu-card {
        max-height: 95vh;
        padding: 25px;
      }
      
      .title {
        font-size: 1.5rem;
        margin-bottom: 10px;
      }
      
      .subtitle {
        font-size: 0.9rem;
        margin-bottom: 15px;
      }
      
      .game-modes {
        gap: 10px;
      }
      
      .mode-option {
        padding: 12px;
      }
    }

    .power-pellet-glow {
      animation: power-glow 0.5s ease-in-out infinite alternate;
    }

    @keyframes power-glow {
      0% { box-shadow: 0 0 10px var(--power-pellet); }
      100% { box-shadow: 0 0 20px var(--power-pellet), 0 0 30px var(--power-pellet); }
    }

    .frightened-mode {
      animation: frightened-flash 0.2s ease-in-out infinite;
    }

    @keyframes frightened-flash {
      0% { filter: brightness(1); }
      100% { filter: brightness(0.5) hue-rotate(180deg); }
    }

    /* Additional visual improvements */
    .score-popup {
      animation: score-float 1s ease-out forwards;
    }

    @keyframes score-float {
      0% { transform: translateY(0) scale(1); opacity: 1; }
      100% { transform: translateY(-30px) scale(1.2); opacity: 0; }
    }

    .maze-glow {
      box-shadow: 0 0 20px rgba(0, 102, 255, 0.3);
    }
  </style>
</head>
<body>
  <div id="gameContainer">
    <div class="game-header">
      <div class="score-panel">
        <div class="player-info">
          <span class="player-icon player1-icon"></span>
          <span>P1: <span id="player1Score">0</span></span>
        </div>
        <div class="player-info" id="player2Info" style="display: none;">
          <span class="player-icon player2-icon"></span>
          <span>P2: <span id="player2Score">0</span></span>
        </div>
      </div>
      <div class="game-stats">
        <div>Level: <span id="levelDisplay">1</span></div>
        <div>Lives: <span id="livesDisplay">3</span></div>
        <div>Bonus: <span id="bonusDisplay">0</span></div>
      </div>
    </div>

    <div class="game-area">
      <canvas id="gameCanvas" width="1200" height="870"></canvas>
    </div>

    <div class="game-footer">
      <button class="back-btn" onclick="goHome()" title="Back to Main Menu">
        ← HOME
      </button>

      <div class="paused-overlay" id="pausedOverlay">
        <div>PAUSED<br><small style="font-size: 1rem;">Press P or Start to resume</small></div>
      </div>

      <div class="ready-overlay" id="readyOverlay">
        READY!
      </div>

      <div class="touch-controls" id="touchControls">
        <button class="touch-btn up" data-direction="up">↑</button>
        <button class="touch-btn left" data-direction="left">←</button>
        <button class="touch-btn right" data-direction="right">→</button>
        <button class="touch-btn down" data-direction="down">↓</button>
      </div>
    </div>

    <!-- Menu overlay -->
    <div class="overlay" id="menuOverlay">
      <div class="menu-card">
        <h1 class="title">PAC-BATTLE</h1>
        <p class="subtitle">Navigate the maze, collect dots, avoid ghosts!</p>
        
        <div class="game-modes">
          <div class="mode-option active" data-mode="classic">
            <div class="mode-title">🟡 CLASSIC</div>
            <div class="mode-desc">Single player vs AI ghosts<br>Traditional Pac-Man experience</div>
          </div>
          <div class="mode-option" data-mode="versus">
            <div class="mode-title">⚔️ VERSUS</div>
            <div class="mode-desc">2 players compete<br>Race to collect the most dots</div>
          </div>
          <div class="mode-option" data-mode="cooperative">
            <div class="mode-title">🤝 CO-OP</div>
            <div class="mode-desc">2 players team up<br>Work together against ghosts</div>
          </div>
        </div>

        <div class="controls-info">
          <div class="control-section">
            <div class="control-title">Player 1 Controls</div>
            <div>
              <span class="kbd">↑</span><span class="kbd">↓</span><span class="kbd">←</span><span class="kbd">→</span> or 
              <span class="kbd">W</span><span class="kbd">A</span><span class="kbd">S</span><span class="kbd">D</span>
            </div>
          </div>
          <div class="control-section">
            <div class="control-title">Player 2 Controls</div>
            <div>
              <span class="kbd">I</span><span class="kbd">J</span><span class="kbd">K</span><span class="kbd">L</span> or 
              🎮 Gamepad
            </div>
          </div>
          <div class="control-section">
            <div class="control-title">Game Controls</div>
            <div>
              <span class="kbd">P</span> Pause • <span class="kbd">F</span> Fullscreen<br>
              <span class="kbd">R</span> Restart Level
            </div>
          </div>
        </div>

        <button class="btn" onclick="startGame()">START GAME</button>
      </div>
    </div>

    <!-- Game Over overlay -->
    <div class="overlay hidden" id="gameOverOverlay">
      <div class="menu-card">
        <h1 class="title">GAME OVER</h1>
        <div id="finalStats" style="margin: 25px 0; font-size: 1.3rem;"></div>
        <div style="display: flex; gap: 15px; justify-content: center; flex-wrap: wrap;">
          <button class="btn" onclick="restartGame()">PLAY AGAIN</button>
          <button class="btn" onclick="showMenu()">MAIN MENU</button>
        </div>
      </div>
    </div>
  </div>

  <script>
    // Game configuration
    const CONFIG = {
      CELL_SIZE: 30, // Updated to match new canvas dimensions (1200/40 = 30)
      MAZE_WIDTH: 40,
      MAZE_HEIGHT: 29, // Fixed: should match actual maze height
      PLAYER_SPEED: 150, // ms between moves
      GHOST_SPEED: 180,
      FRIGHTENED_DURATION: 8000, // 8 seconds
      POINTS: {
        DOT: 10,
        POWER_PELLET: 50,
        GHOST: 200,
        FRUIT: 100
      },
      COLORS: {
        wall: '#00ccff', // Very bright blue for maximum visibility
        dot: '#ffcc00',
        powerPellet: '#ffffff',
        player1: '#ffff00',
        player2: '#ff0000',
        ghosts: ['#ff0000', '#ffb8ff', '#00ffff', '#ffb852'],
        ghostFrightened: '#0000ff',
        ghostEyes: '#ffffff'
      }
    };

    // New maze layout with no dead ends and proper connectivity
    const MAZE_LAYOUT = [
      [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
      [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
      [1,3,1,1,1,1,2,1,1,1,1,1,2,1,1,1,1,1,2,1,1,2,1,1,1,1,1,2,1,1,1,1,1,2,1,1,1,1,3,1],
      [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
      [1,2,1,1,1,1,2,1,1,2,1,1,1,1,1,1,2,1,1,1,1,1,1,2,1,1,1,1,1,1,2,1,1,2,1,1,1,1,2,1],
      [1,2,2,2,2,2,2,1,1,2,2,2,2,1,1,2,2,2,2,1,1,2,2,2,2,1,1,2,2,2,2,1,1,2,2,2,2,2,2,1],
      [1,1,1,1,1,1,2,1,1,1,1,1,0,1,1,2,1,1,2,1,1,2,1,1,2,1,1,0,1,1,1,1,1,2,1,1,1,1,1,1],
      [0,0,0,0,0,1,2,1,1,2,2,2,2,2,2,2,1,1,2,1,1,2,1,1,2,2,2,2,2,2,2,1,1,2,1,0,0,0,0,0],
      [1,1,1,1,1,1,2,1,1,2,1,1,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,1,1,2,1,1,2,1,1,1,1,1,1],
      [2,2,2,2,2,2,2,2,2,2,1,4,0,0,4,0,0,0,0,0,0,0,0,0,0,4,0,0,4,1,2,2,2,2,2,2,2,2,2,2],
      [1,1,1,1,1,1,2,1,1,2,1,0,0,0,0,0,1,1,1,0,0,1,1,1,0,0,0,0,0,1,2,1,1,2,1,1,1,1,1,1],
      [0,0,0,0,0,1,2,1,1,2,1,1,1,1,1,0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,2,1,1,2,1,0,0,0,0,0],
      [1,1,1,1,1,1,2,1,1,2,2,2,2,2,2,2,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,1,1,2,1,1,1,1,1,1],
      [1,2,2,2,2,2,2,2,2,2,1,1,1,1,1,2,1,1,1,1,1,1,1,1,2,1,1,1,1,1,2,2,2,2,2,2,2,2,2,1],
      [1,2,1,1,1,1,2,1,1,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,2,1,1,2,1,1,1,1,2,1],
      [1,3,2,2,1,1,2,2,2,2,1,1,2,1,1,1,1,1,2,1,1,2,1,1,1,1,1,2,1,1,2,2,2,2,1,1,2,2,3,1],
      [1,1,1,2,1,1,2,1,1,1,1,1,2,1,1,2,2,2,2,2,2,2,2,2,2,1,1,2,1,1,1,1,1,2,1,1,2,1,1,1],
      [1,2,2,2,2,2,2,1,1,2,2,2,2,1,1,2,1,1,1,1,1,1,1,1,2,1,1,2,2,2,2,1,1,2,2,2,2,2,2,1],
      [1,2,1,1,1,1,1,1,1,2,1,1,1,1,1,2,1,1,2,2,2,2,1,1,2,1,1,1,1,1,2,1,1,1,1,1,1,1,2,1],
      [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,1,1,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
      [1,1,1,2,1,1,1,1,1,2,1,1,1,1,1,1,1,1,2,1,1,2,1,1,1,1,1,1,1,1,2,1,1,1,1,1,2,1,1,1],
      [1,3,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,1],
      [1,2,1,1,1,1,2,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,2,1,1,1,1,1,2,1],
      [1,2,2,2,2,1,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,1,2,2,2,2,2,1],
      [1,1,1,1,2,1,2,1,1,2,1,1,1,1,1,1,1,2,1,1,1,1,2,1,1,1,1,1,1,1,2,1,1,2,1,2,1,1,1,1],
      [1,2,2,2,2,2,2,1,1,2,2,2,2,1,1,2,2,2,2,1,1,2,2,2,2,1,1,2,2,2,2,1,1,2,2,2,2,2,2,1],
      [1,2,1,1,1,1,1,1,1,1,1,1,2,1,1,2,1,1,2,1,1,2,1,1,2,1,1,2,1,1,1,1,1,1,1,1,1,1,2,1],
      [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
      [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
    ];

    // Game state
    let gameState = {
      running: false,
      paused: false,
      mode: 'classic', // classic, versus, cooperative
      level: 1,
      players: [],
      ghosts: [],
      maze: [],
      dots: [],
      powerPellets: [],
      score: [0, 0],
      lives: 3,
      dotsRemaining: 0,
      frightendMode: false,
      frightendTimer: 0,
      bonusPoints: 0,
      gameSpeed: CONFIG.PLAYER_SPEED,
      lastUpdateTime: 0,
      pausePressed: false,
      fullscreenPressed: false,
      restartPressed: false,
      ghostsEatenCount: 0, // Added for ghost eaten count
      scorePopups: [] // Added for score popup animations
    };

    // Input handling
    class InputManager {
      constructor() {
        this.keys = new Set();
        this.touchDir = null;
        this.setupEventListeners();
      }

      setupEventListeners() {
        document.addEventListener('keydown', (e) => {
          this.keys.add(e.code);
          if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Space'].includes(e.code)) {
            e.preventDefault();
          }
        });

        document.addEventListener('keyup', (e) => {
          this.keys.delete(e.code);
        });

        // Touch controls
        document.querySelectorAll('.touch-btn').forEach(btn => {
          btn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            this.touchDir = btn.dataset.dir;
          });
          
          btn.addEventListener('touchend', (e) => {
            e.preventDefault();
            this.touchDir = null;
          });
        });
      }

      getPlayerInput(playerIndex) {
        // Gamepad support for player 2
        if (playerIndex === 1) {
          const gamepad = navigator.getGamepads()[0];
          if (gamepad) {
            const threshold = 0.5;
            if (gamepad.axes[1] < -threshold || gamepad.buttons[12]?.pressed) return 'up';
            if (gamepad.axes[1] > threshold || gamepad.buttons[13]?.pressed) return 'down';
            if (gamepad.axes[0] < -threshold || gamepad.buttons[14]?.pressed) return 'left';
            if (gamepad.axes[0] > threshold || gamepad.buttons[15]?.pressed) return 'right';
          }
          
          // Keyboard for player 2
          if (this.keys.has('KeyI')) return 'up';
          if (this.keys.has('KeyK')) return 'down';
          if (this.keys.has('KeyJ')) return 'left';
          if (this.keys.has('KeyL')) return 'right';
        } else {
          // Player 1 keyboard and touch
          if (this.keys.has('ArrowUp') || this.keys.has('KeyW')) return 'up';
          if (this.keys.has('ArrowDown') || this.keys.has('KeyS')) return 'down';
          if (this.keys.has('ArrowLeft') || this.keys.has('KeyA')) return 'left';
          if (this.keys.has('ArrowRight') || this.keys.has('KeyD')) return 'right';
          if (this.touchDir) return this.touchDir;
        }
        return null;
      }

      isPausePressed() {
        if (this.keys.has('KeyP')) return true;
        const gamepad = navigator.getGamepads()[0];
        return gamepad?.buttons[9]?.pressed; // Start button
      }

      isFullscreenPressed() {
        return this.keys.has('KeyF');
      }

      isRestartPressed() {
        return this.keys.has('KeyR');
      }
    }

    // Audio system
    class AudioManager {
      constructor() {
        this.context = null;
        this.enabled = false;
      }

      async init() {
        try {
          this.context = new (window.AudioContext || window.webkitAudioContext)();
          if (this.context.state === 'suspended') {
            await this.context.resume();
          }
          this.enabled = true;
        } catch (e) {
          console.warn('Audio not available');
        }
      }

      playTone(frequency, duration = 0.1, type = 'square', volume = 0.1) {
        if (!this.enabled || !this.context) return;

        const oscillator = this.context.createOscillator();
        const gainNode = this.context.createGain();

        oscillator.connect(gainNode);
        gainNode.connect(this.context.destination);

        oscillator.frequency.value = frequency;
        oscillator.type = type;
        gainNode.gain.value = volume;

        oscillator.start();
        oscillator.stop(this.context.currentTime + duration);
      }

      playChomp() {
        this.playTone(800, 0.1, 'square', 0.1);
        setTimeout(() => this.playTone(600, 0.1, 'square', 0.1), 50);
      }

      playPowerPellet() {
        this.playTone(200, 0.1, 'sine', 0.15);
        setTimeout(() => this.playTone(300, 0.1, 'sine', 0.15), 100);
        setTimeout(() => this.playTone(400, 0.2, 'sine', 0.15), 200);
      }

      playGhostEaten() {
        this.playTone(1000, 0.2, 'sine', 0.15);
        setTimeout(() => this.playTone(800, 0.2, 'sine', 0.15), 100);
      }

      playDeath() {
        for (let i = 0; i < 8; i++) {
          setTimeout(() => {
            this.playTone(800 - i * 100, 0.1, 'sawtooth', 0.1);
          }, i * 100);
        }
      }

      playLevelComplete() {
        for (let i = 0; i < 5; i++) {
          setTimeout(() => {
            this.playTone(400 + i * 200, 0.2, 'sine', 0.1);
          }, i * 150);
        }
      }
    }

    // Game entities
    class ScorePopup {
      constructor(x, y, points, color) {
        this.x = x;
        this.y = y;
        this.points = points;
        this.color = color;
        this.life = 60; // 60 frames = 1 second at 60fps
        this.alpha = 1.0;
        this.offsetY = 0;
      }

      update() {
        this.life--;
        this.alpha = this.life / 60;
        this.offsetY -= 0.5; // Float upward
      }

      render(ctx) {
        if (this.life <= 0) return;

        const screenX = this.x * CONFIG.CELL_SIZE + CONFIG.CELL_SIZE / 2;
        const screenY = this.y * CONFIG.CELL_SIZE + CONFIG.CELL_SIZE / 2 + this.offsetY;

        ctx.save();
        ctx.globalAlpha = this.alpha;
        ctx.fillStyle = this.color;
        ctx.font = `bold ${16 + (60 - this.life)}px Orbitron`;
        ctx.textAlign = 'center';
        ctx.shadowColor = this.color;
        ctx.shadowBlur = 10;
        ctx.fillText(`+${this.points}`, screenX, screenY);
        ctx.restore();
      }
    }

    class Player {
      constructor(x, y, color, playerIndex) {
        this.x = x;
        this.y = y;
        this.targetX = x;
        this.targetY = y;
        this.direction = { x: 0, y: 0 };
        this.nextDirection = { x: 0, y: 0 };
        this.color = color;
        this.playerIndex = playerIndex;
        this.alive = true;
        this.score = 0;
        this.animFrame = 0;
        this.moving = false;
      }

      update() {
        if (!this.alive) return;

        // Try to change direction if requested
        if (this.nextDirection.x !== 0 || this.nextDirection.y !== 0) {
          const newX = this.x + this.nextDirection.x;
          const newY = this.y + this.nextDirection.y;
          if (this.canMoveTo(newX, newY)) {
            this.direction = { ...this.nextDirection };
            this.nextDirection = { x: 0, y: 0 };
          }
        }

        // Continue moving in current direction
        if (this.direction.x !== 0 || this.direction.y !== 0) {
          const newX = this.x + this.direction.x;
          const newY = this.y + this.direction.y;
          
          if (this.canMoveTo(newX, newY)) {
            this.x = newX;
            this.y = newY;
            this.moving = true;
            this.animFrame = (this.animFrame + 1) % 8;
            
            // Handle tunnel wrapping
            if (this.x < 0) this.x = CONFIG.MAZE_WIDTH - 1;
            if (this.x >= CONFIG.MAZE_WIDTH) this.x = 0;
            
            this.collectItems();
          } else {
            this.moving = false;
            // Don't reset direction here - keep it for when path becomes available
          }
        } else {
          this.moving = false;
        }
      }

      canMoveTo(x, y) {
        if (y < 0 || y >= CONFIG.MAZE_HEIGHT) return false;
        if (x < 0 || x >= CONFIG.MAZE_WIDTH) return true; // Tunnel
        return gameState.maze[y][x] !== 1; // Not a wall
      }

      collectItems() {
        const pos = this.y * CONFIG.MAZE_WIDTH + this.x;
        
        // Collect dots
        if (gameState.dots.has(pos)) {
          gameState.dots.delete(pos);
          this.score += CONFIG.POINTS.DOT;
          gameState.dotsRemaining--;
          audio.playChomp();
          
          // Create score popup
          gameState.scorePopups.push(new ScorePopup(this.x, this.y, CONFIG.POINTS.DOT, this.color));
        }
        
        // Collect power pellets
        if (gameState.powerPellets.has(pos)) {
          gameState.powerPellets.delete(pos);
          this.score += CONFIG.POINTS.POWER_PELLET;
          audio.playPowerPellet();
          
          // Create score popup
          gameState.scorePopups.push(new ScorePopup(this.x, this.y, CONFIG.POINTS.POWER_PELLET, this.color));
          
          // Activate frightened mode
          gameState.frightendMode = true;
          gameState.frightendTimer = CONFIG.FRIGHTENED_DURATION;
          gameState.ghostsEatenCount = 0; // Reset ghost eaten count
          gameState.ghosts.forEach(ghost => {
            if (ghost.mode !== 'eaten') {
              ghost.mode = 'frightened';
              ghost.reverseDirection();
            }
          });
        }
      }

      setDirection(newDir) {
        this.nextDirection = newDir;
      }

      render(ctx) {
        if (!this.alive) return;

        const x = this.x * CONFIG.CELL_SIZE + CONFIG.CELL_SIZE / 2;
        const y = this.y * CONFIG.CELL_SIZE + CONFIG.CELL_SIZE / 2;
        const radius = CONFIG.CELL_SIZE * 0.4;

        ctx.fillStyle = this.color;
        ctx.shadowColor = this.color;
        ctx.shadowBlur = 15;

        // Draw Pac-Man with opening mouth animation
        ctx.beginPath();
        
        if (this.moving) {
          const mouthAngle = Math.PI * 0.7 * (Math.sin(this.animFrame * 0.5) * 0.5 + 0.5);
          let startAngle = 0;
          
          // Adjust mouth direction based on movement
          if (this.direction.x > 0) startAngle = 0; // Right
          else if (this.direction.x < 0) startAngle = Math.PI; // Left
          else if (this.direction.y < 0) startAngle = -Math.PI/2; // Up
          else if (this.direction.y > 0) startAngle = Math.PI/2; // Down
          
          ctx.arc(x, y, radius, startAngle + mouthAngle/2, startAngle - mouthAngle/2);
          ctx.lineTo(x, y);
        } else {
          ctx.arc(x, y, radius, 0, Math.PI * 2);
        }
        
        ctx.fill();
        ctx.shadowBlur = 0;
      }
    }

    class Ghost {
      constructor(x, y, color, type) {
        this.x = x;
        this.y = y;
        this.color = color;
        this.type = type;
        this.direction = { x: 1, y: 0 }; // Start moving right
        this.mode = 'chase'; // chase, scatter, frightened, eaten
        this.modeTimer = 0;
        this.target = { x: 0, y: 0 };
        this.animFrame = 0;
        this.scatterTarget = this.getScatterTarget();
        this.lastModeSwitch = 0;
        this.modeDuration = 1000; // 1000 frames for chase, 500 for scatter
      }

      getScatterTarget() {
        const scatterTargets = [
          { x: 2, y: 2 },                    // Top-left corner
          { x: CONFIG.MAZE_WIDTH - 3, y: 2 }, // Top-right corner
          { x: CONFIG.MAZE_WIDTH - 3, y: CONFIG.MAZE_HEIGHT - 3 }, // Bottom-right corner
          { x: 2, y: CONFIG.MAZE_HEIGHT - 3 }  // Bottom-left corner
        ];
        return scatterTargets[this.type % 4];
      }

      update() {
        this.animFrame = (this.animFrame + 1) % 16;
        
        // Update mode timer
        this.modeTimer++;
        
        // Switch between chase and scatter modes based on authentic Pac-Man timing
        if (this.mode === 'chase' && this.modeTimer > this.modeDuration) {
          this.mode = 'scatter';
          this.modeTimer = 0;
          this.reverseDirection();
        } else if (this.mode === 'scatter' && this.modeTimer > 500) {
          this.mode = 'chase';
          this.modeTimer = 0;
          this.reverseDirection();
        }
        
        // Choose target based on mode and type
        this.chooseTarget();
        
        // If ghost is stationary, choose a good starting direction
        if (this.direction.x === 0 && this.direction.y === 0) {
          this.chooseInitialDirection();
        }
        
        // Move at controlled speed (every few frames)
        if (this.mode === 'eaten') {
          // Eaten ghosts move faster and more directly
          if (this.animFrame % 2 === 0) { // Move every 2 frames when eaten
            this.move();
          }
        } else if (this.mode === 'chase' && this.modeTimer < 30) {
          // Ghosts wait 0.5 seconds after respawning before moving
          // This prevents them from immediately chasing the player
        } else if (this.mode === 'frightened') {
          // Frightened ghosts move slower (more vulnerable)
          if (this.animFrame % 4 === 0) { // Move every 4 frames when frightened
            this.move();
          }
        } else if (this.animFrame % 2 === 0) { // Move every 2 frames for more responsive movement
          this.move();
        }
        
        // Debug: Log ghost movement
        if (this.type === 0 && this.animFrame % 60 === 0) { // Log every second for Blinky
          console.log(`Ghost ${this.type} (${this.mode}): pos(${this.x}, ${this.y}), dir(${this.direction.x}, ${this.direction.y}), target(${this.target.x}, ${this.target.y})`);
        }
        
        // Debug: Log eaten ghost behavior
        if (this.mode === 'eaten' && this.animFrame % 30 === 0) { // Log every 0.5 seconds for eaten ghosts
          console.log(`Eaten Ghost ${this.type}: pos(${this.x}, ${this.y}), target(${this.target.x}, ${this.target.y}), modeTimer: ${this.modeTimer}`);
        }
        
        // Handle tunnel wrapping
        if (this.x < 0) this.x = CONFIG.MAZE_WIDTH - 1;
        if (this.x >= CONFIG.MAZE_WIDTH) this.x = 0;
        
        // Check collision with players
        this.checkPlayerCollision();
      }

      chooseTarget() {
        const player = gameState.players[0]; // Primary target is player 1
        
        if (this.mode === 'frightened') {
          // Actively flee from player when frightened
          const player = gameState.players[0];
          // Calculate opposite direction from player
          const dx = this.x - player.x;
          const dy = this.y - player.y;
          
          // Set target to opposite side of maze from player
          let targetX = this.x + (dx > 0 ? 10 : -10);
          let targetY = this.y + (dy > 0 ? 10 : -10);
          
          // Ensure target is within maze bounds
          targetX = Math.max(2, Math.min(CONFIG.MAZE_WIDTH - 3, targetX));
          targetY = Math.max(2, Math.min(CONFIG.MAZE_HEIGHT - 3, targetY));
          
          this.target = { x: targetX, y: targetY };
        } else if (this.mode === 'eaten') {
          // Return to ghost house - target the entrance area
          this.target = { x: 20, y: 9 };
          
          // Debug: Log eaten ghost targeting
          if (this.animFrame % 60 === 0) {
            console.log(`Eaten Ghost ${this.type}: at (${this.x}, ${this.y}), targeting (${this.target.x}, ${this.target.y}), distance: ${Math.abs(this.x - 20) + Math.abs(this.y - 9)}`);
          }
          
          // Emergency unstuck logic - if ghost is stuck for too long, teleport closer to house
          if (this.modeTimer > 300) { // 5 seconds stuck
            console.log(`Ghost ${this.type} stuck for too long, teleporting closer to house`);
            // Teleport to a position closer to the house
            if (Math.abs(this.x - 20) > 5 || Math.abs(this.y - 9) > 5) {
              this.x = 20 + (Math.random() > 0.5 ? 5 : -5);
              this.y = 9 + (Math.random() > 0.5 ? 5 : -5);
              this.modeTimer = 0; // Reset timer
            }
          }
          
          // Check if ghost is close enough to the house entrance to enter
          if (Math.abs(this.x - 20) <= 1 && Math.abs(this.y - 9) <= 1) {
            // Move to house entrance
            this.x = 20;
            this.y = 9;
            // Stay in house for a moment before respawning
            if (this.modeTimer > 60) { // 1 second at 60fps for faster respawn
              console.log(`Ghost ${this.type} respawning!`);
              this.mode = 'chase';
              this.modeTimer = 0;
              
              // Reset to starting position and direction based on ghost type
              switch (this.type) {
                case 0: // Blinky - starts outside
                  this.x = 20;
                  this.y = 8;
                  this.direction = { x: -1, y: 0 }; // Start moving left
                  break;
                case 1: // Pinky - starts just outside the house
                  this.x = 19;
                  this.y = 8;
                  this.direction = { x: 1, y: 0 }; // Start moving right
                  break;
                case 2: // Inky - starts just outside the house
                  this.x = 21;
                  this.y = 8;
                  this.direction = { x: 1, y: 0 }; // Start moving right
                  break;
                case 3: // Clyde - starts just outside the house
                  this.x = 22;
                  this.y = 8;
                  this.direction = { x: -1, y: 0 }; // Start moving left
                  break;
              }
              
              // Ensure ghost is in a valid position
              if (!this.canMoveTo(this.x, this.y)) {
                // Find nearest valid position
                for (let offset = 1; offset <= 3; offset++) {
                  for (let dx = -offset; dx <= offset; dx++) {
                    for (let dy = -offset; dy <= offset; dy++) {
                      if (this.canMoveTo(this.x + dx, this.y + dy)) {
                        this.x += dx;
                        this.y += dy;
                        console.log(`Ghost ${this.type} adjusted to valid position: (${this.x}, ${this.y})`);
                        return;
                      }
                    }
                  }
                }
              }
            }
          }
        } else if (this.mode === 'scatter') {
          // Go to assigned corner
          this.target = this.scatterTarget;
        } else {
          // Chase mode - different strategy per ghost type
          switch (this.type) {
            case 0: // Red ghost (Blinky) - direct chase with slight prediction
              // If player is stationary, target directly at player
              if (player.direction.x === 0 && player.direction.y === 0) {
                this.target = { x: player.x, y: player.y };
              } else {
                const blinkyTargetX = player.x + player.direction.x * 2;
                const blinkyTargetY = player.y + player.direction.y * 2;
                this.target = { 
                  x: Math.max(0, Math.min(CONFIG.MAZE_WIDTH - 1, blinkyTargetX)),
                  y: Math.max(0, Math.min(CONFIG.MAZE_HEIGHT - 1, blinkyTargetY))
                };
              }
              break;
            case 1: // Pink ghost (Pinky) - ambush 4 tiles ahead
              // If player is stationary, target slightly to the side
              if (player.direction.x === 0 && player.direction.y === 0) {
                this.target = { x: player.x + 2, y: player.y + 2 };
              } else {
                const targetX = player.x + player.direction.x * 4;
                const targetY = player.y + player.direction.y * 4;
                this.target = { 
                  x: Math.max(0, Math.min(CONFIG.MAZE_WIDTH - 1, targetX)),
                  y: Math.max(0, Math.min(CONFIG.MAZE_HEIGHT - 1, targetY))
                };
              }
              break;
            case 2: // Cyan ghost (Inky) - complex targeting based on red ghost
              const redGhost = gameState.ghosts[0];
              if (redGhost && redGhost.mode !== 'eaten') {
                if (player.direction.x === 0 && player.direction.y === 0) {
                  // If player is stationary, use simple targeting
                  this.target = { x: player.x, y: player.y };
                } else {
                  const vectorX = (player.x + player.direction.x * 2) - redGhost.x;
                  const vectorY = (player.y + player.direction.y * 2) - redGhost.y;
                  this.target = {
                    x: Math.max(0, Math.min(CONFIG.MAZE_WIDTH - 1, redGhost.x + vectorX * 2)),
                    y: Math.max(0, Math.min(CONFIG.MAZE_HEIGHT - 1, redGhost.y + vectorY * 2))
                  };
                }
              } else {
                this.target = { x: player.x, y: player.y };
              }
              break;
            case 3: // Orange ghost (Clyde) - chase if far, scatter if close
              const distance = Math.abs(this.x - player.x) + Math.abs(this.y - player.y);
              if (distance > 8) {
                this.target = { x: player.x, y: player.y };
              } else {
                this.target = this.scatterTarget;
              }
              break;
          }
        }
      }

      move() {
        // Always try to move in current direction first
        const newX = this.x + this.direction.x;
        const newY = this.y + this.direction.y;
        
        if (this.canMoveTo(newX, newY)) {
          this.x = newX;
          this.y = newY;
        } else {
          // Hit a wall, need to find new direction
          this.findNewDirection();
        }
        
        // Ensure we're still within bounds after movement
        this.x = Math.max(0, Math.min(CONFIG.MAZE_WIDTH - 1, this.x));
        this.y = Math.max(0, Math.min(CONFIG.MAZE_HEIGHT - 1, this.y));
        
        // Ensure ghosts stay on integer grid coordinates
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
      }



      findNewDirection() {
        const directions = [
          { x: 0, y: -1 }, // Up
          { x: 1, y: 0 },  // Right
          { x: 0, y: 1 },  // Down
          { x: -1, y: 0 }  // Left
        ];

        let bestDirection = null;
        let bestScore = this.mode === 'frightened' ? -Infinity : Infinity;

        // Try each direction (except reverse) to find a valid move
        for (const dir of directions) {
          // Don't reverse direction unless in frightened mode or eaten mode
          if (dir.x === -this.direction.x && dir.y === -this.direction.y && this.mode !== 'frightened' && this.mode !== 'eaten') {
            continue;
          }

          const newX = this.x + dir.x;
          const newY = this.y + dir.y;

          if (this.canMoveTo(newX, newY)) {
            let score = 0;
            
            if (this.mode === 'frightened') {
              // In frightened mode, actively flee from player
              const player = gameState.players[0];
              const distanceToPlayer = Math.abs(newX - player.x) + Math.abs(newY - player.y);
              score = distanceToPlayer; // Higher score = further from player = better
              
              // Bonus for moving towards open areas
              const openDirections = this.countOpenDirections(newX, newY);
              score += openDirections * 2;
            } else if (this.mode === 'eaten') {
              // Eaten ghosts prioritize the most direct path to ghost house
              const distance = Math.abs(newX - this.target.x) + Math.abs(newY - this.target.y);
              score = -distance; // Lower score = closer to target = better
              
              // Bonus for moving towards the house entrance
              const houseX = 20;
              const houseY = 9;
              const currentDistance = Math.abs(this.x - houseX) + Math.abs(this.y - houseY);
              const newDistance = Math.abs(newX - houseX) + Math.abs(newY - houseY);
              if (newDistance < currentDistance) {
                score -= 20; // Big bonus for moving closer to house
              }
            } else {
              // Normal mode - intelligent pathfinding
              const distance = Math.abs(newX - this.target.x) + Math.abs(newY - this.target.y);
              score = -distance; // Lower score = closer to target = better
              
              // Bonus for avoiding dead ends
              const openDirections = this.countOpenDirections(newX, newY);
              if (openDirections === 1) score -= 10; // Penalty for dead ends
              else if (openDirections >= 3) score += 5; // Bonus for intersections
              
              // Ghost-specific behavior improvements
              if (this.type === 1) { // Pinky - prefer ambush positions
                const player = gameState.players[0];
                const ambushX = player.x + player.direction.x * 4;
                const ambushY = player.y + player.direction.y * 4;
                const ambushDistance = Math.abs(newX - ambushX) + Math.abs(newY - ambushY);
                score -= ambushDistance * 0.5;
              }
            }
            
            if (this.mode === 'frightened') {
              if (score > bestScore) {
                bestScore = score;
                bestDirection = dir;
              }
            } else {
              if (score < bestScore) {
                bestScore = score;
                bestDirection = dir;
              }
            }
          }
        }
        
        if (bestDirection) {
          this.direction = bestDirection;
        } else {
          // If no valid direction found, try to reverse (emergency fallback)
          this.direction.x *= -1;
          this.direction.y *= -1;
        }
      }

      countOpenDirections(x, y) {
        const directions = [
          { x: 0, y: -1 }, { x: 1, y: 0 }, { x: 0, y: 1 }, { x: -1, y: 0 }
        ];
        let count = 0;
        for (const dir of directions) {
          if (this.canMoveTo(x + dir.x, y + dir.y)) {
            count++;
          }
        }
        return count;
      }

      canMoveTo(x, y) {
        if (y < 0 || y >= CONFIG.MAZE_HEIGHT) return false;
        if (x < 0 || x >= CONFIG.MAZE_WIDTH) return true; // Tunnel
        
        // Allow ghosts to move through ghost house area (value 4) when eaten or when starting
        if ((this.mode === 'eaten' || this.mode === 'chase') && gameState.maze[y][x] === 4) {
          return true;
        }
        
        return gameState.maze[y][x] !== 1; // Not a wall
      }

      chooseInitialDirection() {
        const directions = [
          { x: 0, y: -1 }, // Up
          { x: 1, y: 0 },  // Right
          { x: 0, y: 1 },  // Down
          { x: -1, y: 0 }  // Left
        ];
        
        // Try to find a valid direction that moves towards the target
        for (const dir of directions) {
          const newX = this.x + dir.x;
          const newY = this.y + dir.y;
          if (this.canMoveTo(newX, newY)) {
            this.direction = dir;
            break;
          }
        }
      }



      reverseDirection() {
        this.direction.x *= -1;
        this.direction.y *= -1;
      }

      checkPlayerCollision() {
        for (const player of gameState.players) {
          if (player.alive && player.x === this.x && player.y === this.y) {
            if (this.mode === 'frightened') {
              // Ghost eaten
              this.mode = 'eaten';
              this.modeTimer = 0;
              const points = CONFIG.POINTS.GHOST * Math.pow(2, gameState.ghostsEatenCount || 0);
              player.score += points;
              gameState.ghostsEatenCount = (gameState.ghostsEatenCount || 0) + 1;
              
              // Create score popup
              gameState.scorePopups.push(new ScorePopup(this.x, this.y, points, player.color));
              
              audio.playGhostEaten();
            } else if (this.mode !== 'eaten') {
              // Player caught
              player.alive = false;
              gameState.lives--;
              gameState.ghostsEatenCount = 0; // Reset ghost eaten count
              audio.playDeath();
              
              if (gameState.lives <= 0) {
                endGame();
              } else {
                respawnPlayer(player);
              }
            }
          }
        }
      }

      render(ctx) {
        const x = this.x * CONFIG.CELL_SIZE;
        const y = this.y * CONFIG.CELL_SIZE;
        const size = CONFIG.CELL_SIZE * 0.9;

        if (this.mode === 'eaten') {
          // Check if ghost is in the house and respawning
          if (this.x === 20 && this.y === 9 && this.modeTimer > 60) {
            // Show respawning animation (fading in)
            const alpha = Math.min(1, (this.modeTimer - 60) / 60);
            ctx.globalAlpha = alpha;
            ctx.fillStyle = this.color;
            ctx.shadowColor = this.color;
            ctx.shadowBlur = 10;
            
            // Draw ghost body with fade-in effect
            ctx.beginPath();
            ctx.arc(x + size/2, y + size/2, size/2, Math.PI, 0);
            ctx.lineTo(x + size, y + size * 0.8);
            
            // Wavy bottom
            const waveOffset = this.animFrame * 0.3;
            for (let i = 0; i <= 4; i++) {
              const waveX = x + (i / 4) * size;
              const waveY = y + size * 0.8 + Math.sin(waveOffset + i) * size * 0.1;
              ctx.lineTo(waveX, waveY);
            }
            
            ctx.lineTo(x, y + size * 0.8);
            ctx.closePath();
            ctx.fill();
            
            // Draw eyes
            ctx.fillStyle = CONFIG.COLORS.ghostEyes;
            ctx.shadowBlur = 0;
            ctx.fillRect(x + size * 0.2, y + size * 0.3, size * 0.15, size * 0.2);
            ctx.fillRect(x + size * 0.65, y + size * 0.3, size * 0.15, size * 0.2);
            
            ctx.globalAlpha = 1;
            return;
          } else {
            // Just draw eyes when eaten and traveling
            ctx.fillStyle = CONFIG.COLORS.ghostEyes;
            ctx.fillRect(x + size * 0.2, y + size * 0.3, size * 0.2, size * 0.2);
            ctx.fillRect(x + size * 0.6, y + size * 0.3, size * 0.2, size * 0.2);
            return;
          }
        }

        // Ghost body color
        let bodyColor = this.color;
        if (this.mode === 'frightened') {
          // Flash between blue and white when frightened time is running out
          if (gameState.frightendTimer < 2000) {
            // Flash rapidly when time is almost up
            bodyColor = Math.floor(Date.now() / 100) % 2 ? '#ffffff' : CONFIG.COLORS.ghostFrightened;
          } else {
            bodyColor = CONFIG.COLORS.ghostFrightened;
          }
        }

        ctx.fillStyle = bodyColor;
        ctx.shadowColor = bodyColor;
        ctx.shadowBlur = 10;

        // Draw ghost body (rounded top, wavy bottom)
        ctx.beginPath();
        ctx.arc(x + size/2, y + size/2, size/2, Math.PI, 0);
        ctx.lineTo(x + size, y + size * 0.8);
        
        // Wavy bottom
        const waveOffset = this.animFrame * 0.3;
        for (let i = 0; i <= 4; i++) {
          const waveX = x + (i / 4) * size;
          const waveY = y + size * 0.8 + Math.sin(waveOffset + i) * size * 0.1;
          ctx.lineTo(waveX, waveY);
        }
        
        ctx.lineTo(x, y + size * 0.8);
        ctx.closePath();
        ctx.fill();

        // Draw eyes
        ctx.fillStyle = CONFIG.COLORS.ghostEyes;
        ctx.shadowBlur = 0;
        ctx.fillRect(x + size * 0.2, y + size * 0.3, size * 0.15, size * 0.2);
        ctx.fillRect(x + size * 0.65, y + size * 0.3, size * 0.15, size * 0.2);

        // Eye pupils
        ctx.fillStyle = '#000000';
        const pupilOffsetX = this.direction.x * 2;
        const pupilOffsetY = this.direction.y * 2;
        ctx.fillRect(x + size * 0.22 + pupilOffsetX, y + size * 0.35 + pupilOffsetY, size * 0.06, size * 0.08);
        ctx.fillRect(x + size * 0.67 + pupilOffsetX, y + size * 0.35 + pupilOffsetY, size * 0.06, size * 0.08);
      }
      
      reset() {
        // Reset ghost to starting position and state
        switch (this.type) {
          case 0: // Blinky - starts outside
            this.x = 20;
            this.y = 8;
            this.direction = { x: -1, y: 0 };
            break;
          case 1: // Pinky - starts just outside the house
            this.x = 19;
            this.y = 8;
            this.direction = { x: 1, y: 0 };
            break;
          case 2: // Inky - starts just outside the house
            this.x = 21;
            this.y = 8;
            this.direction = { x: 1, y: 0 };
            break;
          case 3: // Clyde - starts just outside the house
            this.x = 22;
            this.y = 8;
            this.direction = { x: -1, y: 0 };
            break;
        }
        this.mode = 'chase';
        this.modeTimer = this.type * 200; // Stagger start times
        this.target = null;
      }
    }

    // Initialize game systems
    const input = new InputManager();
    const audio = new AudioManager();

    // Canvas setup
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    ctx.imageSmoothingEnabled = false;



    // Calculate cell size based on current canvas dimensions
    function updateCellSize() {
      const canvas = document.getElementById('gameCanvas');
      if (canvas) {
        const rect = canvas.getBoundingClientRect();
        if (rect.width > 0) {
          CONFIG.CELL_SIZE = rect.width / CONFIG.MAZE_WIDTH;
        }
      }
    }
    
    // Handle window resize
    window.addEventListener('resize', () => {
      updateCellSize();
      showTouchControls();
    });
    window.addEventListener('orientationchange', () => {
      setTimeout(() => {
        updateCellSize();
        showTouchControls();
      }, 100);
    });

    // Show touch controls on mobile devices
    function showTouchControls() {
      const touchControls = document.getElementById('touchControls');
      if (window.innerWidth <= 768 || 'ontouchstart' in window) {
        touchControls.style.display = 'grid';
      } else {
        touchControls.style.display = 'none';
      }
    }

    // Handle touch controls
    document.querySelectorAll('.touch-btn').forEach(btn => {
      btn.addEventListener('touchstart', (e) => {
        e.preventDefault();
        const direction = btn.dataset.direction;
        handleDirectionInput(direction);
      });
      
      btn.addEventListener('mousedown', (e) => {
        e.preventDefault();
        const direction = btn.dataset.direction;
        handleDirectionInput(direction);
      });
    });

    function handleDirectionInput(direction) {
      if (!gameState.gameStarted || gameState.paused) return;
      
      const player = gameState.players[0];
      switch(direction) {
        case 'up':
          player.nextDirection = { x: 0, y: -1 };
          break;
        case 'down':
          player.nextDirection = { x: 0, y: 1 };
          break;
        case 'left':
          player.nextDirection = { x: -1, y: 0 };
          break;
        case 'right':
          player.nextDirection = { x: 1, y: 0 };
          break;
      }
    }

    // Game functions
    function initializeGame() {
      // Ensure mode is set
      if (!gameState.mode) {
        const activeModeOption = document.querySelector('.mode-option.active');
        gameState.mode = activeModeOption ? activeModeOption.dataset.mode : 'classic';
      }
      
      console.log('initializeGame - gameState.mode:', gameState.mode);
      
      // Copy maze layout
      gameState.maze = MAZE_LAYOUT.map(row => [...row]);
      
      // Initialize collections
      gameState.dots = new Set();
      gameState.powerPellets = new Set();
      gameState.dotsRemaining = 0;
      
      // Setup maze items
      for (let y = 0; y < CONFIG.MAZE_HEIGHT; y++) {
        for (let x = 0; x < CONFIG.MAZE_WIDTH; x++) {
          const cell = gameState.maze[y][x];
          const pos = y * CONFIG.MAZE_WIDTH + x;
          
          if (cell === 2) {
            gameState.dots.add(pos);
            gameState.dotsRemaining++;
            gameState.maze[y][x] = 0; // Convert to path
          } else if (cell === 3) {
            gameState.powerPellets.add(pos);
            gameState.maze[y][x] = 0; // Convert to path
          }
        }
      }

      // Create players
      gameState.players = [];
      gameState.players.push(new Player(19, 23, CONFIG.COLORS.player1, 0));
      
      if (gameState.mode === 'versus' || gameState.mode === 'cooperative') {
        gameState.players.push(new Player(20, 23, CONFIG.COLORS.player2, 1));
      }

      // Create ghosts
      gameState.ghosts = [];
      for (let i = 0; i < 4; i++) {
        // Each ghost starts in a different position around the ghost house
        let startX, startY;
        switch (i) {
          case 0: // Blinky (Red) - starts outside the house
            startX = 20;
            startY = 8;
            break;
          case 1: // Pinky (Pink) - starts just outside the house
            startX = 19;
            startY = 8;
            break;
          case 2: // Inky (Cyan) - starts just outside the house
            startX = 21;
            startY = 8;
            break;
          case 3: // Clyde (Orange) - starts just outside the house
            startX = 22;
            startY = 8;
            break;
        }
        const ghost = new Ghost(startX, startY, CONFIG.COLORS.ghosts[i], i);
        // Stagger ghost start times for authentic Pac-Man behavior
        ghost.modeTimer = i * 200;
        gameState.ghosts.push(ghost);
      }

      // Reset game state
      gameState.score = [0, 0];
      gameState.lives = 3;
      gameState.frightendMode = false;
      gameState.frightendTimer = 0;
      gameState.bonusPoints = 0;
      gameState.ghostsEatenCount = 0; // Reset ghost eaten count
      gameState.scorePopups = []; // Reset score popups

      // Show ready screen
      showReady();
    }

    function showReady() {
      const readyOverlay = document.getElementById('readyOverlay');
      readyOverlay.style.display = 'flex';
      
      setTimeout(() => {
        readyOverlay.style.display = 'none';
        gameState.running = true;
        startGameLoop();
      }, 2000);
    }

    function respawnPlayer(player) {
      player.x = 19;
      player.y = 23;
      player.alive = true;
      player.direction = { x: 0, y: 0 };
      player.nextDirection = { x: 0, y: 0 };
      
      // Reset ghosts to non-frightened mode and return to starting positions
      gameState.frightendMode = false;
      gameState.frightendTimer = 0;
      gameState.ghosts.forEach(ghost => {
        if (ghost.mode === 'frightened') {
          ghost.mode = 'chase';
        }
        // Reset ghosts to their starting positions when player respawns
        ghost.reset();
      });
      
      setTimeout(() => showReady(), 1000);
    }

    function updateGame() {
      if (!gameState.running || gameState.paused) return;

      // Update frightened timer
      if (gameState.frightendMode) {
        gameState.frightendTimer -= 16; // Assuming 60fps
        if (gameState.frightendTimer <= 0) {
          gameState.frightendMode = false;
          gameState.ghosts.forEach(ghost => {
            if (ghost.mode === 'frightened') {
              ghost.mode = 'chase';
            }
          });
        }
      }

      // Update players
      gameState.players.forEach(player => {
        if (player.alive) {
          player.update();
        }
      });

      // Update ghosts
      gameState.ghosts.forEach(ghost => ghost.update());

      // Update score popups
      gameState.scorePopups = gameState.scorePopups.filter(popup => {
        popup.update();
        return popup.life > 0;
      });

      // Check win condition
      if (gameState.dotsRemaining <= 0) {
        levelComplete();
      }

      // Update score display
      updateScoreDisplay();
    }

    function handleInput() {
      if (!gameState.running) return;

      // Check pause
      if (input.isPausePressed() && !gameState.pausePressed) {
        gameState.paused = !gameState.paused;
        document.getElementById('pausedOverlay').style.display = gameState.paused ? 'flex' : 'none';
        gameState.pausePressed = true;
      } else if (!input.isPausePressed()) {
        gameState.pausePressed = false;
      }

      // Check fullscreen
      if (input.isFullscreenPressed() && !gameState.fullscreenPressed) {
        toggleFullscreen();
        gameState.fullscreenPressed = true;
      } else if (!input.isFullscreenPressed()) {
        gameState.fullscreenPressed = false;
      }

      // Check restart
      if (input.isRestartPressed() && !gameState.restartPressed) {
        restartLevel();
        gameState.restartPressed = true;
      } else if (!input.isRestartPressed()) {
        gameState.restartPressed = false;
      }

      if (gameState.paused) return;

      // Handle player input
      gameState.players.forEach((player, index) => {
        if (!player.alive) return;

        const inputDir = input.getPlayerInput(index);
        if (inputDir) {
          let direction;
          
          switch (inputDir) {
            case 'up': direction = { x: 0, y: -1 }; break;
            case 'down': direction = { x: 0, y: 1 }; break;
            case 'left': direction = { x: -1, y: 0 }; break;
            case 'right': direction = { x: 1, y: 0 }; break;
          }
          
          if (direction) {
            player.setDirection(direction);
          }
        }
      });
    }

    function render() {
      // Clear canvas with dark background
      ctx.fillStyle = '#000033'; // Dark blue background
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Draw maze walls
      ctx.fillStyle = CONFIG.COLORS.wall;
      ctx.shadowColor = CONFIG.COLORS.wall;
      ctx.shadowBlur = 5;
      for (let y = 0; y < CONFIG.MAZE_HEIGHT; y++) {
        for (let x = 0; x < CONFIG.MAZE_WIDTH; x++) {
          if (gameState.maze[y][x] === 1) {
            const wallX = x * CONFIG.CELL_SIZE;
            const wallY = y * CONFIG.CELL_SIZE;
            
            // Draw rounded wall corners
            ctx.beginPath();
            if (ctx.roundRect) {
              ctx.roundRect(wallX, wallY, CONFIG.CELL_SIZE, CONFIG.CELL_SIZE, 3);
            } else {
              // Fallback for browsers without roundRect support
              ctx.rect(wallX, wallY, CONFIG.CELL_SIZE, CONFIG.CELL_SIZE);
            }
            ctx.fill();
            
            // Add border for better visibility
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 1;
            ctx.stroke();
          }
        }
      }
      ctx.shadowBlur = 0;

      // Draw dots
      ctx.fillStyle = CONFIG.COLORS.dot;
      for (const pos of gameState.dots) {
        const x = pos % CONFIG.MAZE_WIDTH;
        const y = Math.floor(pos / CONFIG.MAZE_WIDTH);
        const centerX = x * CONFIG.CELL_SIZE + CONFIG.CELL_SIZE / 2;
        const centerY = y * CONFIG.CELL_SIZE + CONFIG.CELL_SIZE / 2;
        
        ctx.beginPath();
        ctx.arc(centerX, centerY, 2, 0, Math.PI * 2);
        ctx.fill();
      }

      // Draw power pellets
      ctx.fillStyle = CONFIG.COLORS.powerPellet;
      ctx.shadowColor = CONFIG.COLORS.powerPellet;
      ctx.shadowBlur = 10;
      for (const pos of gameState.powerPellets) {
        const x = pos % CONFIG.MAZE_WIDTH;
        const y = Math.floor(pos / CONFIG.MAZE_WIDTH);
        const centerX = x * CONFIG.CELL_SIZE + CONFIG.CELL_SIZE / 2;
        const centerY = y * CONFIG.CELL_SIZE + CONFIG.CELL_SIZE / 2;
        const pulseSize = 6 + Math.sin(Date.now() * 0.01) * 3;
        
        ctx.beginPath();
        ctx.arc(centerX, centerY, pulseSize, 0, Math.PI * 2);
        ctx.fill();
        
        // Add pulsing glow effect
        ctx.globalAlpha = 0.3;
        ctx.beginPath();
        ctx.arc(centerX, centerY, pulseSize + 4, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1.0;
      }
      ctx.shadowBlur = 0;

      // Draw ghosts
      gameState.ghosts.forEach(ghost => ghost.render(ctx));

      // Draw players
      gameState.players.forEach(player => player.render(ctx));

      // Draw score popups
      gameState.scorePopups.forEach(popup => popup.render(ctx));
    }

    function updateScoreDisplay() {
      if (gameState.players.length > 0) {
        document.getElementById('player1Score').textContent = gameState.players[0].score;
        gameState.score[0] = gameState.players[0].score;
      }
      
      if (gameState.players.length > 1) {
        document.getElementById('player2Score').textContent = gameState.players[1].score;
        document.getElementById('player2Info').style.display = 'block';
        gameState.score[1] = gameState.players[1].score;
      }
      
      document.getElementById('levelDisplay').textContent = gameState.level;
      document.getElementById('livesDisplay').textContent = gameState.lives;
      document.getElementById('bonusDisplay').textContent = gameState.bonusPoints;
    }

    function levelComplete() {
      gameState.running = false;
      audio.playLevelComplete();
      
      // Calculate bonus points
      gameState.bonusPoints += 1000 * gameState.level;
      gameState.players.forEach(player => {
        player.score += gameState.bonusPoints;
      });
      
      // Update total scores
      gameState.score[0] = gameState.players[0].score;
      if (gameState.players.length > 1) {
        gameState.score[1] = gameState.players[1].score;
      }
      
      // Next level
      gameState.level++;
      
      // Increase difficulty for higher levels
      if (gameState.level > 1) {
        gameState.gameSpeed = Math.max(50, CONFIG.PLAYER_SPEED - (gameState.level - 1) * 10);
        // Reduce scatter time in higher levels
        gameState.ghosts.forEach(ghost => {
          ghost.modeDuration = Math.max(200, 1000 - (gameState.level - 1) * 100);
        });
      }
      
      setTimeout(() => {
        initializeGame();
      }, 2000);
    }

    function restartLevel() {
      gameState.running = false;
      gameState.paused = false;
      document.getElementById('pausedOverlay').style.display = 'none';
      
      // Reset all ghosts to their starting positions
      gameState.ghosts.forEach(ghost => ghost.reset());
      
      initializeGame();
    }

    function endGame() {
      gameState.running = false;
      
      let statsHtml = '';
      
      // Show mode-specific results
      if (gameState.mode === 'versus') {
        const winner = gameState.players[0].score > gameState.players[1].score ? 0 : 1;
        const winnerColor = winner === 0 ? CONFIG.COLORS.player1 : CONFIG.COLORS.player2;
        statsHtml += `<div style="color: ${winnerColor}; font-size: 1.8rem; margin-bottom: 15px; text-shadow: 0 0 20px ${winnerColor};">🏆 Player ${winner + 1} Wins!</div>`;
      } else if (gameState.mode === 'cooperative') {
        const totalScore = gameState.players.reduce((sum, p) => sum + p.score, 0);
        statsHtml += `<div style="color: var(--ghost-cyan); font-size: 1.8rem; margin-bottom: 15px;">🤝 Team Score: ${totalScore}</div>`;
      }
      
      statsHtml += `<div style="font-size: 1.4rem; margin-bottom: 15px; color: var(--pac-yellow);">Level ${gameState.level} Complete</div>`;
      statsHtml += '<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">';
      
      gameState.players.forEach((player, index) => {
        const playerColor = index === 0 ? CONFIG.COLORS.player1 : CONFIG.COLORS.player2;
        statsHtml += `
          <div style="padding: 15px; border: 2px solid ${playerColor}; border-radius: 10px; background: rgba(0,0,0,0.3);">
            <div style="color: ${playerColor}; font-weight: 700; font-size: 1.2rem;">Player ${index + 1}</div>
            <div style="margin-top: 8px;">Score: ${player.score}</div>
            <div>Level: ${gameState.level}</div>
            <div>Dots Collected: ${Math.floor(player.score / CONFIG.POINTS.DOT)}</div>
          </div>
        `;
      });
      statsHtml += '</div>';
      
      // Show game mode info
      statsHtml += `<div style="margin-top: 20px; padding: 15px; border: 2px solid var(--maze-blue); border-radius: 10px; background: rgba(0,102,255,0.1);">
        <div style="color: var(--maze-blue); font-weight: 700;">Game Mode: ${gameState.mode.toUpperCase()}</div>
        <div style="margin-top: 5px;">Total Bonus Points: ${gameState.bonusPoints}</div>
      </div>`;
      
      document.getElementById('finalStats').innerHTML = statsHtml;
      document.getElementById('gameOverOverlay').classList.remove('hidden');
    }

    // Game loop
    let lastTime = 0;
    function gameLoop(currentTime) {
      if (currentTime - lastTime >= gameState.gameSpeed) {
        handleInput();
        updateGame();
        lastTime = currentTime;
      }
      
      render();
      
      if (gameState.running) {
        requestAnimationFrame(gameLoop);
      }
    }

    function startGameLoop() {
      requestAnimationFrame(gameLoop);
    }

    // UI functions
    function showMenu() {
      gameState.running = false;
      document.getElementById('menuOverlay').classList.remove('hidden');
      document.getElementById('gameOverOverlay').classList.add('hidden');
      document.querySelector('.game-area').classList.add('hidden');
    }

    function startGame() {
      audio.init();
      gameState.running = false; // Will be set to true after ready screen
      gameState.paused = false;
      document.getElementById('menuOverlay').classList.add('hidden');
      document.getElementById('gameOverOverlay').classList.add('hidden');
      document.getElementById('pausedOverlay').style.display = 'none';
      document.querySelector('.game-area').classList.remove('hidden');
      
      // Update cell size based on current canvas dimensions
      setTimeout(updateCellSize, 100);
      
      initializeGame();
    }

    function restartGame() {
      gameState.level = 1;
      startGame();
    }

    function goHome() {
      window.location.href = '../index.html';
    }

    async function toggleFullscreen() {
      try {
        if (!document.fullscreenElement) {
          await canvas.requestFullscreen();
        } else {
          await document.exitFullscreen();
        }
      } catch (e) {
        console.warn('Fullscreen not supported');
      }
    }

    // Game mode selection
    document.querySelectorAll('.mode-option').forEach(option => {
      option.addEventListener('click', () => {
        document.querySelectorAll('.mode-option').forEach(opt => opt.classList.remove('active'));
        option.classList.add('active');
        gameState.mode = option.dataset.mode;
      });
    });

    // Set initial mode to the active one
    const activeModeOption = document.querySelector('.mode-option.active');
    if (activeModeOption) {
      gameState.mode = activeModeOption.dataset.mode;
    }
    
    // Debug logging to check if mode is set
    console.log('Initial gameState.mode:', gameState.mode);

    // Initialize
    showMenu();
    
    // Initialize touch controls
    showTouchControls();
    
    // Handle visibility change to pause game
    document.addEventListener('visibilitychange', () => {
      if (document.hidden && gameState.running && !gameState.paused) {
        gameState.paused = true;
        document.getElementById('pausedOverlay').style.display = 'flex';
      }
    });
  </script>
</body>
</html>
