<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Neon Asteroids - Space Combat</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');
    
    :root {
      --bg-space: #000011;
      --ship-cyan: #00ffff;
      --asteroid-orange: #ff6600;
      --bullet-yellow: #ffff00;
      --powerup-pink: #ff00ff;
      --enemy-red: #ff0040;
      --text-light: #e6f1ff;
      --neon-green: #00ff41;
      --neon-purple: #8a2be2;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    html, body {
      height: 100%;
      background: var(--bg-space);
      color: var(--text-light);
      font-family: 'Orbitron', monospace;
      overflow: hidden;
      user-select: none;
      -webkit-user-select: none;
      touch-action: none;
    }

    #gameContainer {
      position: fixed;
      inset: 0;
      display: grid;
      place-items: center;
      background: 
        radial-gradient(circle at 20% 30%, rgba(0, 255, 255, 0.1) 0%, transparent 30%),
        radial-gradient(circle at 80% 70%, rgba(255, 102, 0, 0.1) 0%, transparent 30%),
        radial-gradient(circle at 50% 20%, rgba(255, 0, 255, 0.05) 0%, transparent 40%);
    }

    canvas {
      border: 4px solid var(--ship-cyan);
      border-radius: 15px;
      background: 
        radial-gradient(2px 2px at 20% 30%, white, transparent),
        radial-gradient(2px 2px at 40% 70%, white, transparent),
        radial-gradient(1px 1px at 90% 40%, white, transparent),
        radial-gradient(1px 1px at 70% 90%, white, transparent),
        var(--bg-space);
      background-size: 200px 200px, 300px 300px, 150px 150px, 250px 250px;
      box-shadow: 
        0 0 50px rgba(0, 255, 255, 0.5),
        inset 0 0 50px rgba(0, 255, 255, 0.1);
    }

    .overlay {
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
      background: rgba(0, 0, 17, 0.9);
      backdrop-filter: blur(12px);
      overflow-y: auto;
      padding: 20px 0;
    }

    .menu-card {
      background: linear-gradient(135deg, rgba(0, 255, 255, 0.1), rgba(255, 102, 0, 0.1));
      border: 3px solid var(--ship-cyan);
      border-radius: 25px;
      padding: 30px;
      text-align: center;
      max-width: 650px;
      width: 90vw;
      max-height: 90vh;
      overflow-y: auto;
      box-shadow: 
        0 0 60px rgba(0, 255, 255, 0.4),
        inset 0 0 40px rgba(0, 255, 255, 0.1);
    }

    .title {
      font-size: 3rem;
      font-weight: 900;
      margin-bottom: 15px;
      background: linear-gradient(45deg, var(--ship-cyan), var(--asteroid-orange), var(--bullet-yellow), var(--powerup-pink));
      background-size: 400% 400%;
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      animation: gradient-flow 4s ease-in-out infinite;
      text-shadow: 0 0 50px rgba(0, 255, 255, 0.6);
    }

    @keyframes gradient-flow {
      0%, 100% { background-position: 0% 50%; }
      25% { background-position: 100% 50%; }
      50% { background-position: 100% 100%; }
      75% { background-position: 0% 100%; }
    }

    .subtitle {
      color: var(--text-light);
      margin-bottom: 25px;
      font-size: 1.2rem;
      opacity: 0.9;
    }

    .game-modes {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 20px;
      margin-bottom: 25px;
    }

    .mode-card {
      background: linear-gradient(135deg, rgba(0, 255, 65, 0.1), rgba(255, 0, 64, 0.1));
      border: 2px solid transparent;
      border-radius: 18px;
      padding: 18px 15px;
      cursor: pointer;
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
    }

    .mode-card.active {
      border-color: var(--neon-green);
      background: linear-gradient(135deg, rgba(0, 255, 65, 0.2), rgba(255, 0, 64, 0.2));
      transform: scale(1.05);
      box-shadow: 0 0 30px rgba(0, 255, 65, 0.4);
    }

    .mode-card:hover {
      transform: translateY(-4px);
      box-shadow: 0 15px 30px rgba(0, 255, 255, 0.3);
    }

    .mode-title {
      font-weight: 700;
      font-size: 1.2rem;
      margin-bottom: 8px;
      color: var(--neon-green);
    }

    .mode-desc {
      font-size: 0.85rem;
      opacity: 0.8;
      line-height: 1.3;
    }

    .btn {
      background: linear-gradient(135deg, var(--ship-cyan), var(--powerup-pink));
      border: none;
      border-radius: 18px;
      padding: 16px 35px;
      color: var(--bg-space);
      font-family: inherit;
      font-weight: 700;
      font-size: 1.3rem;
      cursor: pointer;
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
      margin: 15px;
      text-transform: uppercase;
      letter-spacing: 2px;
    }

    .btn:hover {
      transform: translateY(-4px) scale(1.05);
      box-shadow: 0 25px 50px rgba(0, 255, 255, 0.4);
    }

    .btn:active {
      transform: translateY(-2px) scale(1.02);
    }

    .controls-info {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 15px;
      margin-bottom: 20px;
    }

    .control-section {
      background: rgba(0, 0, 0, 0.4);
      border: 1px solid rgba(0, 255, 255, 0.3);
      border-radius: 12px;
      padding: 12px;
    }

    .control-title {
      color: var(--ship-cyan);
      font-weight: 700;
      margin-bottom: 8px;
      font-size: 1.1rem;
    }

    .kbd {
      display: inline-block;
      padding: 3px 8px;
      background: rgba(0, 255, 255, 0.2);
      border: 1px solid rgba(0, 255, 255, 0.4);
      border-radius: 5px;
      font-size: 0.85rem;
      margin: 2px;
      font-weight: 600;
    }

    .hud {
      position: absolute;
      top: 60px;
      left: 20px;
      right: 80px;
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      font-weight: 700;
      pointer-events: none;
      z-index: 10;
    }

    .hud-panel {
      background: rgba(0, 0, 17, 0.8);
      border: 2px solid var(--ship-cyan);
      border-radius: 15px;
      padding: 18px 25px;
      backdrop-filter: blur(10px);
      min-width: 200px;
    }

    .hud-item {
      margin-bottom: 10px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .hud-label {
      color: var(--ship-cyan);
      font-size: 1rem;
    }

    .hud-value {
      color: var(--text-light);
      font-size: 1.3rem;
      font-weight: 900;
    }

    .lives-display {
      display: flex;
      gap: 8px;
      margin-top: 8px;
    }

    .life-ship {
      width: 16px;
      height: 16px;
      background: var(--ship-cyan);
      clip-path: polygon(50% 0%, 0% 100%, 100% 100%);
      filter: drop-shadow(0 0 5px var(--ship-cyan));
    }

    .radar {
      position: absolute;
      top: 20px;
      right: 20px;
      width: 150px;
      height: 150px;
      background: rgba(0, 0, 17, 0.8);
      border: 2px solid var(--ship-cyan);
      border-radius: 50%;
      backdrop-filter: blur(10px);
      pointer-events: none;
    }

    .back-btn {
      position: absolute;
      bottom: 20px;
      left: 20px;
      background: rgba(255, 0, 64, 0.2);
      border: 2px solid var(--enemy-red);
      border-radius: 15px;
      padding: 15px 22px;
      color: var(--enemy-red);
      font-family: inherit;
      font-weight: 700;
      cursor: pointer;
      transition: all 0.3s ease;
      z-index: 20;
    }

    .back-btn:hover {
      background: rgba(255, 0, 64, 0.3);
      transform: translateY(-3px);
      box-shadow: 0 12px 30px rgba(255, 0, 64, 0.3);
    }

    .paused-overlay {
      position: absolute;
      inset: 0;
      background: rgba(0, 0, 17, 0.8);
      display: none;
      align-items: center;
      justify-content: center;
      font-size: 3.5rem;
      font-weight: 900;
      color: var(--ship-cyan);
      text-shadow: 0 0 50px rgba(0, 255, 255, 0.8);
      backdrop-filter: blur(10px);
    }

    .touch-controls {
      position: absolute;
      bottom: 30px;
      left: 30px;
      right: 30px;
      display: none;
      justify-content: space-between;
      align-items: center;
    }

    .touch-movement {
      display: grid;
      grid-template-columns: repeat(3, 60px);
      grid-template-rows: repeat(3, 60px);
      gap: 8px;
    }

    .touch-actions {
      display: flex;
      flex-direction: column;
      gap: 15px;
    }

    .touch-btn {
      background: rgba(0, 255, 255, 0.3);
      border: 2px solid var(--ship-cyan);
      border-radius: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.4rem;
      color: var(--ship-cyan);
      font-weight: 700;
      cursor: pointer;
      transition: all 0.2s ease;
      user-select: none;
      -webkit-user-select: none;
      touch-action: manipulation;
    }

    .touch-btn:active {
      background: rgba(0, 255, 255, 0.5);
      transform: scale(0.95);
    }

    .touch-btn.thrust { grid-column: 2; grid-row: 1; }
    .touch-btn.left { grid-column: 1; grid-row: 2; }
    .touch-btn.right { grid-column: 3; grid-row: 2; }

    .touch-btn.fire {
      width: 80px;
      height: 80px;
      border-radius: 50%;
      background: rgba(255, 255, 0, 0.3);
      border: 3px solid var(--bullet-yellow);
      color: var(--bullet-yellow);
      font-size: 1.8rem;
    }

    .touch-btn.hyperspace {
      width: 70px;
      height: 50px;
      background: rgba(255, 0, 255, 0.3);
      border: 2px solid var(--powerup-pink);
      color: var(--powerup-pink);
      font-size: 1.2rem;
    }

    @media (max-width: 768px) {
      .touch-controls {
        display: flex;
      }
      
      .menu-card {
        padding: 20px;
        margin: 10px;
      }
      
      .title {
        font-size: 2.5rem;
        margin-bottom: 10px;
      }
      
      .subtitle {
        font-size: 1.1rem;
        margin-bottom: 20px;
      }
      
      .game-modes {
        grid-template-columns: 1fr;
        gap: 15px;
        margin-bottom: 20px;
      }
      
      .controls-info {
        grid-template-columns: 1fr;
        gap: 10px;
        margin-bottom: 15px;
      }
      
      .control-section {
        padding: 10px;
      }
      
      .control-title {
        font-size: 1rem;
        margin-bottom: 6px;
      }
      
      .back-btn {
        right: 20px;
      }
      
      .home-btn {
        bottom: 15px;
        left: 15px;
        padding: 6px 12px;
        font-size: 0.75rem;
      }
    }

    @media (max-width: 480px) {
      .menu-card {
        padding: 15px;
        margin: 5px;
      }
      
      .title {
        font-size: 2.2rem;
        margin-bottom: 8px;
      }
      
      .subtitle {
        font-size: 1rem;
        margin-bottom: 15px;
      }
      
      .game-modes {
        gap: 12px;
        margin-bottom: 15px;
      }
      
      .mode-card {
        padding: 15px 12px;
      }
      
      .mode-title {
        font-size: 1.1rem;
        margin-bottom: 6px;
      }
      
      .mode-desc {
        font-size: 0.8rem;
      }
      
      .controls-info {
        gap: 8px;
        margin-bottom: 12px;
      }
      
      .control-section {
        padding: 8px;
      }
      
      .control-title {
        font-size: 0.95rem;
        margin-bottom: 5px;
      }
      
      .kbd {
        padding: 2px 6px;
        font-size: 0.8rem;
        margin: 1px;
      }
      
      .btn {
        padding: 14px 28px;
        font-size: 1.2rem;
      }
      
      .home-btn {
        bottom: 10px;
        left: 10px;
        padding: 5px 10px;
        font-size: 0.7rem;
        gap: 4px;
      }
    }

    /* Animation effects */
    .explosion {
      position: absolute;
      pointer-events: none;
      border-radius: 50%;
      animation: explosion-burst 0.6s ease-out forwards;
    }

    @keyframes explosion-burst {
      0% {
        transform: scale(0);
        opacity: 1;
      }
      50% {
        transform: scale(1.2);
        opacity: 0.8;
      }
      100% {
        transform: scale(2);
        opacity: 0;
      }
    }

    .debris-particle {
      position: absolute;
      pointer-events: none;
      width: 3px;
      height: 3px;
      background: var(--asteroid-orange);
      animation: debris-fly 2s ease-out forwards;
    }

    @keyframes debris-fly {
      0% {
        opacity: 1;
        transform: scale(1);
      }
      100% {
        opacity: 0;
        transform: scale(0) translate(var(--dx), var(--dy));
      }
    }

    .hyperspace-effect {
      position: absolute;
      inset: 0;
      background: 
        radial-gradient(circle, transparent 30%, rgba(0, 255, 255, 0.1) 31%, rgba(0, 255, 255, 0.1) 32%, transparent 33%),
        radial-gradient(circle, transparent 50%, rgba(255, 255, 255, 0.1) 51%, rgba(255, 255, 255, 0.1) 52%, transparent 53%);
      animation: hyperspace-warp 0.5s ease-in-out;
      pointer-events: none;
      opacity: 0;
    }

    .hidden {
      display: none !important;
    }

    .home-btn {
      position: fixed;
      bottom: 20px;
      left: 20px;
      background: linear-gradient(135deg, #ff0040, #ff2056);
      border: 2px solid #ff4070;
      border-radius: 8px;
      padding: 8px 16px;
      color: white;
      font-family: 'Orbitron', monospace;
      font-weight: 700;
      font-size: 0.85rem;
      cursor: pointer;
      transition: all 0.3s ease;
      z-index: 1000;
      text-decoration: none;
      display: flex;
      align-items: center;
      gap: 6px;
      backdrop-filter: blur(8px);
      box-shadow: 
        0 2px 10px rgba(255, 0, 64, 0.4),
        inset 0 0 15px rgba(255, 255, 255, 0.1);
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .home-btn:hover {
      background: linear-gradient(135deg, #ff2060, #ff4080);
      border-color: #ff6090;
      transform: translateY(-1px);
      box-shadow: 
        0 4px 15px rgba(255, 0, 64, 0.6),
        inset 0 0 20px rgba(255, 255, 255, 0.15);
    }

    .home-btn:active {
      transform: translateY(0px);
    }

    /* Hide external/injected home buttons in top area */
    *[style*="position: fixed"][style*="top"],
    *[style*="position: absolute"][style*="top"] {
      z-index: -1 !important;
    }

    /* Target elements that appear in top-right corner */
    body > *:not(#gameContainer):not(.home-btn):not(script) {
      position: static !important;
      top: auto !important;
      right: auto !important;
      z-index: -1 !important;
    }

    @keyframes hyperspace-warp {
      0%, 100% { opacity: 0; transform: scale(1); }
      50% { opacity: 1; transform: scale(1.1); }
    }

    .score-popup {
      position: absolute;
      color: var(--bullet-yellow);
      font-weight: 700;
      font-size: 1.2rem;
      pointer-events: none;
      animation: score-rise 1s ease-out forwards;
    }

    @keyframes score-rise {
      0% {
        opacity: 1;
        transform: translateY(0) scale(1);
      }
      100% {
        opacity: 0;
        transform: translateY(-50px) scale(1.2);
      }
    }
  </style>
</head>
<body>
  <div id="gameContainer">
    <canvas id="gameCanvas" width="1000" height="700"></canvas>
    
    <div class="hud" id="hud" style="display: none;">
      <div class="hud-panel">
        <div class="hud-item">
          <span class="hud-label">Score:</span>
          <span class="hud-value" id="scoreDisplay">0</span>
        </div>
        <div class="hud-item">
          <span class="hud-label">Wave:</span>
          <span class="hud-value" id="waveDisplay">1</span>
        </div>
        <div class="hud-item">
          <span class="hud-label">Lives:</span>
        </div>
        <div class="lives-display" id="livesDisplay"></div>
      </div>
      
      <div class="hud-panel">
        <div class="hud-item">
          <span class="hud-label">High Score:</span>
          <span class="hud-value" id="highScoreDisplay">0</span>
        </div>
        <div class="hud-item">
          <span class="hud-label">Asteroids:</span>
          <span class="hud-value" id="asteroidsDisplay">0</span>
        </div>
        <div class="hud-item">
          <span class="hud-label">Multiplier:</span>
          <span class="hud-value" id="multiplierDisplay">x1</span>
        </div>
      </div>
    </div>

    <div class="radar" id="radar" style="display: none;"></div>

    <button class="back-btn" onclick="goHome()" title="Back to Main Menu">
      ‚Üê HOME
    </button>

    <div class="paused-overlay" id="pausedOverlay">
      <div>PAUSED<br><small style="font-size: 1.2rem;">Press P or Start to resume</small></div>
    </div>

    <div class="touch-controls" id="touchControls">
      <div class="touch-movement">
        <div class="touch-btn thrust" data-action="thrust">‚Üë</div>
        <div class="touch-btn left" data-action="left">‚Ü∫</div>
        <div class="touch-btn right" data-action="right">‚Üª</div>
      </div>
      
      <div class="touch-actions">
        <div class="touch-btn fire" data-action="fire">üî•</div>
        <div class="touch-btn hyperspace" data-action="hyperspace">‚ö°</div>
      </div>
    </div>

    <!-- Menu overlay -->
    <div class="overlay" id="menuOverlay">
      <div class="menu-card">
        <h1 class="title">ASTEROIDS</h1>
        <p class="subtitle">Navigate the void, destroy asteroids, survive the chaos!</p>
        
        <div class="game-modes">
          <div class="mode-card active" data-mode="classic">
            <div class="mode-title">üöÄ CLASSIC</div>
            <div class="mode-desc">Traditional asteroid field<br>Increasing difficulty<br>Pure survival</div>
          </div>
          <div class="mode-card" data-mode="versus">
            <div class="mode-title">‚öîÔ∏è VERSUS</div>
            <div class="mode-desc">2-player combat<br>Shared asteroid field<br>Competitive scoring</div>
          </div>
          <div class="mode-card" data-mode="cooperative">
            <div class="mode-title">ü§ù CO-OP</div>
            <div class="mode-desc">Team survival<br>Shared lives<br>Combined score</div>
          </div>
          <div class="mode-card" data-mode="endless">
            <div class="mode-title">‚ôæÔ∏è ENDLESS</div>
            <div class="mode-desc">Infinite waves<br>Power-ups included<br>Ultimate challenge</div>
          </div>
        </div>

        <div class="controls-info">
          <div class="control-section">
            <div class="control-title">Ship Controls</div>
            <div>
              <span class="kbd">‚Üë</span> or <span class="kbd">W</span> Thrust<br>
              <span class="kbd">‚Üê</span><span class="kbd">‚Üí</span> or <span class="kbd">A</span><span class="kbd">D</span> Rotate<br>
              <span class="kbd">Space</span> Fire ‚Ä¢ <span class="kbd">Shift</span> Hyperspace
            </div>
          </div>
          <div class="control-section">
            <div class="control-title">Player 2 (Versus/Co-op)</div>
            <div>
              <span class="kbd">I</span> Thrust ‚Ä¢ <span class="kbd">J</span><span class="kbd">L</span> Rotate<br>
              <span class="kbd">K</span> Fire ‚Ä¢ <span class="kbd">U</span> Hyperspace<br>
              üéÆ Gamepad Support
            </div>
          </div>
          <div class="control-section">
            <div class="control-title">Game Controls</div>
            <div>
              <span class="kbd">P</span> Pause ‚Ä¢ <span class="kbd">F</span> Fullscreen<br>
              <span class="kbd">R</span> Restart Wave<br>
              üì± Touch Controls Available
            </div>
          </div>
        </div>

        <button class="btn" onclick="startGame()">LAUNCH</button>
      </div>
    </div>

    <!-- Game Over overlay -->
    <div class="overlay hidden" id="gameOverOverlay">
      <div class="menu-card">
        <h1 class="title">MISSION END</h1>
        <div id="finalStats" style="margin: 30px 0; font-size: 1.4rem;"></div>
        <div style="display: flex; gap: 20px; justify-content: center; flex-wrap: wrap;">
          <button class="btn" onclick="restartGame()">LAUNCH AGAIN</button>
          <button class="btn" onclick="showMenu()">MAIN MENU</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Home Button -->
  <!-- <a href="../index.html" class="home-btn">
    <span>‚Üê</span>
    <span>HOME</span>
  </a> -->

  <script>
    // Game configuration
    const CONFIG = {
      CANVAS_WIDTH: 1000,
      CANVAS_HEIGHT: 700,
      SHIP_SIZE: 12,
      SHIP_THRUST: 0.3,
      SHIP_ROTATION_SPEED: 0.15,
      SHIP_MAX_SPEED: 8,
      SHIP_FRICTION: 0.98,
      BULLET_SPEED: 10,
      BULLET_LIFETIME: 60, // frames
      ASTEROID_SPEEDS: [0.5, 1, 1.5, 2],
      ASTEROID_SIZES: [40, 25, 15],
      ASTEROID_POINTS: [20, 50, 100],
      UFO_SPEED: 2,
      UFO_FIRE_RATE: 0.02,
      HYPERSPACE_COOLDOWN: 180, // 3 seconds at 60fps
      INITIAL_ASTEROIDS: 4,
      LIVES: 3,
      COLORS: {
        ship: '#00ffff',
        bullet: '#ffff00',
        asteroid: '#ff6600',
        ufo: '#ff0040',
        explosion: '#ffffff',
        powerup: '#ff00ff',
        thruster: '#0080ff'
      }
    };

    // Game state
    let gameState = {
      running: false,
      paused: false,
      mode: 'classic', // classic, versus, cooperative, endless
      wave: 1,
      score: [0, 0], // [player1, player2]
      highScore: 0,
      lives: [CONFIG.LIVES, CONFIG.LIVES],
      multiplier: 1,
      multiplierTimer: 0,
      ships: [],
      asteroids: [],
      bullets: [],
      ufos: [],
      powerups: [],
      explosions: [],
      particles: [],
      gameSpeed: 16, // 60fps
      lastUpdateTime: 0,
      pausePressed: false,
      fullscreenPressed: false,
      restartPressed: false,
      hyperspaceEffect: false,
      waveTransition: false // Prevent multiple wave transitions
    };

    // Input handling
    class InputManager {
      constructor() {
        this.keys = new Set();
        this.touchActions = new Set();
        this.gamepadIndex = [null, null];
        this.setupEventListeners();
      }

      setupEventListeners() {
        document.addEventListener('keydown', (e) => {
          this.keys.add(e.code);
          if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Space'].includes(e.code)) {
            e.preventDefault();
          }
        });

        document.addEventListener('keyup', (e) => {
          this.keys.delete(e.code);
        });

        // Gamepad events
        window.addEventListener('gamepadconnected', (e) => {
          if (this.gamepadIndex[0] === null) {
            this.gamepadIndex[0] = e.gamepad.index;
          } else if (this.gamepadIndex[1] === null) {
            this.gamepadIndex[1] = e.gamepad.index;
          }
        });

        // Touch controls
        document.querySelectorAll('.touch-btn').forEach(btn => {
          const action = btn.dataset.action;
          if (action) {
            btn.addEventListener('touchstart', (e) => {
              e.preventDefault();
              this.touchActions.add(action);
            });
            
            btn.addEventListener('touchend', (e) => {
              e.preventDefault();
              this.touchActions.delete(action);
            });
          }
        });
      }

      getPlayerInput(playerIndex) {
        const input = { 
          left: false, 
          right: false, 
          thrust: false, 
          fire: false, 
          hyperspace: false 
        };
        
        if (playerIndex === 0) {
          // Player 1 - Arrow keys, WASD, and touch
          input.left = this.keys.has('ArrowLeft') || this.keys.has('KeyA') || this.touchActions.has('left');
          input.right = this.keys.has('ArrowRight') || this.keys.has('KeyD') || this.touchActions.has('right');
          input.thrust = this.keys.has('ArrowUp') || this.keys.has('KeyW') || this.touchActions.has('thrust');
          input.fire = this.keys.has('Space') || this.touchActions.has('fire');
          input.hyperspace = this.keys.has('ShiftLeft') || this.keys.has('ShiftRight') || this.touchActions.has('hyperspace');
        } else if (playerIndex === 1) {
          // Player 2 - IJKL and gamepad
          input.left = this.keys.has('KeyJ');
          input.right = this.keys.has('KeyL');
          input.thrust = this.keys.has('KeyI');
          input.fire = this.keys.has('KeyK');
          input.hyperspace = this.keys.has('KeyU');
          
          // Gamepad support
          const gamepadIndex = this.gamepadIndex[1] !== null ? this.gamepadIndex[1] : this.gamepadIndex[0];
          const gamepad = navigator.getGamepads()[gamepadIndex];
          if (gamepad) {
            const threshold = 0.5;
            if (gamepad.axes[0] < -threshold || gamepad.buttons[14]?.pressed) input.left = true;
            if (gamepad.axes[0] > threshold || gamepad.buttons[15]?.pressed) input.right = true;
            if (gamepad.axes[1] < -threshold || gamepad.buttons[12]?.pressed) input.thrust = true;
            if (gamepad.buttons[0]?.pressed || gamepad.buttons[1]?.pressed) input.fire = true;
            if (gamepad.buttons[2]?.pressed || gamepad.buttons[3]?.pressed) input.hyperspace = true;
          }
        }
        
        return input;
      }

      isPausePressed() {
        if (this.keys.has('KeyP')) return true;
        const gamepad = navigator.getGamepads()[this.gamepadIndex[0]];
        return gamepad?.buttons[9]?.pressed;
      }

      isFullscreenPressed() {
        return this.keys.has('KeyF');
      }

      isRestartPressed() {
        return this.keys.has('KeyR');
      }
    }

    // Audio system
    class AudioManager {
      constructor() {
        this.context = null;
        this.enabled = false;
      }

      async init() {
        try {
          this.context = new (window.AudioContext || window.webkitAudioContext)();
          if (this.context.state === 'suspended') {
            await this.context.resume();
          }
          this.enabled = true;
        } catch (e) {
          console.warn('Audio not available');
        }
      }

      playTone(frequency, duration = 0.1, type = 'square', volume = 0.1) {
        if (!this.enabled || !this.context) return;

        const oscillator = this.context.createOscillator();
        const gainNode = this.context.createGain();

        oscillator.connect(gainNode);
        gainNode.connect(this.context.destination);

        oscillator.frequency.value = frequency;
        oscillator.type = type;
        gainNode.gain.value = volume;

        oscillator.start();
        oscillator.stop(this.context.currentTime + duration);
      }

      playThrust() {
        this.playTone(100, 0.1, 'sawtooth', 0.05);
      }

      playFire() {
        this.playTone(1000, 0.1, 'square', 0.1);
      }

      playExplosion() {
        this.playTone(150, 0.3, 'sawtooth', 0.15);
        setTimeout(() => this.playTone(100, 0.2, 'sawtooth', 0.1), 100);
      }

      playAsteroidHit() {
        this.playTone(440, 0.15, 'triangle', 0.12);
      }

      playHyperspace() {
        for (let i = 0; i < 10; i++) {
          setTimeout(() => {
            this.playTone(2000 - i * 150, 0.05, 'sine', 0.08);
          }, i * 20);
        }
      }

      playPowerUp() {
        for (let i = 0; i < 5; i++) {
          setTimeout(() => {
            this.playTone(440 + i * 220, 0.1, 'sine', 0.1);
          }, i * 80);
        }
      }
    }

    // Game entities
    class Ship {
      constructor(x, y, color, playerIndex) {
        this.x = x;
        this.y = y;
        this.vx = 0;
        this.vy = 0;
        this.angle = 0;
        this.color = color;
        this.playerIndex = playerIndex;
        this.alive = true;
        this.invulnerable = 0;
        this.thrusterTime = 0;
        this.hyperspaceCooldown = 0;
        this.fireRate = 0;
        this.trail = [];
      }

      update() {
        if (!this.alive) return;

        const input = this.getInput();
        
        // Rotation
        if (input.left) {
          this.angle -= CONFIG.SHIP_ROTATION_SPEED;
        }
        if (input.right) {
          this.angle += CONFIG.SHIP_ROTATION_SPEED;
        }

        // Thrust
        if (input.thrust) {
          this.vx += Math.cos(this.angle) * CONFIG.SHIP_THRUST;
          this.vy += Math.sin(this.angle) * CONFIG.SHIP_THRUST;
          this.thrusterTime = 10;
          audio.playThrust();
          
          // Add thruster particles
          this.addThrusterParticle();
        }

        // Limit speed
        const speed = Math.hypot(this.vx, this.vy);
        if (speed > CONFIG.SHIP_MAX_SPEED) {
          this.vx = (this.vx / speed) * CONFIG.SHIP_MAX_SPEED;
          this.vy = (this.vy / speed) * CONFIG.SHIP_MAX_SPEED;
        }

        // Apply friction
        this.vx *= CONFIG.SHIP_FRICTION;
        this.vy *= CONFIG.SHIP_FRICTION;

        // Update position
        this.x += this.vx;
        this.y += this.vy;

        // Screen wrapping
        this.x = (this.x + CONFIG.CANVAS_WIDTH) % CONFIG.CANVAS_WIDTH;
        this.y = (this.y + CONFIG.CANVAS_HEIGHT) % CONFIG.CANVAS_HEIGHT;

        // Update timers
        if (this.invulnerable > 0) this.invulnerable--;
        if (this.thrusterTime > 0) this.thrusterTime--;
        if (this.hyperspaceCooldown > 0) this.hyperspaceCooldown--;
        if (this.fireRate > 0) this.fireRate--;

        // Firing
        if (input.fire && this.fireRate <= 0) {
          this.fire();
        }

        // Hyperspace
        if (input.hyperspace && this.hyperspaceCooldown <= 0 && !this.hyperspacePressed) {
          this.hyperspace();
          this.hyperspacePressed = true;
        }
        if (!input.hyperspace) {
          this.hyperspacePressed = false;
        }

        // Update trail
        this.trail.push({ x: this.x, y: this.y, time: Date.now() });
        this.trail = this.trail.filter(point => Date.now() - point.time < 500);

        // Check collisions
        this.checkCollisions();
      }

      getInput() {
        return input.getPlayerInput(this.playerIndex);
      }

      addThrusterParticle() {
        const thrusterX = this.x - Math.cos(this.angle) * CONFIG.SHIP_SIZE;
        const thrusterY = this.y - Math.sin(this.angle) * CONFIG.SHIP_SIZE;
        
        gameState.particles.push(new Particle(
          thrusterX, thrusterY,
          -Math.cos(this.angle) * 3 + (Math.random() - 0.5) * 2,
          -Math.sin(this.angle) * 3 + (Math.random() - 0.5) * 2,
          CONFIG.COLORS.thruster,
          20
        ));
      }

      fire() {
        this.fireRate = 10; // Fire rate cooldown
        
        const bulletX = this.x + Math.cos(this.angle) * CONFIG.SHIP_SIZE;
        const bulletY = this.y + Math.sin(this.angle) * CONFIG.SHIP_SIZE;
        const bulletVx = Math.cos(this.angle) * CONFIG.BULLET_SPEED + this.vx * 0.5;
        const bulletVy = Math.sin(this.angle) * CONFIG.BULLET_SPEED + this.vy * 0.5;
        
        gameState.bullets.push(new Bullet(bulletX, bulletY, bulletVx, bulletVy, this));
        audio.playFire();
      }

      hyperspace() {
        this.hyperspaceCooldown = CONFIG.HYPERSPACE_COOLDOWN;
        
        // Random teleportation
        this.x = Math.random() * CONFIG.CANVAS_WIDTH;
        this.y = Math.random() * CONFIG.CANVAS_HEIGHT;
        this.vx = 0;
        this.vy = 0;
        this.invulnerable = 60; // 1 second invulnerability
        
        // Visual effect
        triggerHyperspaceEffect();
        audio.playHyperspace();
      }

      checkCollisions() {
        if (this.invulnerable > 0) return;

        // Check asteroid collisions
        for (const asteroid of gameState.asteroids) {
          if (this.isCollidingWith(asteroid)) {
            this.destroy();
            return;
          }
        }

        // Check UFO bullet collisions
        for (let i = gameState.bullets.length - 1; i >= 0; i--) {
          const bullet = gameState.bullets[i];
          if (bullet.owner !== this && this.isCollidingWith(bullet)) {
            this.destroy();
            gameState.bullets.splice(i, 1);
            return;
          }
        }
      }

      isCollidingWith(other) {
        const distance = Math.hypot(this.x - other.x, this.y - other.y);
        const minDistance = CONFIG.SHIP_SIZE + (other.size || other.radius || 10);
        return distance < minDistance;
      }

      destroy() {
        this.alive = false;
        gameState.lives[this.playerIndex]--;
        
        createExplosion(this.x, this.y, CONFIG.COLORS.ship);
        audio.playExplosion();
        
        if (gameState.lives[this.playerIndex] <= 0) {
          checkGameOver();
        } else {
          // Respawn after delay
          setTimeout(() => {
            if (gameState.running) {
              this.respawn();
            }
          }, 2000);
        }
      }

      respawn() {
        this.alive = true;
        this.x = CONFIG.CANVAS_WIDTH / 2;
        this.y = CONFIG.CANVAS_HEIGHT / 2;
        this.vx = 0;
        this.vy = 0;
        this.angle = 0;
        this.invulnerable = 120; // 2 seconds invulnerability
      }

      render(ctx) {
        if (!this.alive) return;

        // Flicker when invulnerable
        if (this.invulnerable > 0 && Math.floor(this.invulnerable / 5) % 2) return;

        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);

        // Draw trail
        if (this.trail.length > 1) {
          ctx.globalAlpha = 0.3;
          ctx.strokeStyle = this.color;
          ctx.lineWidth = 2;
          ctx.beginPath();
          for (let i = 0; i < this.trail.length - 1; i++) {
            const alpha = i / this.trail.length;
            ctx.globalAlpha = alpha * 0.3;
            if (i === 0) {
              ctx.moveTo(this.trail[i].x - this.x, this.trail[i].y - this.y);
            } else {
              ctx.lineTo(this.trail[i].x - this.x, this.trail[i].y - this.y);
            }
          }
          ctx.stroke();
          ctx.globalAlpha = 1;
        }

        // Draw ship
        ctx.strokeStyle = this.color;
        ctx.fillStyle = this.color;
        ctx.lineWidth = 2;
        ctx.shadowColor = this.color;
        ctx.shadowBlur = 10;

        ctx.beginPath();
        ctx.moveTo(CONFIG.SHIP_SIZE, 0);
        ctx.lineTo(-CONFIG.SHIP_SIZE * 0.6, -CONFIG.SHIP_SIZE * 0.6);
        ctx.lineTo(-CONFIG.SHIP_SIZE * 0.3, 0);
        ctx.lineTo(-CONFIG.SHIP_SIZE * 0.6, CONFIG.SHIP_SIZE * 0.6);
        ctx.closePath();
        ctx.stroke();

        // Draw thruster flame
        if (this.thrusterTime > 0) {
          const flameSize = 8 + Math.random() * 4;
          ctx.fillStyle = CONFIG.COLORS.thruster;
          ctx.beginPath();
          ctx.moveTo(-CONFIG.SHIP_SIZE * 0.3, 0);
          ctx.lineTo(-CONFIG.SHIP_SIZE - flameSize, -3);
          ctx.lineTo(-CONFIG.SHIP_SIZE - flameSize, 3);
          ctx.closePath();
          ctx.fill();
        }

        ctx.restore();
        ctx.shadowBlur = 0;
      }
    }

    class Asteroid {
      constructor(x, y, size, vx, vy) {
        this.x = x;
        this.y = y;
        this.size = Math.max(0, Math.min(size, CONFIG.ASTEROID_SIZES.length - 1)); // Clamp size
        this.radius = CONFIG.ASTEROID_SIZES[this.size];
        this.vx = vx || (Math.random() - 0.5) * CONFIG.ASTEROID_SPEEDS[this.size];
        this.vy = vy || (Math.random() - 0.5) * CONFIG.ASTEROID_SPEEDS[this.size];
        this.rotation = 0;
        this.rotationSpeed = (Math.random() - 0.5) * 0.1;
        this.points = this.generateShape();
      }

      generateShape() {
        const points = [];
        const numPoints = 8 + Math.floor(Math.random() * 4);
        
        for (let i = 0; i < numPoints; i++) {
          const angle = (i / numPoints) * Math.PI * 2;
          const variance = 0.7 + Math.random() * 0.6; // Random size variation
          const radius = this.radius * variance;
          points.push({
            x: Math.cos(angle) * radius,
            y: Math.sin(angle) * radius
          });
        }
        
        return points;
      }

      update() {
        this.x += this.vx;
        this.y += this.vy;
        this.rotation += this.rotationSpeed;

        // Screen wrapping
        this.x = (this.x + CONFIG.CANVAS_WIDTH) % CONFIG.CANVAS_WIDTH;
        this.y = (this.y + CONFIG.CANVAS_HEIGHT) % CONFIG.CANVAS_HEIGHT;
      }

      split() {
        // Only large (0) and medium (1) asteroids should split
        // Small asteroids (size 2) should be destroyed completely
        if (this.size >= 2) {
          return [];
        }

        const fragments = [];
        const newSize = this.size + 1;
        const numFragments = 2; // Always split into exactly 2 pieces
        
        for (let i = 0; i < numFragments; i++) {
          const angle = (i / numFragments) * Math.PI * 2 + Math.random() * 0.5;
          const speed = CONFIG.ASTEROID_SPEEDS[newSize] * (1.2 + Math.random() * 0.6);
          const separationDistance = this.radius + CONFIG.ASTEROID_SIZES[newSize] + 10;
          const fragment = new Asteroid(
            this.x + Math.cos(angle) * separationDistance,
            this.y + Math.sin(angle) * separationDistance,
            newSize,
            Math.cos(angle) * speed,
            Math.sin(angle) * speed
          );
          fragments.push(fragment);
        }
        
        return fragments;
      }

      render(ctx) {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.rotation);

        ctx.strokeStyle = CONFIG.COLORS.asteroid;
        ctx.fillStyle = 'rgba(255, 102, 0, 0.1)';
        ctx.lineWidth = 2;
        ctx.shadowColor = CONFIG.COLORS.asteroid;
        ctx.shadowBlur = 8;

        ctx.beginPath();
        for (let i = 0; i < this.points.length; i++) {
          const point = this.points[i];
          if (i === 0) {
            ctx.moveTo(point.x, point.y);
          } else {
            ctx.lineTo(point.x, point.y);
          }
        }
        ctx.closePath();
        ctx.stroke();
        ctx.fill();

        ctx.restore();
        ctx.shadowBlur = 0;
      }
    }

    class Bullet {
      constructor(x, y, vx, vy, owner) {
        this.x = x;
        this.y = y;
        this.vx = vx;
        this.vy = vy;
        this.owner = owner;
        this.lifetime = CONFIG.BULLET_LIFETIME;
        this.trail = [];
      }

      update() {
        this.x += this.vx;
        this.y += this.vy;
        this.lifetime--;

        // Screen wrapping
        this.x = (this.x + CONFIG.CANVAS_WIDTH) % CONFIG.CANVAS_WIDTH;
        this.y = (this.y + CONFIG.CANVAS_HEIGHT) % CONFIG.CANVAS_HEIGHT;

        // Add to trail
        this.trail.push({ x: this.x, y: this.y });
        if (this.trail.length > 5) {
          this.trail.shift();
        }

        // Check asteroid collisions
        for (let i = gameState.asteroids.length - 1; i >= 0; i--) {
          const asteroid = gameState.asteroids[i];
          const distance = Math.hypot(this.x - asteroid.x, this.y - asteroid.y);
          
          if (distance < asteroid.radius) {
            // Hit asteroid
            const points = CONFIG.ASTEROID_POINTS[asteroid.size] * gameState.multiplier;
            if (this.owner) {
              gameState.score[this.owner.playerIndex] += points;
              showScorePopup(asteroid.x, asteroid.y, points);
            }
            
            // Increase multiplier
            gameState.multiplier = Math.min(8, gameState.multiplier + 0.1);
            gameState.multiplierTimer = 300; // 5 seconds
            
            // Create fragments and remove asteroid
            const fragments = asteroid.split();
            gameState.asteroids.splice(i, 1);
            gameState.asteroids.push(...fragments);
            
            // Effects
            createExplosion(asteroid.x, asteroid.y, CONFIG.COLORS.asteroid);
            createDebris(asteroid.x, asteroid.y, CONFIG.COLORS.asteroid);
            audio.playAsteroidHit();
            
            return false; // Bullet destroyed
          }
        }

        return this.lifetime > 0;
      }

      render(ctx) {
        // Draw trail
        if (this.trail.length > 1) {
          ctx.strokeStyle = CONFIG.COLORS.bullet;
          ctx.lineWidth = 3;
          ctx.shadowColor = CONFIG.COLORS.bullet;
          ctx.shadowBlur = 10;
          
          ctx.beginPath();
          for (let i = 0; i < this.trail.length; i++) {
            const alpha = i / this.trail.length;
            ctx.globalAlpha = alpha;
            if (i === 0) {
              ctx.moveTo(this.trail[i].x, this.trail[i].y);
            } else {
              ctx.lineTo(this.trail[i].x, this.trail[i].y);
            }
          }
          ctx.stroke();
          ctx.globalAlpha = 1;
          ctx.shadowBlur = 0;
        }

        // Draw bullet
        ctx.fillStyle = CONFIG.COLORS.bullet;
        ctx.shadowColor = CONFIG.COLORS.bullet;
        ctx.shadowBlur = 10;
        ctx.beginPath();
        ctx.arc(this.x, this.y, 2, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
      }
    }

    class Particle {
      constructor(x, y, vx, vy, color, lifetime) {
        this.x = x;
        this.y = y;
        this.vx = vx;
        this.vy = vy;
        this.color = color;
        this.lifetime = lifetime;
        this.maxLifetime = lifetime;
      }

      update() {
        this.x += this.vx;
        this.y += this.vy;
        this.vx *= 0.98;
        this.vy *= 0.98;
        this.lifetime--;
        return this.lifetime > 0;
      }

      render(ctx) {
        const alpha = this.lifetime / this.maxLifetime;
        ctx.globalAlpha = alpha;
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, 2, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;
      }
    }

    // Initialize game systems
    const input = new InputManager();
    const audio = new AudioManager();

    // Canvas setup
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    ctx.imageSmoothingEnabled = false;

    // Utility functions
    function createExplosion(x, y, color) {
      const explosion = document.createElement('div');
      explosion.className = 'explosion';
      explosion.style.left = x + 'px';
      explosion.style.top = y + 'px';
      explosion.style.width = '60px';
      explosion.style.height = '60px';
      explosion.style.background = `radial-gradient(circle, ${color}, transparent)`;
      
      document.getElementById('gameContainer').appendChild(explosion);
      
      setTimeout(() => {
        if (explosion.parentNode) {
          explosion.parentNode.removeChild(explosion);
        }
      }, 600);
    }

    function createDebris(x, y, color) {
      for (let i = 0; i < 8; i++) {
        const angle = (Math.PI * 2 * i) / 8;
        const distance = 30 + Math.random() * 30;
        const dx = Math.cos(angle) * distance;
        const dy = Math.sin(angle) * distance;
        
        gameState.particles.push(new Particle(
          x + Math.cos(angle) * 10,
          y + Math.sin(angle) * 10,
          Math.cos(angle) * 3,
          Math.sin(angle) * 3,
          color,
          30 + Math.random() * 20
        ));
      }
    }

    function showScorePopup(x, y, points) {
      const popup = document.createElement('div');
      popup.className = 'score-popup';
      popup.style.left = x + 'px';
      popup.style.top = y + 'px';
      popup.textContent = '+' + points;
      
      document.getElementById('gameContainer').appendChild(popup);
      
      setTimeout(() => {
        if (popup.parentNode) {
          popup.parentNode.removeChild(popup);
        }
      }, 1000);
    }

    function triggerHyperspaceEffect() {
      gameState.hyperspaceEffect = true;
      const effect = document.createElement('div');
      effect.className = 'hyperspace-effect';
      document.getElementById('gameContainer').appendChild(effect);
      
      setTimeout(() => {
        gameState.hyperspaceEffect = false;
        if (effect.parentNode) {
          effect.parentNode.removeChild(effect);
        }
      }, 500);
    }

    // Game functions
    function initializeGame() {
      // Load high score
      gameState.highScore = parseInt(localStorage.getItem('asteroids_highscore') || '0');
      
      // Create ships
      gameState.ships = [];
      gameState.ships.push(new Ship(CONFIG.CANVAS_WIDTH / 2, CONFIG.CANVAS_HEIGHT / 2, CONFIG.COLORS.ship, 0));
      
      if (gameState.mode === 'versus' || gameState.mode === 'cooperative') {
        gameState.ships.push(new Ship(CONFIG.CANVAS_WIDTH / 2 + 50, CONFIG.CANVAS_HEIGHT / 2, '#ff00ff', 1));
      }
      
      // Reset state
      gameState.asteroids = [];
      gameState.bullets = [];
      gameState.ufos = [];
      gameState.powerups = [];
      gameState.explosions = [];
      gameState.particles = [];
      gameState.score = [0, 0];
      gameState.lives = [CONFIG.LIVES, CONFIG.LIVES];
      gameState.multiplier = 1;
      gameState.multiplierTimer = 0;
      gameState.wave = 1;
      gameState.waveTransition = false;
      
      // Create initial asteroids
      createAsteroidField();
      
      updateHUD();
    }

    function createAsteroidField() {
      // Progressive difficulty - add 1 asteroid every 2 waves, then every wave
      const baseAsteroids = CONFIG.INITIAL_ASTEROIDS;
      let waveBonus;
      
      if (gameState.wave <= 4) {
        // Waves 1-4: +1 every 2 waves
        waveBonus = Math.floor((gameState.wave - 1) / 2);
      } else {
        // Waves 5+: +1 every wave (starting from wave 4 base)
        waveBonus = 2 + (gameState.wave - 4);
      }
      
      const maxAsteroids = 12; // Cap at 12 asteroids per wave
      const numAsteroids = Math.min(baseAsteroids + waveBonus, maxAsteroids);
      
      // Debug: console.log(`Wave ${gameState.wave}: Creating ${numAsteroids} asteroids (base: ${baseAsteroids}, bonus: ${waveBonus})`);
      
      for (let i = 0; i < numAsteroids; i++) {
        let x, y;
        
        // Ensure asteroids don't spawn too close to ships
        do {
          x = Math.random() * CONFIG.CANVAS_WIDTH;
          y = Math.random() * CONFIG.CANVAS_HEIGHT;
        } while (gameState.ships.some(ship => {
          const distance = Math.hypot(ship.x - x, ship.y - y);
          return distance < 100;
        }));
        
        gameState.asteroids.push(new Asteroid(x, y, 0));
      }
    }

    function updateGame() {
      if (!gameState.running || gameState.paused) return;

      // Update entities
      gameState.ships.forEach(ship => ship.update());
      gameState.asteroids.forEach(asteroid => asteroid.update());
      gameState.particles = gameState.particles.filter(particle => particle.update());
      
      // Update bullets
      for (let i = gameState.bullets.length - 1; i >= 0; i--) {
        if (!gameState.bullets[i].update()) {
          gameState.bullets.splice(i, 1);
        }
      }

      // Update multiplier timer
      if (gameState.multiplierTimer > 0) {
        gameState.multiplierTimer--;
        if (gameState.multiplierTimer <= 0) {
          gameState.multiplier = 1;
        }
      }

      // Check wave completion
      if (gameState.asteroids.length === 0 && !gameState.waveTransition) {
        nextWave();
      }

      updateHUD();
    }

    function nextWave() {
      // Prevent multiple simultaneous wave transitions
      if (gameState.waveTransition) return;
      gameState.waveTransition = true;
      
      gameState.wave++;
      
      // Bonus points for completing wave
      const waveBonus = 1000 * gameState.wave;
      gameState.ships.forEach((ship, index) => {
        if (ship.alive) {
          gameState.score[index] += waveBonus;
        }
      });
      
      // Show wave completion message
      showWaveMessage(`WAVE ${gameState.wave - 1} COMPLETE!`);
      
      // Create new asteroid field after delay
      setTimeout(() => {
        showWaveMessage(`WAVE ${gameState.wave} INCOMING!`);
        setTimeout(() => {
          createAsteroidField();
          updateHUD();
          gameState.waveTransition = false; // Allow next wave transition
        }, 1000);
      }, 2000);
    }

    function showWaveMessage(message) {
      // Create a temporary message overlay
      const messageDiv = document.createElement('div');
      messageDiv.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-family: 'Orbitron', monospace;
        font-size: 3rem;
        font-weight: 900;
        color: #00ffff;
        text-shadow: 0 0 40px rgba(0, 255, 255, 0.8);
        background: rgba(0, 0, 17, 0.9);
        border: 3px solid #00ffff;
        border-radius: 20px;
        padding: 30px 60px;
        z-index: 1000;
        pointer-events: none;
        backdrop-filter: blur(10px);
        animation: wave-message 2s ease-in-out forwards;
      `;
      messageDiv.textContent = message;
      
      // Add keyframe animation
      if (!document.querySelector('#wave-message-style')) {
        const style = document.createElement('style');
        style.id = 'wave-message-style';
        style.textContent = `
          @keyframes wave-message {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
            25% { opacity: 1; transform: translate(-50%, -50%) scale(1.1); }
            75% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
          }
        `;
        document.head.appendChild(style);
      }
      
      document.body.appendChild(messageDiv);
      
      setTimeout(() => {
        if (messageDiv.parentNode) {
          messageDiv.parentNode.removeChild(messageDiv);
        }
      }, 2000);
    }

    function checkGameOver() {
      const alivePlayers = gameState.ships.filter(ship => gameState.lives[ship.playerIndex] > 0);
      
      if (alivePlayers.length === 0) {
        endGame();
      }
    }

    function handleInput() {
      if (!gameState.running) return;

      // Check pause
      if (input.isPausePressed() && !gameState.pausePressed) {
        gameState.paused = !gameState.paused;
        document.getElementById('pausedOverlay').style.display = gameState.paused ? 'flex' : 'none';
        gameState.pausePressed = true;
      } else if (!input.isPausePressed()) {
        gameState.pausePressed = false;
      }

      // Check fullscreen
      if (input.isFullscreenPressed() && !gameState.fullscreenPressed) {
        toggleFullscreen();
        gameState.fullscreenPressed = true;
      } else if (!input.isFullscreenPressed()) {
        gameState.fullscreenPressed = false;
      }

      // Check restart
      if (input.isRestartPressed() && !gameState.restartPressed) {
        restartGame();
        gameState.restartPressed = true;
      } else if (!input.isRestartPressed()) {
        gameState.restartPressed = false;
      }
    }

    function render() {
      // Clear canvas
      ctx.fillStyle = CONFIG.COLORS.space || '#000011';
      ctx.fillRect(0, 0, CONFIG.CANVAS_WIDTH, CONFIG.CANVAS_HEIGHT);

      // Draw entities
      gameState.particles.forEach(particle => particle.render(ctx));
      gameState.asteroids.forEach(asteroid => asteroid.render(ctx));
      gameState.bullets.forEach(bullet => bullet.render(ctx));
      gameState.ships.forEach(ship => ship.render(ctx));

      // Draw screen border
      ctx.strokeStyle = 'rgba(0, 255, 255, 0.3)';
      ctx.lineWidth = 2;
      ctx.strokeRect(1, 1, CONFIG.CANVAS_WIDTH - 2, CONFIG.CANVAS_HEIGHT - 2);
    }

    function updateHUD() {
      const totalScore = Math.floor(gameState.score[0] + (gameState.score[1] || 0));
      document.getElementById('scoreDisplay').textContent = totalScore.toLocaleString();
      document.getElementById('waveDisplay').textContent = gameState.wave;
      document.getElementById('highScoreDisplay').textContent = Math.floor(gameState.highScore).toLocaleString();
      document.getElementById('asteroidsDisplay').textContent = gameState.asteroids.length;
      document.getElementById('multiplierDisplay').textContent = 'x' + gameState.multiplier.toFixed(1);
      
      // Update lives display
      const livesDisplay = document.getElementById('livesDisplay');
      livesDisplay.innerHTML = '';
      const maxLives = Math.max(gameState.lives[0], gameState.lives[1] || 0);
      for (let i = 0; i < maxLives; i++) {
        const lifeIcon = document.createElement('div');
        lifeIcon.className = 'life-ship';
        if (i >= gameState.lives[0]) {
          lifeIcon.style.opacity = '0.3';
        }
        livesDisplay.appendChild(lifeIcon);
      }
    }

    function endGame() {
      gameState.running = false;
      
      const finalScore = gameState.score[0] + (gameState.score[1] || 0);
      
      // Update high score
      if (finalScore > gameState.highScore) {
        gameState.highScore = finalScore;
        localStorage.setItem('asteroids_highscore', gameState.highScore.toString());
      }
      
      let statsHtml = '';
      if (gameState.mode === 'versus') {
        const winner = gameState.score[0] > gameState.score[1] ? 0 : 1;
        statsHtml += `<div style="color: ${winner === 0 ? '#00ffff' : '#ff00ff'}; font-size: 2.2rem; margin-bottom: 15px;">Player ${winner + 1} Wins!</div>`;
      } else {
        statsHtml += `<div style="color: #00ffff; font-size: 2.2rem; margin-bottom: 15px;">Mission Complete!</div>`;
      }
      
      statsHtml += `<div style="font-size: 1.5rem; margin-bottom: 20px;">Wave ${gameState.wave} Reached</div>`;
      statsHtml += '<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 20px;">';
      
      gameState.ships.forEach((ship, index) => {
        statsHtml += `
          <div style="padding: 20px; border: 2px solid ${ship.color}; border-radius: 15px;">
            <div style="color: ${ship.color}; font-weight: 700; font-size: 1.3rem;">Player ${index + 1}</div>
            <div style="margin-top: 10px;">Score: ${gameState.score[index]}</div>
            <div>Wave: ${gameState.wave}</div>
            <div>Multiplier: x${gameState.multiplier.toFixed(1)}</div>
          </div>
        `;
      });
      
      statsHtml += `
        <div style="padding: 20px; border: 2px solid #ffff00; border-radius: 15px;">
          <div style="color: #ffff00; font-weight: 700; font-size: 1.3rem;">High Score</div>
          <div style="margin-top: 10px; font-size: 1.5rem;">${gameState.highScore}</div>
        </div>
      `;
      statsHtml += '</div>';
      
      document.getElementById('finalStats').innerHTML = statsHtml;
      document.getElementById('gameOverOverlay').classList.remove('hidden');
    }

    // Game loop
    let lastTime = 0;
    function gameLoop(currentTime) {
      if (currentTime - lastTime >= gameState.gameSpeed) {
        handleInput();
        updateGame();
        lastTime = currentTime;
      }
      
      render();
      
      if (gameState.running) {
        requestAnimationFrame(gameLoop);
      }
    }

    // UI functions
    function showMenu() {
      gameState.running = false;
      document.getElementById('menuOverlay').classList.remove('hidden');
      document.getElementById('gameOverOverlay').classList.add('hidden');
      document.getElementById('hud').style.display = 'none';
    }

    function startGame() {
      audio.init();
      gameState.running = true;
      gameState.paused = false;
      document.getElementById('menuOverlay').classList.add('hidden');
      document.getElementById('gameOverOverlay').classList.add('hidden');
      document.getElementById('pausedOverlay').style.display = 'none';
      document.getElementById('hud').style.display = 'flex';
      
      initializeGame();
      requestAnimationFrame(gameLoop);
    }

    function restartGame() {
      startGame();
    }

    function goHome() {
      window.location.href = '../index.html';
    }

    async function toggleFullscreen() {
      try {
        if (!document.fullscreenElement) {
          await canvas.requestFullscreen();
        } else {
          await document.exitFullscreen();
        }
      } catch (e) {
        console.warn('Fullscreen not supported');
      }
    }

    // Game mode selection
    document.querySelectorAll('.mode-card').forEach(card => {
      card.addEventListener('click', () => {
        document.querySelectorAll('.mode-card').forEach(c => c.classList.remove('active'));
        card.classList.add('active');
        gameState.mode = card.dataset.mode;
      });
    });

    // Initialize
    showMenu();
    
    // Hide external home buttons that might interfere
    function hideExternalHomeButtons() {
      // Look for elements that might be external HOME buttons
      const allElements = document.querySelectorAll('*');
      allElements.forEach(element => {
        const computedStyle = window.getComputedStyle(element);
        const text = element.textContent;
        
        // Check if it's likely an external HOME button
        if (
          text && text.trim().toUpperCase().includes('HOME') &&
          element !== document.querySelector('.home-btn') &&
          !element.closest('#gameContainer') &&
          (computedStyle.position === 'fixed' || computedStyle.position === 'absolute') &&
          (parseInt(computedStyle.top) < 100 || parseInt(computedStyle.right) < 100)
        ) {
          element.style.display = 'none';
          element.style.visibility = 'hidden';
          element.style.opacity = '0';
          element.style.pointerEvents = 'none';
        }
      });
    }
    
    // Run immediately and periodically to catch dynamically added elements
    hideExternalHomeButtons();
    setInterval(hideExternalHomeButtons, 1000);
    
    // Handle visibility change to pause game
    document.addEventListener('visibilitychange', () => {
      if (document.hidden && gameState.running && !gameState.paused) {
        gameState.paused = true;
        document.getElementById('pausedOverlay').style.display = 'flex';
      }
    });
  </script>
</body>
</html>
