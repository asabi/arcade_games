<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Neon Pixel Runner - Retro Arcade</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');
    
    :root {
      --bg-dark: #000011;
      --neon-cyan: #00ffff;
      --neon-pink: #ff00ff;
      --neon-green: #00ff41;
      --neon-orange: #ff6600;
      --neon-purple: #8a2be2;
      --neon-yellow: #ffff00;
      --neon-red: #ff0040;
      --neon-blue: #0080ff;
      --player-blue: #0080ff;
      --obstacle-red: #ff0040;
      --powerup-green: #00ff41;
      --ground-color: #1a1a2e;
      --text-light: #e6f1ff;
      --text-muted: #8892b0;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    html, body {
      height: 100%;
      background: var(--bg-dark);
      color: var(--text-light);
      font-family: 'Orbitron', monospace;
      overflow: hidden;
      user-select: none;
      -webkit-user-select: none;
      touch-action: none;
    }

    #gameContainer {
      position: fixed;
      inset: 0;
      display: grid;
      place-items: center;
      background: 
        radial-gradient(circle at 25% 25%, rgba(0, 255, 255, 0.1) 0%, transparent 50%),
        radial-gradient(circle at 75% 75%, rgba(255, 0, 255, 0.1) 0%, transparent 50%),
        radial-gradient(circle at 50% 50%, rgba(0, 255, 65, 0.05) 0%, transparent 70%);
      padding: 20px;
    }

    canvas {
      border: 4px solid var(--neon-cyan);
      border-radius: 12px;
      background: linear-gradient(180deg, var(--bg-dark) 0%, #000022 50%, #000033 100%);
      box-shadow: 
        0 0 40px rgba(0, 255, 255, 0.5),
        inset 0 0 30px rgba(0, 255, 255, 0.1);
      max-width: 100%;
      max-height: 100%;
      /* Ensure canvas is interactive and focusable */
      cursor: pointer;
      outline: none;
      /* Add focus indicator */
      transition: box-shadow 0.3s ease;
    }
    
    canvas:focus {
      box-shadow: 
        0 0 40px rgba(0, 255, 255, 0.8),
        inset 0 0 30px rgba(0, 255, 255, 0.2),
        0 0 0 3px rgba(0, 255, 255, 0.5);
    }
    
    canvas:hover {
      cursor: pointer;
    }

    .overlay {
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
      background: rgba(0, 0, 17, 0.9);
      backdrop-filter: blur(10px);
      overflow-y: auto;
      padding: 20px 0;
    }

    .menu-card {
      background: linear-gradient(135deg, rgba(0, 255, 255, 0.1), rgba(255, 0, 255, 0.1));
      border: 3px solid var(--neon-cyan);
      border-radius: 20px;
      padding: 30px;
      text-align: center;
      max-width: 600px;
      width: 90vw;
      max-height: 90vh;
      overflow-y: auto;
      box-shadow: 
        0 0 50px rgba(0, 255, 255, 0.4),
        inset 0 0 30px rgba(0, 255, 255, 0.1);
      margin: 10px;
    }

    .title {
      font-size: 3rem;
      font-weight: 900;
      margin-bottom: 15px;
      background: linear-gradient(45deg, var(--neon-blue), var(--neon-cyan), var(--neon-green));
      background-size: 400% 400%;
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      animation: gradient-shift 3s ease-in-out infinite;
    }

    .subtitle {
      font-size: 1.2rem;
      color: var(--text-muted);
      margin-bottom: 25px;
      letter-spacing: 1px;
    }

    .controls {
      background: rgba(0, 255, 255, 0.1);
      border: 2px solid var(--neon-cyan);
      border-radius: 15px;
      padding: 20px;
      margin: 20px 0;
      text-align: left;
    }

    .controls h3 {
      color: var(--neon-cyan);
      margin-bottom: 15px;
      font-size: 1.1rem;
    }

    .control-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin: 10px 0;
      padding: 8px 0;
      border-bottom: 1px solid rgba(0, 255, 255, 0.2);
    }

    .key {
      background: rgba(0, 255, 255, 0.2);
      border: 1px solid var(--neon-cyan);
      border-radius: 6px;
      padding: 4px 8px;
      font-family: monospace;
      font-weight: bold;
      color: var(--neon-cyan);
      min-width: 30px;
      text-align: center;
    }

    .btn {
      background: linear-gradient(135deg, var(--neon-cyan), var(--neon-blue));
      border: none;
      border-radius: 25px;
      color: #000000;
      font-family: 'Orbitron', monospace;
      font-weight: 700;
      font-size: 1.1rem;
      padding: 15px 30px;
      margin: 10px;
      cursor: pointer;
      transition: all 0.3s ease;
      text-transform: uppercase;
      letter-spacing: 1px;
      box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
      /* Ensure text is readable */
      text-shadow: 0 0 2px rgba(255, 255, 255, 0.8);
    }

    .btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 0 30px rgba(0, 255, 255, 0.5);
      /* Improve hover readability */
      color: #000000;
      text-shadow: 0 0 4px rgba(255, 255, 255, 1);
    }

    .btn:active {
      transform: translateY(0);
    }

    .stats {
      position: absolute;
      top: 20px;
      left: 20px;
      background: rgba(0, 0, 0, 0.7);
      border: 2px solid var(--neon-cyan);
      border-radius: 10px;
      padding: 15px;
      color: var(--text-light);
      font-size: 0.9rem;
      backdrop-filter: blur(10px);
    }

    .stat-item {
      margin: 5px 0;
      display: flex;
      justify-content: space-between;
      min-width: 150px;
    }

    .stat-label {
      color: var(--neon-cyan);
      font-weight: bold;
    }

    .stat-value {
      color: var(--text-light);
    }

    .game-over {
      background: linear-gradient(135deg, rgba(255, 0, 64, 0.1), rgba(255, 0, 255, 0.1));
      border-color: var(--neon-red);
    }

    .game-over .title {
      background: linear-gradient(45deg, var(--neon-red), var(--neon-pink));
      background-size: 400% 400%;
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .game-over .btn {
      background: linear-gradient(135deg, var(--neon-red), var(--neon-pink));
      color: #ffffff;
      text-shadow: 0 0 2px rgba(0, 0, 0, 0.8);
    }

    .game-over .btn:hover {
      color: #ffffff;
      text-shadow: 0 0 4px rgba(0, 0, 0, 1);
    }

    /* Home Button - matches Asteroids style */
    .home-btn {
      position: fixed;
      bottom: 20px;
      left: 20px;
      background: linear-gradient(135deg, #ff0040, #ff2056);
      border: 2px solid #ff4070;
      border-radius: 8px;
      padding: 8px 16px;
      color: white;
      font-family: 'Orbitron', monospace;
      font-weight: 700;
      font-size: 0.85rem;
      cursor: pointer;
      transition: all 0.3s ease;
      z-index: 1000;
      text-decoration: none;
      display: flex;
      align-items: center;
      gap: 6px;
      backdrop-filter: blur(8px);
      box-shadow: 
        0 2px 10px rgba(255, 0, 64, 0.4),
        inset 0 0 15px rgba(255, 255, 255, 0.1);
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .home-btn:hover {
      background: linear-gradient(135deg, #ff2060, #ff4080);
      border-color: #ff6090;
      transform: translateY(-1px);
      box-shadow: 
        0 4px 15px rgba(255, 0, 64, 0.6),
        inset 0 0 20px rgba(255, 255, 255, 0.15);
    }

    .home-btn:active {
      transform: translateY(0px);
    }

    .home-btn:focus {
      outline: 2px solid rgba(255, 255, 255, 0.5);
      outline-offset: 2px;
    }

    @keyframes gradient-shift {
      0%, 100% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
    }

    .hidden {
      display: none !important;
    }
    
    @media (max-width: 768px) {
      .title {
        font-size: 2rem;
      }
      
      .subtitle {
        font-size: 1rem;
      }
      
      .menu-card {
        padding: 20px;
        margin: 10px;
      }
      
      .controls {
        padding: 15px;
      }
    }

    @media (max-width: 768px) {
      .home-btn {
        bottom: 15px;
        left: 15px;
        padding: 6px 12px;
        font-size: 0.75rem;
      }
    }

    @media (max-width: 480px) {
      .home-btn {
        bottom: 10px;
        left: 10px;
        padding: 5px 10px;
        font-size: 0.7rem;
        gap: 4px;
      }
    }


  </style>
</head>
<body>
  <div id="gameContainer">
    <canvas id="gameCanvas" width="800" height="400"></canvas>
    
    <!-- Main Menu -->
    <div id="mainMenu" class="overlay">
      <div class="menu-card">
        <h1 class="title">NEON PIXEL RUNNER</h1>
        <p class="subtitle">Run, Jump, Survive in the Cyberpunk Future</p>
        
        <div class="controls">
          <h3>üéÆ Controls</h3>
          <div class="control-item">
            <span>Move Left/Right</span>
            <span class="key">‚Üê ‚Üí</span>
          </div>
          <div class="control-item">
            <span>Jump</span>
            <span class="key">Space</span>
          </div>
          <div class="control-item">
            <span>Double Jump</span>
            <span class="key">Space</span>
          </div>
          <div class="control-item">
            <span>Pause</span>
            <span class="key">P</span>
          </div>
          <!-- <div class="control-item">
            <span>Fullscreen</span>
            <span class="key">F</span>
          </div> -->
        </div>
        
        <button id="startBtn" class="btn">Start Game</button>
      </div>
    </div>

    <!-- Pause Menu -->
    <div id="pauseMenu" class="overlay hidden">
      <div class="menu-card">
        <h1 class="title">PAUSED</h1>
        <p class="subtitle">Game is paused</p>
        <button id="resumeBtn" class="btn">Resume</button>
        <button id="restartBtn" class="btn">Restart</button>
        <button id="quitBtn" class="btn">Main Menu</button>
      </div>
    </div>

    <!-- Game Over Menu -->
    <div id="gameOverMenu" class="overlay hidden">
      <div class="menu-card game-over">
        <h1 class="title">GAME OVER</h1>
        <p class="subtitle">Your run has ended</p>
        <div id="finalStats"></div>
        <button id="playAgainBtn" class="btn">Play Again</button>
        <button id="mainMenuBtn" class="btn">Main Menu</button>
      </div>
    </div>

    <!-- Game Stats -->
    <div id="gameStats" class="stats hidden">
      <div class="stat-item">
        <span class="stat-label">Score:</span>
        <span id="scoreValue" class="stat-value">0</span>
      </div>
      <div class="stat-item">
        <span class="stat-label">Distance:</span>
        <span id="distanceValue" class="stat-value">0m</span>
      </div>
      <div class="stat-item">
        <span class="stat-label">Speed:</span>
        <span id="speedValue" class="stat-value">1x</span>
      </div>
    </div>
  </div>

  <!-- Home Button -->
  <a href="../index.html" class="home-btn">
    <span>‚Üê</span>
    <span>HOME</span>
  </a>

  <script>
    // Game variables
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    let gameState = 'menu'; // menu, playing, paused, gameOver
    let gameLoop;
    let lastTime = 0;
    
    // Game objects
    let player = {
      x: 100,
      y: 300,
      width: 20,
      height: 30,
      velocityY: 0,
      velocityX: 0,
      onGround: false,
      canDoubleJump: true,
      color: '#0080ff'
    };
    
    let obstacles = [];
    let powerups = [];
    let particles = [];
    let groundY = 350;
    let scrollX = 0;
    let score = 0;
    let distance = 0;
    let gameSpeed = 1;
    let gravity = 0.8;
    let jumpPower = -15;
    
    // Input handling
    let keys = {};
    let gamepad = null;
    
    // Initialize game
    function init() {
      console.log('Initializing game...');
      
      // Add event listeners to the document instead of canvas for better focus handling
      document.addEventListener('keydown', handleKeyDown);
      document.addEventListener('keyup', handleKeyUp);
      // document.addEventListener('click', handleClick); // Removed problematic handleClick
      
      // Ensure canvas is focusable and focused
      canvas.setAttribute('tabindex', '0');
      canvas.focus();
      
      // Gamepad support
      window.addEventListener('gamepadconnected', handleGamepad);
      window.addEventListener('gamepaddisconnected', handleGamepad);
      
      // Button event listeners
      document.getElementById('startBtn').addEventListener('click', () => {
        console.log('Start button clicked');
        startGame();
      });
      document.getElementById('resumeBtn').addEventListener('click', () => {
        console.log('Resume button clicked');
        resumeGame();
      });
      document.getElementById('restartBtn').addEventListener('click', () => {
        console.log('Restart button clicked');
        restartGame();
      });
      document.getElementById('quitBtn').addEventListener('click', () => {
        console.log('Quit button clicked');
        showMainMenu();
      });
      document.getElementById('playAgainBtn').addEventListener('click', () => {
        console.log('Play again button clicked');
        restartGame();
      });
      document.getElementById('mainMenuBtn').addEventListener('click', () => {
        console.log('Main menu button clicked');
        showMainMenu();
      });
      
      // Ensure we start in menu state
      gameState = 'menu';
      console.log('Initial game state:', gameState);
      
      // Start game loop
      gameLoop = setInterval(update, 1000 / 60);
      
      // Add focus event to ensure canvas stays focused
      canvas.addEventListener('focus', () => console.log('Canvas focused'));
      canvas.addEventListener('blur', () => console.log('Canvas lost focus'));
      
      // Add click event to canvas to refocus it
      canvas.addEventListener('click', () => {
        canvas.focus();
        console.log('Canvas clicked and focused');
      });

    }
    
    // Input handlers
    function handleKeyDown(e) {
      console.log('Key pressed:', e.code, 'Game state:', gameState);
      keys[e.code] = true;
      
      // Handle jump (Space or ArrowUp)
      if ((e.code === 'Space' || e.code === 'ArrowUp') && gameState === 'playing') {
        e.preventDefault();
        console.log('Jump attempt - onGround:', player.onGround, 'canDoubleJump:', player.canDoubleJump);
        if (player.onGround) {
          player.velocityY = jumpPower;
          player.onGround = false;
          player.canDoubleJump = true;
          console.log('Single jump executed');
        } else if (player.canDoubleJump) {
          player.velocityY = jumpPower * 0.8;
          player.canDoubleJump = false;
          console.log('Double jump executed');
        }
      }
      
      // Handle pause
      if (e.code === 'KeyP') {
        e.preventDefault();
        togglePause();
      }
      

      
      // Prevent default for arrow keys to avoid page scrolling
      if (['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown', 'Space'].includes(e.code)) {
        e.preventDefault();
      }
    }
    
    function handleKeyUp(e) {
      keys[e.code] = false;
    }
    
    // Remove the problematic handleClick function that was interfering with buttons
    // function handleClick() {
    //   if (gameState === 'menu') {
    //     startGame();
    //   }
    // }
    
    function handleGamepad(e) {
      if (e.type === 'gamepadconnected') {
        gamepad = navigator.getGamepads()[e.gamepad.index];
      } else {
        gamepad = null;
      }
    }
    
    // Game state management
    function startGame() {
      console.log('Starting game...');
      gameState = 'playing';
      resetGame();
      
      // Ensure canvas has focus for controls
      canvas.focus();
      
      // Double-check that obstacles are cleared
      if (obstacles.length > 0) {
        console.log('Warning: obstacles still exist after reset, clearing them');
        obstacles = [];
      }
      
      showElement('gameStats');
      hideElement('mainMenu');
      console.log('Game state:', gameState, 'Obstacles:', obstacles.length);
      
      // Add visual feedback that game is ready
      setTimeout(() => {
        if (gameState === 'playing') {
          console.log('Game is now running and ready for input');
        }
      }, 100);
    }
    
    function pauseGame() {
      if (gameState === 'playing') {
        gameState = 'paused';
        showElement('pauseMenu');
        console.log('Game paused');
      }
    }
    
    function resumeGame() {
      if (gameState === 'paused') {
        gameState = 'playing';
        hideElement('pauseMenu');
        // Refocus canvas when resuming
        canvas.focus();
        console.log('Game resumed');
      }
    }
    
    function togglePause() {
      if (gameState === 'playing') {
        pauseGame();
      } else if (gameState === 'paused') {
        resumeGame();
      }
    }
    
    function gameOver() {
      gameState = 'gameOver';
      hideElement('gameStats');
      showElement('gameOverMenu');
      document.getElementById('finalStats').innerHTML = `
        <p>Final Score: ${score}</p>
        <p>Distance: ${Math.floor(distance)}m</p>
        <p>Max Speed: ${gameSpeed.toFixed(1)}x</p>
      `;
    }
    
    function restartGame() {
      resetGame();
      gameState = 'playing';
      hideElement('gameOverMenu');
      hideElement('pauseMenu');
      showElement('gameStats');
    }
    
    function showMainMenu() {
      console.log('showMainMenu called - returning to splash screen');
      gameState = 'menu';
      
      // Hide all game-related elements
      hideElement('gameOverMenu');
      hideElement('pauseMenu');
      hideElement('gameStats');
      
      // Show the main menu/splash screen
      showElement('mainMenu');
      
      // Reset the game state completely
      resetGame();
      
      // Ensure canvas loses focus to prevent accidental game start
      canvas.blur();
      
      console.log('Main menu shown, game state:', gameState);
    }
    
    function resetGame() {
      console.log('Resetting game state...');
      player.x = 100;
      player.y = 300;
      player.velocityY = 0;
      player.velocityX = 0;
      player.onGround = false;
      player.canDoubleJump = true;
      
      obstacles = [];
      powerups = [];
      particles = [];
      scrollX = 0;
      score = 0;
      distance = 0;
      gameSpeed = 1;
      
      console.log('Game reset, obstacles:', obstacles.length, 'powerups:', powerups.length);
    }
    
    // Game update loop
    function update() {
      if (gameState !== 'playing') {
        return;
      }
      
      updatePlayer();
      updateObstacles();
      updatePowerups();
      updateParticles();
      updateGameSpeed();
      checkCollisions();
      updateUI();
    }
    
    function updatePlayer() {
      // Handle input with better responsiveness
      if (keys['ArrowLeft'] || keys['KeyA']) {
        player.velocityX = -5;
      } else if (keys['ArrowRight'] || keys['KeyD']) {
        player.velocityX = 5;
      } else {
        // Apply friction when no keys are pressed
        player.velocityX *= 0.8;
      }
      
      // Gamepad support
      if (gamepad) {
        const leftStick = gamepad.axes[0];
        if (Math.abs(leftStick) > 0.1) {
          player.velocityX = leftStick * 5;
        }
        
        // Gamepad jump button (A button)
        if (gamepad.buttons[0].pressed && player.onGround) {
          player.velocityY = jumpPower;
          player.onGround = false;
          player.canDoubleJump = true;
        }
      }
      
      // Apply physics
      player.velocityY += gravity;
      player.x += player.velocityX;
      player.y += player.velocityY;
      
      // Ground collision
      if (player.y >= groundY - player.height) {
        player.y = groundY - player.height;
        player.velocityY = 0;
        player.onGround = true;
      }
      
      // Screen boundaries
      if (player.x < 0) player.x = 0;
      if (player.x > canvas.width - player.width) player.x = canvas.width - player.width;
      
      // Debug logging for movement
      if (keys['ArrowLeft'] || keys['ArrowRight'] || keys['Space'] || keys['ArrowUp']) {
        console.log('Player position:', player.x, player.y, 'Velocity:', player.velocityX, player.velocityY, 'On ground:', player.onGround);
      }
    }
    
    function updateObstacles() {
      // Remove off-screen obstacles
      obstacles = obstacles.filter(obs => obs.x + obs.width > scrollX - 100);
      
      // Generate new obstacles only after a delay to give player time to start
      if (distance > 50 && Math.random() < 0.02 * gameSpeed) {
        const obstacle = {
          x: scrollX + canvas.width + Math.random() * 200,
          y: groundY - 30 - Math.random() * 20,
          width: 20 + Math.random() * 30,
          height: 30 + Math.random() * 20,
          color: '#ff0040'
        };
        obstacles.push(obstacle);
        console.log('Generated obstacle at:', obstacle.x, obstacle.y, 'scrollX:', scrollX);
      }
      
      // Move obstacles
      obstacles.forEach(obs => {
        obs.x -= 3 * gameSpeed;
      });
    }
    
    function updatePowerups() {
      // Remove off-screen powerups
      powerups = powerups.filter(power => power.x + power.width > scrollX - 100);
      
      // Generate new powerups only after a delay
      if (distance > 100 && Math.random() < 0.005 * gameSpeed) {
        const powerup = {
          x: scrollX + canvas.width + Math.random() * 300,
          y: groundY - 60 - Math.random() * 100,
          width: 15,
          height: 15,
          color: '#00ff41',
          type: Math.random() < 0.5 ? 'score' : 'speed'
        };
        powerups.push(powerup);
      }
      
      // Move powerups
      powerups.forEach(power => {
        power.x -= 3 * gameSpeed;
      });
    }
    
    function updateParticles() {
      particles = particles.filter(particle => particle.life > 0);
      
      particles.forEach(particle => {
        particle.x += particle.vx;
        particle.y += particle.vy;
        particle.life--;
        particle.vy += 0.1;
      });
    }
    
    function updateGameSpeed() {
      gameSpeed += 0.001;
      distance += gameSpeed;
      score += Math.floor(gameSpeed);
    }
    
    function checkCollisions() {
      // Obstacle collisions
      obstacles.forEach(obs => {
        // Use screen coordinates for collision detection
        const screenX = obs.x - scrollX;
        const screenY = obs.y;
        
        if (checkCollision(player, {x: screenX, y: screenY, width: obs.width, height: obs.height})) {
          console.log('Collision detected with obstacle at screen:', screenX, screenY, 'world:', obs.x, obs.y);
          createExplosion(player.x + player.width/2, player.y + player.height/2);
          gameOver();
        }
      });
      
      // Powerup collisions
      powerups.forEach((power, index) => {
        // Use screen coordinates for collision detection
        const screenX = power.x - scrollX;
        const screenY = power.y;
        
        if (checkCollision(player, {x: screenX, y: screenY, width: power.width, height: power.height})) {
          if (power.type === 'score') {
            score += 100;
          } else {
            gameSpeed += 0.1;
          }
          powerups.splice(index, 1);
          createPowerupEffect(player.x + player.width/2, player.y + player.height/2);
        }
      });
    }
    
    function checkCollision(rect1, rect2) {
      return rect1.x < rect2.x + rect2.width &&
             rect1.x + rect1.width > rect2.x &&
             rect1.y < rect2.y + rect2.height &&
             rect1.y + rect1.height > rect2.y;
    }
    
    function createExplosion(x, y) {
      for (let i = 0; i < 20; i++) {
        particles.push({
          x: x,
          y: y,
          vx: (Math.random() - 0.5) * 10,
          vy: (Math.random() - 0.5) * 10,
          life: 30,
          color: '#ff0040'
        });
      }
    }
    
    function createPowerupEffect(x, y) {
      for (let i = 0; i < 10; i++) {
        particles.push({
          x: x,
          y: y,
          vx: (Math.random() - 0.5) * 5,
          vy: (Math.random() - 0.5) * 5,
          life: 20,
          color: '#00ff41'
        });
      }
    }
    
    function updateUI() {
      document.getElementById('scoreValue').textContent = score;
      document.getElementById('distanceValue').textContent = Math.floor(distance) + 'm';
      document.getElementById('speedValue').textContent = gameSpeed.toFixed(1) + 'x';
    }
    
    // Rendering
    function render() {
      // Clear canvas
      ctx.fillStyle = '#000011';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // Draw background
      drawBackground();
      
      // Draw ground
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, groundY, canvas.width, canvas.height - groundY);
      
      // Draw game objects
      drawObstacles();
      drawPowerups();
      drawPlayer();
      drawParticles();
      
      // Draw UI elements
      if (gameState === 'playing') {
        drawUI();
      }
    }
    
    function drawBackground() {
      // Draw stars
      ctx.fillStyle = '#ffffff';
      for (let i = 0; i < 100; i++) {
        const x = (i * 37) % canvas.width;
        const y = (i * 73) % canvas.height;
        const size = (i % 3) + 1;
        ctx.fillRect(x, y, size, size);
      }
      
      // Draw neon grid lines
      ctx.strokeStyle = 'rgba(0, 255, 255, 0.1)';
      ctx.lineWidth = 1;
      for (let x = 0; x < canvas.width; x += 50) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, canvas.height);
        ctx.stroke();
      }
    }
    
    function drawPlayer() {
      ctx.fillStyle = player.color;
      ctx.fillRect(player.x, player.y, player.width, player.height);
      
      // Draw neon glow
      ctx.shadowColor = player.color;
      ctx.shadowBlur = 10;
      ctx.fillRect(player.x, player.y, player.width, player.height);
      ctx.shadowBlur = 0;
    }
    
    function drawObstacles() {
      obstacles.forEach(obs => {
        ctx.fillStyle = obs.color;
        ctx.fillRect(obs.x - scrollX, obs.y, obs.width, obs.height);
        
        // Draw neon glow
        ctx.shadowColor = obs.color;
        ctx.shadowBlur = 8;
        ctx.fillRect(obs.x - scrollX, obs.y, obs.width, obs.height);
        ctx.shadowBlur = 0;
      });
    }
    
    function drawPowerups() {
      powerups.forEach(power => {
        ctx.fillStyle = power.color;
        ctx.fillRect(power.x - scrollX, power.y, power.width, power.height);
        
        // Draw neon glow
        ctx.shadowColor = power.color;
        ctx.shadowBlur = 8;
        ctx.fillRect(power.x - scrollX, power.y, power.width, power.height);
        ctx.shadowBlur = 0;
      });
    }
    
    function drawParticles() {
      particles.forEach(particle => {
        ctx.fillStyle = particle.color;
        ctx.globalAlpha = particle.life / 30;
        ctx.fillRect(particle.x - scrollX, particle.y, 3, 3);
        ctx.globalAlpha = 1;
      });
    }
    
    function drawUI() {
      // Draw distance indicator
      ctx.fillStyle = '#00ffff';
      ctx.font = '16px Orbitron';
      ctx.textAlign = 'right';
      ctx.fillText(`${Math.floor(distance)}m`, canvas.width - 20, 30);
      
      // Draw speed indicator
      ctx.fillStyle = '#00ff41';
      ctx.fillText(`${gameSpeed.toFixed(1)}x`, canvas.width - 20, 50);
    }
    
    // Utility functions
    function showElement(id) {
      document.getElementById(id).classList.remove('hidden');
    }
    
    function hideElement(id) {
      document.getElementById(id).classList.add('hidden');
    }
    

    
    function goHome() {
      window.location.href = '../index.html';
    }


    
    // Main render loop
    function renderLoop() {
      render();
      requestAnimationFrame(renderLoop);
    }
    
    // Initialize and start
    init();
    renderLoop();
  </script>
</body>
</html>
