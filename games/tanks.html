<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Combat Tanks - Multiplayer Battle</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');
    
    :root {
      --bg-dark: #0a0a0a;
      --terrain-green: #228b22;
      --terrain-brown: #8b4513;
      --tank-green: #32cd32;
      --tank-red: #ff4444;
      --explosion-orange: #ff6600;
      --explosion-yellow: #ffff00;
      --bullet-yellow: #ffd700;
      --text-light: #ffffff;
      --neon-cyan: #00ffff;
      --neon-green: #00ff41;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    html, body {
      height: 100%;
      background: var(--bg-dark);
      color: var(--text-light);
      font-family: 'Orbitron', monospace;
      overflow: hidden;
      user-select: none;
      -webkit-user-select: none;
      touch-action: none;
    }

    #gameContainer {
      position: fixed;
      inset: 0;
      display: grid;
      place-items: center;
      background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 50%, #16213e 100%);
    }

    canvas {
      border: 3px solid var(--neon-cyan);
      border-radius: 10px;
      background: linear-gradient(180deg, #87ceeb 0%, #228b22 70%, #8b4513 100%);
      box-shadow: 
        0 0 30px rgba(0, 255, 255, 0.4),
        inset 0 0 20px rgba(0, 255, 255, 0.1);
    }

    .overlay {
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
      background: rgba(10, 10, 10, 0.9);
      backdrop-filter: blur(8px);
    }

    .menu-card {
      background: linear-gradient(135deg, rgba(0, 255, 255, 0.1), rgba(0, 255, 65, 0.1));
      border: 3px solid var(--neon-cyan);
      border-radius: 20px;
      padding: 40px;
      text-align: center;
      max-width: 650px;
      width: 90vw;
      box-shadow: 
        0 0 40px rgba(0, 255, 255, 0.4),
        inset 0 0 20px rgba(0, 255, 255, 0.1);
    }

    .title {
      font-size: 3.5rem;
      font-weight: 900;
      margin-bottom: 20px;
      background: linear-gradient(45deg, var(--tank-green), var(--tank-red), var(--explosion-orange));
      background-size: 300% 300%;
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      animation: gradient-shift 2s ease-in-out infinite;
      text-shadow: 0 0 30px rgba(255, 68, 68, 0.6);
    }

    @keyframes gradient-shift {
      0%, 100% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
    }

    .subtitle {
      color: var(--text-light);
      margin-bottom: 30px;
      font-size: 1.3rem;
      opacity: 0.9;
    }

    .game-options {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 20px;
      margin-bottom: 30px;
    }

    .option-card {
      background: linear-gradient(135deg, rgba(50, 205, 50, 0.1), rgba(255, 68, 68, 0.1));
      border: 2px solid transparent;
      border-radius: 15px;
      padding: 20px;
      cursor: pointer;
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
    }

    .option-card.active {
      border-color: var(--neon-green);
      background: linear-gradient(135deg, rgba(50, 205, 50, 0.2), rgba(255, 68, 68, 0.2));
      transform: scale(1.05);
      box-shadow: 0 0 25px rgba(0, 255, 65, 0.4);
    }

    .option-card:hover {
      transform: translateY(-3px);
      box-shadow: 0 10px 25px rgba(0, 255, 255, 0.3);
    }

    .option-title {
      font-weight: 700;
      font-size: 1.2rem;
      margin-bottom: 8px;
      color: var(--neon-green);
    }

    .option-desc {
      font-size: 0.9rem;
      opacity: 0.8;
      line-height: 1.3;
    }

    .btn {
      background: linear-gradient(135deg, var(--neon-green), var(--neon-cyan));
      border: none;
      border-radius: 12px;
      padding: 15px 30px;
      color: var(--bg-dark);
      font-family: inherit;
      font-weight: 700;
      font-size: 1.2rem;
      cursor: pointer;
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
      margin: 10px;
      text-transform: uppercase;
    }

    .btn:hover {
      transform: translateY(-3px) scale(1.05);
      box-shadow: 0 15px 30px rgba(0, 255, 65, 0.4);
    }

    .controls-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 15px;
      margin-bottom: 25px;
    }

    .control-section {
      background: rgba(0, 0, 0, 0.4);
      border: 1px solid rgba(0, 255, 255, 0.3);
      border-radius: 10px;
      padding: 15px;
    }

    .control-title {
      color: var(--neon-cyan);
      font-weight: 700;
      margin-bottom: 10px;
      font-size: 1.1rem;
    }

    .kbd {
      display: inline-block;
      padding: 4px 8px;
      background: rgba(0, 255, 255, 0.2);
      border: 1px solid rgba(0, 255, 255, 0.4);
      border-radius: 5px;
      font-size: 0.9rem;
      margin: 2px;
      font-weight: 600;
    }

    .hud {
      position: absolute;
      top: 20px;
      left: 20px;
      right: 20px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-weight: 700;
      pointer-events: none;
      z-index: 10;
    }

    .player-panel {
      background: rgba(10, 10, 10, 0.8);
      border: 2px solid var(--neon-cyan);
      border-radius: 10px;
      padding: 15px 20px;
      backdrop-filter: blur(5px);
      min-width: 200px;
    }

    .player-stats {
      display: flex;
      align-items: center;
      gap: 15px;
      margin-bottom: 8px;
    }

    .tank-icon {
      width: 24px;
      height: 16px;
      border-radius: 3px;
      position: relative;
    }

    .tank-icon::after {
      content: '';
      position: absolute;
      top: 6px;
      right: -8px;
      width: 12px;
      height: 4px;
      background: currentColor;
      border-radius: 2px;
    }

    .player1-color { background: var(--tank-green); color: var(--tank-green); }
    .player2-color { background: var(--tank-red); color: var(--tank-red); }

    .health-bar {
      width: 100%;
      height: 8px;
      background: rgba(255, 255, 255, 0.2);
      border-radius: 4px;
      overflow: hidden;
      margin-top: 5px;
    }

    .health-fill {
      height: 100%;
      background: linear-gradient(90deg, #ff0000, #ffff00, #00ff00);
      transition: width 0.3s ease;
      border-radius: 4px;
    }

    .game-info {
      background: rgba(10, 10, 10, 0.8);
      border: 2px solid var(--neon-cyan);
      border-radius: 10px;
      padding: 15px 20px;
      backdrop-filter: blur(5px);
      text-align: center;
    }

    .back-btn {
      position: absolute;
      top: 20px;
      right: 20px;
      background: rgba(255, 0, 64, 0.2);
      border: 2px solid #ff0040;
      border-radius: 10px;
      padding: 12px 18px;
      color: #ff0040;
      font-family: inherit;
      font-weight: 700;
      cursor: pointer;
      transition: all 0.3s ease;
      z-index: 20;
    }

    .back-btn:hover {
      background: rgba(255, 0, 64, 0.3);
      transform: translateY(-2px);
      box-shadow: 0 8px 20px rgba(255, 0, 64, 0.3);
    }

    .paused-overlay {
      position: absolute;
      inset: 0;
      background: rgba(10, 10, 10, 0.8);
      display: none;
      align-items: center;
      justify-content: center;
      font-size: 2.5rem;
      font-weight: 900;
      color: var(--neon-green);
      text-shadow: 0 0 30px rgba(0, 255, 65, 0.8);
      backdrop-filter: blur(5px);
    }

    .crosshair {
      position: absolute;
      width: 20px;
      height: 20px;
      border: 2px solid var(--bullet-yellow);
      border-radius: 50%;
      pointer-events: none;
      opacity: 0.8;
      z-index: 5;
      transform: translate(-50%, -50%);
    }

    .crosshair::before,
    .crosshair::after {
      content: '';
      position: absolute;
      background: var(--bullet-yellow);
    }

    .crosshair::before {
      width: 2px;
      height: 12px;
      top: 2px;
      left: 50%;
      transform: translateX(-50%);
    }

    .crosshair::after {
      width: 12px;
      height: 2px;
      top: 50%;
      left: 2px;
      transform: translateY(-50%);
    }

    .touch-controls {
      position: absolute;
      bottom: 30px;
      left: 20px;
      right: 20px;
      display: none;
      justify-content: space-between;
      align-items: center;
    }

    .movement-pad {
      display: grid;
      grid-template-columns: repeat(3, 50px);
      grid-template-rows: repeat(3, 50px);
      gap: 5px;
    }

    .action-controls {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .touch-btn {
      background: rgba(0, 255, 255, 0.3);
      border: 2px solid var(--neon-cyan);
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.2rem;
      color: var(--neon-cyan);
      font-weight: 700;
      cursor: pointer;
      transition: all 0.2s ease;
      user-select: none;
      -webkit-user-select: none;
      touch-action: manipulation;
    }

    .touch-btn:active {
      background: rgba(0, 255, 255, 0.5);
      transform: scale(0.95);
    }

    .move-up { grid-column: 2; grid-row: 1; }
    .move-left { grid-column: 1; grid-row: 2; }
    .move-right { grid-column: 3; grid-row: 2; }
    .move-down { grid-column: 2; grid-row: 3; }

    .fire-btn {
      width: 70px;
      height: 70px;
      border-radius: 50%;
      background: rgba(255, 215, 0, 0.3);
      border: 3px solid var(--bullet-yellow);
      color: var(--bullet-yellow);
      font-size: 1.5rem;
    }

    @media (max-width: 768px) {
      .touch-controls {
        display: flex;
      }
      
      .menu-card {
        padding: 25px;
      }
      
      .title {
        font-size: 2.5rem;
      }
      
      .game-options {
        grid-template-columns: 1fr;
        gap: 15px;
      }
      
      .controls-grid {
        grid-template-columns: 1fr;
      }
    }

    /* Animation effects */
    .muzzle-flash {
      position: absolute;
      width: 30px;
      height: 30px;
      background: radial-gradient(circle, var(--explosion-yellow), var(--explosion-orange));
      border-radius: 50%;
      pointer-events: none;
      animation: muzzle-flash 0.1s ease-out;
    }

    @keyframes muzzle-flash {
      0% { transform: scale(0); opacity: 1; }
      100% { transform: scale(1); opacity: 0; }
    }

    .explosion {
      position: absolute;
      pointer-events: none;
      animation: explosion 0.5s ease-out forwards;
    }

    @keyframes explosion {
      0% { transform: scale(0); opacity: 1; }
      50% { transform: scale(1.2); opacity: 0.8; }
      100% { transform: scale(1.5); opacity: 0; }
    }
  </style>
</head>
<body>
  <div id="gameContainer">
    <canvas id="gameCanvas" width="1000" height="700"></canvas>
    
    <div class="hud" id="hud" style="display: none;">
      <div class="player-panel">
        <div class="player-stats">
          <div class="tank-icon player1-color"></div>
          <span>Player 1</span>
        </div>
        <div>Health: <span id="player1Health">100</span>%</div>
        <div class="health-bar">
          <div class="health-fill player1-color" id="player1HealthBar" style="width: 100%;"></div>
        </div>
        <div style="margin-top: 8px;">Kills: <span id="player1Kills">0</span></div>
      </div>
      
      <div class="game-info">
        <div style="font-size: 1.3rem; margin-bottom: 5px;">TANK COMBAT</div>
        <div>Round: <span id="roundDisplay">1</span></div>
        <div>Time: <span id="timeDisplay">0:00</span></div>
      </div>
      
      <div class="player-panel" id="player2Panel" style="display: none;">
        <div class="player-stats">
          <div class="tank-icon player2-color"></div>
          <span>Player 2</span>
        </div>
        <div>Health: <span id="player2Health">100</span>%</div>
        <div class="health-bar">
          <div class="health-fill player2-color" id="player2HealthBar" style="width: 100%;"></div>
        </div>
        <div style="margin-top: 8px;">Kills: <span id="player2Kills">0</span></div>
      </div>
    </div>

    <button class="back-btn" onclick="goHome()" title="Back to Main Menu">
      ← HOME
    </button>

    <div class="paused-overlay" id="pausedOverlay">
      <div>PAUSED<br><small style="font-size: 1rem;">Press P or Start to resume</small></div>
    </div>

    <div class="touch-controls" id="touchControls">
      <div class="movement-pad">
        <div class="touch-btn move-up" data-action="move-up">↑</div>
        <div class="touch-btn move-left" data-action="move-left">←</div>
        <div class="touch-btn move-right" data-action="move-right">→</div>
        <div class="touch-btn move-down" data-action="move-down">↓</div>
      </div>
      
      <div class="action-controls">
        <div class="touch-btn fire-btn" data-action="fire">🔥</div>
      </div>
    </div>

    <!-- Menu overlay -->
    <div class="overlay" id="menuOverlay">
      <div class="menu-card">
        <h1 class="title">TANK COMBAT</h1>
        <p class="subtitle">Destroy terrain, eliminate enemies, dominate the battlefield!</p>
        
        <div class="game-options">
          <div class="option-card active" data-mode="single">
            <div class="option-title">🎯 SINGLE PLAYER</div>
            <div class="option-desc">Battle against AI tanks<br>Destructible environment</div>
          </div>
          <div class="option-card" data-mode="versus">
            <div class="option-title">⚔️ VERSUS</div>
            <div class="option-desc">1v1 Tank combat<br>Last tank standing wins</div>
          </div>
          <div class="option-card" data-mode="survival">
            <div class="option-title">🛡️ SURVIVAL</div>
            <div class="option-desc">Waves of enemy tanks<br>How long can you survive?</div>
          </div>
        </div>

        <div class="controls-grid">
          <div class="control-section">
            <div class="control-title">Player 1 Movement</div>
            <div>
              <span class="kbd">↑</span><span class="kbd">↓</span><span class="kbd">←</span><span class="kbd">→</span> or 
              <span class="kbd">W</span><span class="kbd">A</span><span class="kbd">S</span><span class="kbd">D</span>
            </div>
            <div style="margin-top: 5px;">
              Fire: <span class="kbd">Space</span> or <span class="kbd">Enter</span>
            </div>
          </div>
          <div class="control-section">
            <div class="control-title">Player 2 Controls</div>
            <div>
              Move: <span class="kbd">I</span><span class="kbd">J</span><span class="kbd">K</span><span class="kbd">L</span><br>
              Fire: <span class="kbd">U</span> or 🎮 Gamepad
            </div>
          </div>
          <div class="control-section">
            <div class="control-title">Game Controls</div>
            <div>
              <span class="kbd">P</span> Pause • <span class="kbd">F</span> Fullscreen<br>
              <span class="kbd">R</span> Reset Round
            </div>
          </div>
        </div>

        <button class="btn" onclick="startGame()">START BATTLE</button>
      </div>
    </div>

    <!-- Game Over overlay -->
    <div class="overlay hidden" id="gameOverOverlay">
      <div class="menu-card">
        <h1 class="title">MISSION COMPLETE</h1>
        <div id="finalStats" style="margin: 25px 0; font-size: 1.3rem;"></div>
        <div style="display: flex; gap: 15px; justify-content: center; flex-wrap: wrap;">
          <button class="btn" onclick="restartGame()">BATTLE AGAIN</button>
          <button class="btn" onclick="showMenu()">MAIN MENU</button>
        </div>
      </div>
    </div>
  </div>

  <script>
    // Game configuration
    const CONFIG = {
      CANVAS_WIDTH: 1000,
      CANVAS_HEIGHT: 700,
      TERRAIN_HEIGHT: 100,
      TANK_SIZE: 20,
      TANK_SPEED: 2,
      BULLET_SPEED: 8,
      BULLET_SIZE: 4,
      EXPLOSION_SIZE: 40,
      GRAVITY: 0.3,
      TERRAIN_DESTRUCTION_RADIUS: 25,
      MAX_HEALTH: 100,
      DAMAGE_PER_HIT: 25,
      COLORS: {
        sky: '#87CEEB',
        terrain: '#228B22',
        terrainBorder: '#8B4513',
        player1: '#32CD32',
        player2: '#FF4444',
        bullet: '#FFD700',
        explosion: '#FF6600',
        ai: '#8A2BE2'
      }
    };

    // Game state
    let gameState = {
      running: false,
      paused: false,
      mode: 'single', // single, versus, survival
      round: 1,
      gameTime: 0,
      terrain: [],
      players: [],
      bullets: [],
      explosions: [],
      particles: [],
      aiTanks: [],
      gameSpeed: 16, // 60fps
      lastUpdateTime: 0,
      pausePressed: false,
      fullscreenPressed: false,
      restartPressed: false
    };

    // Input handling
    class InputManager {
      constructor() {
        this.keys = new Set();
        this.touchActions = new Set();
        this.setupEventListeners();
      }

      setupEventListeners() {
        document.addEventListener('keydown', (e) => {
          this.keys.add(e.code);
          if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Space'].includes(e.code)) {
            e.preventDefault();
          }
        });

        document.addEventListener('keyup', (e) => {
          this.keys.delete(e.code);
        });

        // Touch controls
        document.querySelectorAll('.touch-btn').forEach(btn => {
          const action = btn.dataset.action;
          if (action) {
            btn.addEventListener('touchstart', (e) => {
              e.preventDefault();
              this.touchActions.add(action);
            });
            
            btn.addEventListener('touchend', (e) => {
              e.preventDefault();
              this.touchActions.delete(action);
            });
          }
        });
      }

      getPlayerInput(playerIndex) {
        const input = { left: false, right: false, up: false, down: false, fire: false };
        
        if (playerIndex === 0) {
          // Player 1 - Arrow keys, WASD, and touch
          input.left = this.keys.has('ArrowLeft') || this.keys.has('KeyA') || this.touchActions.has('move-left');
          input.right = this.keys.has('ArrowRight') || this.keys.has('KeyD') || this.touchActions.has('move-right');
          input.up = this.keys.has('ArrowUp') || this.keys.has('KeyW') || this.touchActions.has('move-up');
          input.down = this.keys.has('ArrowDown') || this.keys.has('KeyS') || this.touchActions.has('move-down');
          input.fire = this.keys.has('Space') || this.keys.has('Enter') || this.touchActions.has('fire');
        } else if (playerIndex === 1) {
          // Player 2 - IJKL and gamepad
          input.left = this.keys.has('KeyJ');
          input.right = this.keys.has('KeyL');
          input.up = this.keys.has('KeyI');
          input.down = this.keys.has('KeyK');
          input.fire = this.keys.has('KeyU');
          
          // Gamepad support
          const gamepad = navigator.getGamepads()[0];
          if (gamepad) {
            const threshold = 0.5;
            if (gamepad.axes[0] < -threshold || gamepad.buttons[14]?.pressed) input.left = true;
            if (gamepad.axes[0] > threshold || gamepad.buttons[15]?.pressed) input.right = true;
            if (gamepad.axes[1] < -threshold || gamepad.buttons[12]?.pressed) input.up = true;
            if (gamepad.axes[1] > threshold || gamepad.buttons[13]?.pressed) input.down = true;
            if (gamepad.buttons[0]?.pressed || gamepad.buttons[1]?.pressed) input.fire = true;
          }
        }
        
        return input;
      }

      isPausePressed() {
        if (this.keys.has('KeyP')) return true;
        const gamepad = navigator.getGamepads()[0];
        return gamepad?.buttons[9]?.pressed;
      }

      isFullscreenPressed() {
        return this.keys.has('KeyF');
      }

      isRestartPressed() {
        return this.keys.has('KeyR');
      }
    }

    // Audio system
    class AudioManager {
      constructor() {
        this.context = null;
        this.enabled = false;
      }

      async init() {
        try {
          this.context = new (window.AudioContext || window.webkitAudioContext)();
          if (this.context.state === 'suspended') {
            await this.context.resume();
          }
          this.enabled = true;
        } catch (e) {
          console.warn('Audio not available');
        }
      }

      playTone(frequency, duration = 0.1, type = 'square', volume = 0.1) {
        if (!this.enabled || !this.context) return;

        const oscillator = this.context.createOscillator();
        const gainNode = this.context.createGain();

        oscillator.connect(gainNode);
        gainNode.connect(this.context.destination);

        oscillator.frequency.value = frequency;
        oscillator.type = type;
        gainNode.gain.value = volume;

        oscillator.start();
        oscillator.stop(this.context.currentTime + duration);
      }

      playFire() {
        this.playTone(1200, 0.1, 'square', 0.15);
        setTimeout(() => this.playTone(800, 0.05, 'square', 0.1), 50);
      }

      playExplosion() {
        this.playTone(200, 0.3, 'sawtooth', 0.2);
        setTimeout(() => this.playTone(150, 0.2, 'sawtooth', 0.15), 100);
      }

      playHit() {
        this.playTone(600, 0.2, 'triangle', 0.12);
      }

      playEngine() {
        this.playTone(100, 0.1, 'sawtooth', 0.05);
      }
    }

    // Game entities
    class Tank {
      constructor(x, y, color, isPlayer = true, playerIndex = 0) {
        this.x = x;
        this.y = y;
        this.color = color;
        this.isPlayer = isPlayer;
        this.playerIndex = playerIndex;
        this.angle = 0; // Tank body rotation
        this.turretAngle = 0; // Turret rotation
        this.health = CONFIG.MAX_HEALTH;
        this.alive = true;
        this.kills = 0;
        this.lastFired = 0;
        this.fireRate = 500; // ms between shots
        this.vx = 0;
        this.vy = 0;
        this.onGround = false;
        
        // AI properties
        this.aiTarget = null;
        this.aiThinkTimer = 0;
        this.aiAction = 'idle';
      }

      update() {
        if (!this.alive) return;

        if (this.isPlayer) {
          this.updatePlayer();
        } else {
          this.updateAI();
        }

        // Apply physics
        this.applyPhysics();
        
        // Check terrain collision
        this.checkTerrainCollision();
      }

      updatePlayer() {
        const input = this.getInput();
        
        // Movement
        if (input.left) {
          this.angle -= 0.05;
          this.vx -= Math.cos(this.angle) * 0.3;
          if (this.onGround) audio.playEngine();
        }
        if (input.right) {
          this.angle += 0.05;
          this.vx += Math.cos(this.angle) * 0.3;
          if (this.onGround) audio.playEngine();
        }
        if (input.up) {
          this.vx += Math.cos(this.angle) * 0.5;
          this.vy += Math.sin(this.angle) * 0.5;
        }
        if (input.down) {
          this.vx -= Math.cos(this.angle) * 0.3;
          this.vy -= Math.sin(this.angle) * 0.3;
        }

        // Turret control (aim towards other tanks or mouse)
        this.updateTurretAiming();

        // Firing
        if (input.fire && Date.now() - this.lastFired > this.fireRate) {
          this.fire();
        }
      }

      updateAI() {
        this.aiThinkTimer++;
        
        if (this.aiThinkTimer % 60 === 0) { // Think every second
          // Find nearest target
          let nearestDistance = Infinity;
          this.aiTarget = null;
          
          for (const tank of gameState.players) {
            if (tank.alive) {
              const distance = Math.hypot(tank.x - this.x, tank.y - this.y);
              if (distance < nearestDistance) {
                nearestDistance = distance;
                this.aiTarget = tank;
              }
            }
          }
          
          // Decide action
          if (this.aiTarget && nearestDistance < 300) {
            this.aiAction = Math.random() < 0.7 ? 'attack' : 'move';
          } else {
            this.aiAction = 'patrol';
          }
        }

        // Execute AI action
        this.executeAIAction();
      }

      executeAIAction() {
        switch (this.aiAction) {
          case 'attack':
            if (this.aiTarget) {
              // Aim at target
              this.turretAngle = Math.atan2(this.aiTarget.y - this.y, this.aiTarget.x - this.x);
              
              // Fire if aimed
              if (Date.now() - this.lastFired > this.fireRate * 1.5) {
                this.fire();
              }
              
              // Move towards or away from target
              const distance = Math.hypot(this.aiTarget.x - this.x, this.aiTarget.y - this.y);
              if (distance > 200) {
                // Move closer
                this.angle = Math.atan2(this.aiTarget.y - this.y, this.aiTarget.x - this.x);
                this.vx += Math.cos(this.angle) * 0.3;
                this.vy += Math.sin(this.angle) * 0.3;
              } else if (distance < 100) {
                // Move away
                this.angle = Math.atan2(this.y - this.aiTarget.y, this.x - this.aiTarget.x);
                this.vx += Math.cos(this.angle) * 0.2;
                this.vy += Math.sin(this.angle) * 0.2;
              }
            }
            break;
            
          case 'patrol':
            // Random movement
            if (Math.random() < 0.02) {
              this.angle += (Math.random() - 0.5) * 0.2;
            }
            this.vx += Math.cos(this.angle) * 0.1;
            this.vy += Math.sin(this.angle) * 0.1;
            break;
            
          case 'move':
            // Evasive maneuvers
            this.angle += Math.sin(this.aiThinkTimer * 0.1) * 0.05;
            this.vx += Math.cos(this.angle) * 0.4;
            this.vy += Math.sin(this.angle) * 0.4;
            break;
        }
      }

      getInput() {
        return input.getPlayerInput(this.playerIndex);
      }

      updateTurretAiming() {
        // Simple aiming - point turret in movement direction
        if (Math.abs(this.vx) > 0.1 || Math.abs(this.vy) > 0.1) {
          this.turretAngle = Math.atan2(this.vy, this.vx);
        }
      }

      applyPhysics() {
        // Apply friction
        this.vx *= 0.95;
        this.vy *= 0.95;
        
        // Apply gravity
        if (!this.onGround) {
          this.vy += CONFIG.GRAVITY;
        }
        
        // Limit velocity
        const maxSpeed = CONFIG.TANK_SPEED;
        const speed = Math.hypot(this.vx, this.vy);
        if (speed > maxSpeed) {
          this.vx = (this.vx / speed) * maxSpeed;
          this.vy = (this.vy / speed) * maxSpeed;
        }
        
        // Update position
        this.x += this.vx;
        this.y += this.vy;
        
        // Keep in bounds
        this.x = Math.max(CONFIG.TANK_SIZE, Math.min(CONFIG.CANVAS_WIDTH - CONFIG.TANK_SIZE, this.x));
        this.y = Math.max(CONFIG.TANK_SIZE, Math.min(CONFIG.CANVAS_HEIGHT - CONFIG.TANK_SIZE, this.y));
      }

      checkTerrainCollision() {
        const terrainY = getTerrainHeight(this.x);
        this.onGround = false;
        
        if (this.y + CONFIG.TANK_SIZE / 2 >= terrainY) {
          this.y = terrainY - CONFIG.TANK_SIZE / 2;
          this.vy = 0;
          this.onGround = true;
        }
      }

      fire() {
        this.lastFired = Date.now();
        
        // Create bullet
        const bulletX = this.x + Math.cos(this.turretAngle) * (CONFIG.TANK_SIZE / 2 + 5);
        const bulletY = this.y + Math.sin(this.turretAngle) * (CONFIG.TANK_SIZE / 2 + 5);
        const bulletVx = Math.cos(this.turretAngle) * CONFIG.BULLET_SPEED;
        const bulletVy = Math.sin(this.turretAngle) * CONFIG.BULLET_SPEED;
        
        gameState.bullets.push(new Bullet(bulletX, bulletY, bulletVx, bulletVy, this));
        
        // Muzzle flash effect
        createMuzzleFlash(bulletX, bulletY);
        
        audio.playFire();
      }

      takeDamage(damage) {
        this.health -= damage;
        if (this.health <= 0) {
          this.alive = false;
          this.explode();
        }
        audio.playHit();
      }

      explode() {
        createExplosion(this.x, this.y, CONFIG.EXPLOSION_SIZE);
        destroyTerrain(this.x, this.y, CONFIG.TERRAIN_DESTRUCTION_RADIUS);
        audio.playExplosion();
      }

      render(ctx) {
        if (!this.alive) return;

        ctx.save();
        ctx.translate(this.x, this.y);
        
        // Draw tank body
        ctx.rotate(this.angle);
        ctx.fillStyle = this.color;
        ctx.fillRect(-CONFIG.TANK_SIZE / 2, -CONFIG.TANK_SIZE / 3, CONFIG.TANK_SIZE, CONFIG.TANK_SIZE * 2/3);
        
        // Draw tracks
        ctx.fillStyle = '#333';
        ctx.fillRect(-CONFIG.TANK_SIZE / 2, -CONFIG.TANK_SIZE / 2, CONFIG.TANK_SIZE, 4);
        ctx.fillRect(-CONFIG.TANK_SIZE / 2, CONFIG.TANK_SIZE / 2 - 4, CONFIG.TANK_SIZE, 4);
        
        ctx.restore();
        
        // Draw turret
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.turretAngle);
        ctx.fillStyle = this.color;
        ctx.fillRect(0, -3, CONFIG.TANK_SIZE / 2 + 8, 6);
        ctx.restore();
        
        // Draw health bar
        if (this.health < CONFIG.MAX_HEALTH) {
          const barWidth = CONFIG.TANK_SIZE;
          const barHeight = 4;
          const healthPercent = this.health / CONFIG.MAX_HEALTH;
          
          ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
          ctx.fillRect(this.x - barWidth / 2, this.y - CONFIG.TANK_SIZE / 2 - 10, barWidth, barHeight);
          
          ctx.fillStyle = healthPercent > 0.5 ? '#00ff00' : healthPercent > 0.25 ? '#ffff00' : '#ff0000';
          ctx.fillRect(this.x - barWidth / 2, this.y - CONFIG.TANK_SIZE / 2 - 10, barWidth * healthPercent, barHeight);
        }
      }
    }

    class Bullet {
      constructor(x, y, vx, vy, owner) {
        this.x = x;
        this.y = y;
        this.vx = vx;
        this.vy = vy;
        this.owner = owner;
        this.alive = true;
        this.trail = [];
      }

      update() {
        if (!this.alive) return;

        // Add to trail
        this.trail.push({ x: this.x, y: this.y });
        if (this.trail.length > 5) {
          this.trail.shift();
        }

        // Apply gravity
        this.vy += CONFIG.GRAVITY * 0.1;

        // Update position
        this.x += this.vx;
        this.y += this.vy;

        // Check bounds
        if (this.x < 0 || this.x > CONFIG.CANVAS_WIDTH || 
            this.y < 0 || this.y > CONFIG.CANVAS_HEIGHT) {
          this.alive = false;
          return;
        }

        // Check terrain collision
        const terrainY = getTerrainHeight(this.x);
        if (this.y >= terrainY) {
          this.explode();
          return;
        }

        // Check tank collisions
        this.checkTankCollisions();
      }

      checkTankCollisions() {
        const allTanks = [...gameState.players, ...gameState.aiTanks];
        
        for (const tank of allTanks) {
          if (tank === this.owner || !tank.alive) continue;
          
          const distance = Math.hypot(tank.x - this.x, tank.y - this.y);
          if (distance < CONFIG.TANK_SIZE / 2) {
            tank.takeDamage(CONFIG.DAMAGE_PER_HIT);
            if (!tank.alive) {
              this.owner.kills++;
            }
            this.explode();
            return;
          }
        }
      }

      explode() {
        this.alive = false;
        createExplosion(this.x, this.y, CONFIG.EXPLOSION_SIZE / 2);
        destroyTerrain(this.x, this.y, CONFIG.TERRAIN_DESTRUCTION_RADIUS);
        audio.playExplosion();
      }

      render(ctx) {
        if (!this.alive) return;

        // Draw trail
        ctx.strokeStyle = CONFIG.COLORS.bullet;
        ctx.lineWidth = 2;
        ctx.globalAlpha = 0.5;
        
        if (this.trail.length > 1) {
          ctx.beginPath();
          ctx.moveTo(this.trail[0].x, this.trail[0].y);
          for (let i = 1; i < this.trail.length; i++) {
            ctx.lineTo(this.trail[i].x, this.trail[i].y);
          }
          ctx.stroke();
        }
        
        ctx.globalAlpha = 1;

        // Draw bullet
        ctx.fillStyle = CONFIG.COLORS.bullet;
        ctx.shadowColor = CONFIG.COLORS.bullet;
        ctx.shadowBlur = 10;
        ctx.beginPath();
        ctx.arc(this.x, this.y, CONFIG.BULLET_SIZE, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
      }
    }

    class Explosion {
      constructor(x, y, maxSize) {
        this.x = x;
        this.y = y;
        this.size = 0;
        this.maxSize = maxSize;
        this.life = 30; // frames
        this.particles = [];
        
        // Create particles
        for (let i = 0; i < 15; i++) {
          this.particles.push({
            x: x + (Math.random() - 0.5) * 20,
            y: y + (Math.random() - 0.5) * 20,
            vx: (Math.random() - 0.5) * 10,
            vy: (Math.random() - 0.5) * 10 - 5,
            life: 20 + Math.random() * 20,
            maxLife: 20 + Math.random() * 20,
            size: 3 + Math.random() * 5
          });
        }
      }

      update() {
        this.life--;
        this.size = Math.min(this.maxSize, this.size + this.maxSize / 15);
        
        // Update particles
        this.particles.forEach(particle => {
          particle.x += particle.vx;
          particle.y += particle.vy;
          particle.vy += 0.2; // gravity
          particle.life--;
          particle.vx *= 0.98;
          particle.vy *= 0.98;
        });
        
        this.particles = this.particles.filter(p => p.life > 0);
      }

      render(ctx) {
        // Draw explosion circle
        const alpha = this.life / 30;
        ctx.globalAlpha = alpha;
        
        const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.size);
        gradient.addColorStop(0, CONFIG.COLORS.explosion);
        gradient.addColorStop(0.5, '#FFD700');
        gradient.addColorStop(1, 'transparent');
        
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fill();
        
        // Draw particles
        this.particles.forEach(particle => {
          const particleAlpha = particle.life / particle.maxLife;
          ctx.globalAlpha = alpha * particleAlpha;
          
          ctx.fillStyle = particleAlpha > 0.5 ? '#FFD700' : CONFIG.COLORS.explosion;
          ctx.beginPath();
          ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
          ctx.fill();
        });
        
        ctx.globalAlpha = 1;
      }

      get alive() {
        return this.life > 0 || this.particles.length > 0;
      }
    }

    // Initialize game systems
    const input = new InputManager();
    const audio = new AudioManager();

    // Canvas setup
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    ctx.imageSmoothingEnabled = false;

    // Terrain generation
    function generateTerrain() {
      gameState.terrain = [];
      const width = CONFIG.CANVAS_WIDTH;
      const baseHeight = CONFIG.CANVAS_HEIGHT - CONFIG.TERRAIN_HEIGHT;
      
      for (let x = 0; x < width; x++) {
        // Create rolling hills
        const hillHeight = Math.sin(x * 0.01) * 30 + Math.sin(x * 0.005) * 20;
        const terrainHeight = baseHeight + hillHeight;
        gameState.terrain[x] = Math.max(baseHeight - 50, terrainHeight);
      }
    }

    function getTerrainHeight(x) {
      const clampedX = Math.max(0, Math.min(CONFIG.CANVAS_WIDTH - 1, Math.floor(x)));
      return gameState.terrain[clampedX] || CONFIG.CANVAS_HEIGHT;
    }

    function destroyTerrain(centerX, centerY, radius) {
      for (let x = centerX - radius; x <= centerX + radius; x++) {
        if (x >= 0 && x < CONFIG.CANVAS_WIDTH) {
          const distance = Math.abs(x - centerX);
          if (distance <= radius) {
            const factor = 1 - (distance / radius);
            const destructionHeight = factor * radius;
            gameState.terrain[x] = Math.max(gameState.terrain[x], centerY + destructionHeight);
          }
        }
      }
    }

    function createMuzzleFlash(x, y) {
      const flash = document.createElement('div');
      flash.className = 'muzzle-flash';
      flash.style.left = x + 'px';
      flash.style.top = y + 'px';
      document.getElementById('gameContainer').appendChild(flash);
      
      setTimeout(() => {
        if (flash.parentNode) {
          flash.parentNode.removeChild(flash);
        }
      }, 100);
    }

    function createExplosion(x, y, size) {
      gameState.explosions.push(new Explosion(x, y, size));
    }

    // Game functions
    function initializeGame() {
      // Generate terrain
      generateTerrain();
      
      // Create players
      gameState.players = [];
      gameState.players.push(new Tank(200, 100, CONFIG.COLORS.player1, true, 0));
      
      if (gameState.mode === 'versus') {
        gameState.players.push(new Tank(CONFIG.CANVAS_WIDTH - 200, 100, CONFIG.COLORS.player2, true, 1));
        document.getElementById('player2Panel').style.display = 'block';
      } else {
        document.getElementById('player2Panel').style.display = 'none';
      }
      
      // Create AI tanks
      gameState.aiTanks = [];
      if (gameState.mode === 'single' || gameState.mode === 'survival') {
        const aiCount = gameState.mode === 'survival' ? 3 : 2;
        for (let i = 0; i < aiCount; i++) {
          const x = 400 + i * 200;
          const y = 100;
          gameState.aiTanks.push(new Tank(x, y, CONFIG.COLORS.ai, false));
        }
      }
      
      // Reset game state
      gameState.bullets = [];
      gameState.explosions = [];
      gameState.particles = [];
      gameState.gameTime = 0;
      
      updateHUD();
    }

    function updateGame() {
      if (!gameState.running || gameState.paused) return;

      gameState.gameTime += gameState.gameSpeed;

      // Update entities
      gameState.players.forEach(player => player.update());
      gameState.aiTanks.forEach(ai => ai.update());
      gameState.bullets.forEach(bullet => bullet.update());
      gameState.explosions.forEach(explosion => explosion.update());

      // Remove dead entities
      gameState.bullets = gameState.bullets.filter(bullet => bullet.alive);
      gameState.explosions = gameState.explosions.filter(explosion => explosion.alive);

      // Check win conditions
      checkWinConditions();
      
      updateHUD();
    }

    function checkWinConditions() {
      const alivePlayers = gameState.players.filter(p => p.alive);
      const aliveAI = gameState.aiTanks.filter(ai => ai.alive);
      
      if (gameState.mode === 'versus') {
        if (alivePlayers.length <= 1) {
          endGame();
        }
      } else if (gameState.mode === 'single') {
        if (alivePlayers.length === 0) {
          endGame();
        } else if (aliveAI.length === 0) {
          // Next round
          nextRound();
        }
      } else if (gameState.mode === 'survival') {
        if (alivePlayers.length === 0) {
          endGame();
        } else if (aliveAI.length === 0) {
          // Spawn more AI tanks
          spawnSurvivalWave();
        }
      }
    }

    function nextRound() {
      gameState.round++;
      // Heal players partially
      gameState.players.forEach(player => {
        if (player.alive) {
          player.health = Math.min(CONFIG.MAX_HEALTH, player.health + 50);
        }
      });
      
      setTimeout(() => {
        initializeGame();
      }, 2000);
    }

    function spawnSurvivalWave() {
      const waveSize = Math.min(6, 2 + Math.floor(gameState.round / 2));
      for (let i = 0; i < waveSize; i++) {
        const x = Math.random() * (CONFIG.CANVAS_WIDTH - 100) + 50;
        const y = 50;
        gameState.aiTanks.push(new Tank(x, y, CONFIG.COLORS.ai, false));
      }
      gameState.round++;
    }

    function handleInput() {
      if (!gameState.running) return;

      // Check pause
      if (input.isPausePressed() && !gameState.pausePressed) {
        gameState.paused = !gameState.paused;
        document.getElementById('pausedOverlay').style.display = gameState.paused ? 'flex' : 'none';
        gameState.pausePressed = true;
      } else if (!input.isPausePressed()) {
        gameState.pausePressed = false;
      }

      // Check fullscreen
      if (input.isFullscreenPressed() && !gameState.fullscreenPressed) {
        toggleFullscreen();
        gameState.fullscreenPressed = true;
      } else if (!input.isFullscreenPressed()) {
        gameState.fullscreenPressed = false;
      }

      // Check restart
      if (input.isRestartPressed() && !gameState.restartPressed) {
        restartGame();
        gameState.restartPressed = true;
      } else if (!input.isRestartPressed()) {
        gameState.restartPressed = false;
      }
    }

    function render() {
      // Clear canvas with sky gradient
      const gradient = ctx.createLinearGradient(0, 0, 0, CONFIG.CANVAS_HEIGHT);
      gradient.addColorStop(0, CONFIG.COLORS.sky);
      gradient.addColorStop(0.7, '#87CEEB');
      gradient.addColorStop(1, CONFIG.COLORS.terrain);
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, CONFIG.CANVAS_WIDTH, CONFIG.CANVAS_HEIGHT);

      // Draw terrain
      ctx.fillStyle = CONFIG.COLORS.terrain;
      ctx.beginPath();
      ctx.moveTo(0, CONFIG.CANVAS_HEIGHT);
      for (let x = 0; x < CONFIG.CANVAS_WIDTH; x++) {
        ctx.lineTo(x, gameState.terrain[x]);
      }
      ctx.lineTo(CONFIG.CANVAS_WIDTH, CONFIG.CANVAS_HEIGHT);
      ctx.closePath();
      ctx.fill();

      // Draw terrain border
      ctx.strokeStyle = CONFIG.COLORS.terrainBorder;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(0, gameState.terrain[0]);
      for (let x = 1; x < CONFIG.CANVAS_WIDTH; x++) {
        ctx.lineTo(x, gameState.terrain[x]);
      }
      ctx.stroke();

      // Draw game entities
      gameState.explosions.forEach(explosion => explosion.render(ctx));
      gameState.bullets.forEach(bullet => bullet.render(ctx));
      gameState.players.forEach(player => player.render(ctx));
      gameState.aiTanks.forEach(ai => ai.render(ctx));
    }

    function updateHUD() {
      if (gameState.players.length > 0) {
        const p1 = gameState.players[0];
        document.getElementById('player1Health').textContent = Math.max(0, p1.health);
        document.getElementById('player1HealthBar').style.width = Math.max(0, (p1.health / CONFIG.MAX_HEALTH) * 100) + '%';
        document.getElementById('player1Kills').textContent = p1.kills;
      }
      
      if (gameState.players.length > 1) {
        const p2 = gameState.players[1];
        document.getElementById('player2Health').textContent = Math.max(0, p2.health);
        document.getElementById('player2HealthBar').style.width = Math.max(0, (p2.health / CONFIG.MAX_HEALTH) * 100) + '%';
        document.getElementById('player2Kills').textContent = p2.kills;
      }
      
      document.getElementById('roundDisplay').textContent = gameState.round;
      
      const minutes = Math.floor(gameState.gameTime / 60000);
      const seconds = Math.floor((gameState.gameTime % 60000) / 1000);
      document.getElementById('timeDisplay').textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
    }

    function endGame() {
      gameState.running = false;
      
      let statsHtml = '';
      if (gameState.mode === 'versus') {
        const alivePlayers = gameState.players.filter(p => p.alive);
        if (alivePlayers.length > 0) {
          const winner = alivePlayers[0];
          const winnerNum = gameState.players.indexOf(winner) + 1;
          statsHtml += `<div style="color: ${winner.color}; font-size: 2rem; margin-bottom: 15px;">Player ${winnerNum} Wins!</div>`;
        } else {
          statsHtml += `<div style="font-size: 2rem; margin-bottom: 15px;">Draw!</div>`;
        }
      } else {
        const alivePlayers = gameState.players.filter(p => p.alive);
        if (alivePlayers.length > 0) {
          statsHtml += `<div style="color: ${CONFIG.COLORS.player1}; font-size: 2rem; margin-bottom: 15px;">Mission Complete!</div>`;
        } else {
          statsHtml += `<div style="color: #ff4444; font-size: 2rem; margin-bottom: 15px;">Mission Failed!</div>`;
        }
      }
      
      statsHtml += `<div style="font-size: 1.4rem; margin-bottom: 15px;">Round ${gameState.round} • Time: ${document.getElementById('timeDisplay').textContent}</div>`;
      statsHtml += '<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">';
      
      gameState.players.forEach((player, index) => {
        const status = player.alive ? 'ALIVE' : 'DESTROYED';
        statsHtml += `
          <div style="padding: 15px; border: 2px solid ${player.color}; border-radius: 10px;">
            <div style="color: ${player.color}; font-weight: 700; font-size: 1.2rem;">Player ${index + 1}</div>
            <div style="margin-top: 8px;">Health: ${Math.max(0, player.health)}%</div>
            <div>Kills: ${player.kills}</div>
            <div style="font-size: 0.9rem; opacity: 0.8;">${status}</div>
          </div>
        `;
      });
      statsHtml += '</div>';
      
      document.getElementById('finalStats').innerHTML = statsHtml;
      document.getElementById('gameOverOverlay').classList.remove('hidden');
    }

    // Game loop
    let lastTime = 0;
    function gameLoop(currentTime) {
      if (currentTime - lastTime >= gameState.gameSpeed) {
        handleInput();
        updateGame();
        lastTime = currentTime;
      }
      
      render();
      
      if (gameState.running) {
        requestAnimationFrame(gameLoop);
      }
    }

    // UI functions
    function showMenu() {
      gameState.running = false;
      document.getElementById('menuOverlay').classList.remove('hidden');
      document.getElementById('gameOverOverlay').classList.add('hidden');
      document.getElementById('hud').style.display = 'none';
    }

    function startGame() {
      audio.init();
      gameState.running = true;
      gameState.paused = false;
      document.getElementById('menuOverlay').classList.add('hidden');
      document.getElementById('gameOverOverlay').classList.add('hidden');
      document.getElementById('pausedOverlay').style.display = 'none';
      document.getElementById('hud').style.display = 'flex';
      
      initializeGame();
      requestAnimationFrame(gameLoop);
    }

    function restartGame() {
      gameState.round = 1;
      startGame();
    }

    function goHome() {
      window.location.href = '../index.html';
    }

    async function toggleFullscreen() {
      try {
        if (!document.fullscreenElement) {
          await canvas.requestFullscreen();
        } else {
          await document.exitFullscreen();
        }
      } catch (e) {
        console.warn('Fullscreen not supported');
      }
    }

    // Game mode selection
    document.querySelectorAll('.option-card').forEach(option => {
      option.addEventListener('click', () => {
        document.querySelectorAll('.option-card').forEach(opt => opt.classList.remove('active'));
        option.classList.add('active');
        gameState.mode = option.dataset.mode;
      });
    });

    // Initialize
    showMenu();
    
    // Handle visibility change to pause game
    document.addEventListener('visibilitychange', () => {
      if (document.hidden && gameState.running && !gameState.paused) {
        gameState.paused = true;
        document.getElementById('pausedOverlay').style.display = 'flex';
      }
    });
  </script>
</body>
</html>
