<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Neon Frogger - Retro Arcade</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');
    
    :root {
      --bg-dark: #000011;
      --neon-cyan: #00ffff;
      --neon-pink: #ff00ff;
      --neon-green: #00ff41;
      --neon-orange: #ff6600;
      --neon-purple: #8a2be2;
      --neon-yellow: #ffff00;
      --neon-red: #ff0040;
      --frog-green: #00ff41;
      --car-red: #ff0040;
      --car-blue: #0080ff;
      --car-yellow: #ffff00;
      --log-brown: #8b4513;
      --text-light: #e6f1ff;
      --text-muted: #8892b0;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    html, body {
      height: 100%;
      background: var(--bg-dark);
      color: var(--text-light);
      font-family: 'Orbitron', monospace;
      overflow: hidden;
      user-select: none;
      -webkit-user-select: none;
      touch-action: none;
    }

    #gameContainer {
      position: fixed;
      inset: 0;
      display: grid;
      place-items: center;
      background: 
        radial-gradient(circle at 25% 25%, rgba(0, 255, 255, 0.1) 0%, transparent 50%),
        radial-gradient(circle at 75% 75%, rgba(255, 0, 255, 0.1) 0%, transparent 50%),
        radial-gradient(circle at 50% 50%, rgba(0, 255, 65, 0.05) 0%, transparent 70%);
      padding: 20px;
    }

    canvas {
      border: 4px solid var(--neon-cyan);
      border-radius: 12px;
      background: linear-gradient(180deg, var(--bg-dark) 0%, #000022 50%, #000033 100%);
      box-shadow: 
        0 0 40px rgba(0, 255, 255, 0.5),
        inset 0 0 30px rgba(0, 255, 255, 0.1);
      max-width: 100%;
      max-height: 100%;
    }

    .overlay {
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
      background: rgba(0, 0, 17, 0.9);
      backdrop-filter: blur(10px);
      overflow-y: auto;
      padding: 20px 0;
    }

    .menu-card {
      background: linear-gradient(135deg, rgba(0, 255, 255, 0.1), rgba(255, 0, 255, 0.1));
      border: 3px solid var(--neon-cyan);
      border-radius: 20px;
      padding: 30px;
      text-align: center;
      max-width: 600px;
      width: 90vw;
      max-height: 90vh;
      overflow-y: auto;
      box-shadow: 
        0 0 50px rgba(0, 255, 255, 0.4),
        inset 0 0 30px rgba(0, 255, 255, 0.1);
      margin: 10px;
    }

    .title {
      font-size: 3rem;
      font-weight: 900;
      margin-bottom: 15px;
      background: linear-gradient(45deg, var(--neon-green), var(--neon-cyan), var(--neon-yellow));
      background-size: 400% 400%;
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      animation: gradient-shift 3s ease-in-out infinite;
      text-shadow: 0 0 40px rgba(0, 255, 65, 0.6);
    }

    @keyframes gradient-shift {
      0%, 100% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
    }

    .subtitle {
      color: var(--text-muted);
      margin-bottom: 30px;
      font-size: 1.1rem;
      line-height: 1.5;
    }

    .btn {
      background: linear-gradient(45deg, var(--neon-cyan), var(--neon-green));
      border: none;
      color: var(--bg-dark);
      padding: 15px 30px;
      font-size: 1.1rem;
      font-weight: 700;
      border-radius: 25px;
      cursor: pointer;
      margin: 10px;
      transition: all 0.3s ease;
      text-transform: uppercase;
      letter-spacing: 1px;
      box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
    }

    .btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 0 30px rgba(0, 255, 255, 0.6);
      filter: brightness(1.2);
    }

    .btn:active {
      transform: translateY(0);
    }

    .controls-info {
      background: rgba(0, 255, 255, 0.1);
      border: 1px solid var(--neon-cyan);
      border-radius: 15px;
      padding: 20px;
      margin: 20px 0;
      text-align: left;
      max-height: 60vh;
      overflow-y: auto;
    }

    .controls-info h3 {
      color: var(--neon-cyan);
      margin-bottom: 15px;
      font-size: 1.2rem;
    }

    .controls-info ul {
      list-style: none;
      padding: 0;
      margin-bottom: 20px;
    }
    
    .controls-info ul:last-child {
      margin-bottom: 0;
    }

    .controls-info li {
      margin: 8px 0;
      padding: 5px 0;
      border-bottom: 1px solid rgba(0, 255, 255, 0.2);
    }

    .controls-info li:last-child {
      border-bottom: none;
      margin-bottom: 0;
    }
    
    .key {
      background: rgba(0, 255, 255, 0.2);
      padding: 3px 8px;
      border-radius: 5px;
      font-family: monospace;
      border: 1px solid var(--neon-cyan);
      display: inline-block;
      min-width: 20px;
      text-align: center;
      margin: 0 2px;
    }

    .score-display {
      position: absolute;
      top: 20px;
      left: 20px;
      background: rgba(0, 0, 0, 0.8);
      padding: 15px;
      border-radius: 10px;
      border: 2px solid var(--neon-cyan);
      color: var(--neon-cyan);
      font-size: 1.2rem;
      font-weight: 700;
      z-index: 10;
      backdrop-filter: blur(10px);
    }

    .game-over {
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
      background: rgba(0, 0, 0, 0.9);
      backdrop-filter: blur(10px);
      z-index: 20;
    }

    .game-over-card {
      background: linear-gradient(135deg, rgba(255, 0, 0, 0.1), rgba(255, 0, 0, 0.05));
      border: 3px solid var(--neon-red);
      border-radius: 20px;
      padding: 40px;
      text-align: center;
      max-width: 500px;
      width: 90vw;
      box-shadow: 0 0 50px rgba(255, 0, 0, 0.4);
      margin: 10px;
    }

    .game-over-title {
      font-size: 2.5rem;
      font-weight: 900;
      margin-bottom: 20px;
      color: var(--neon-red);
      text-shadow: 0 0 30px rgba(255, 0, 0, 0.6);
    }

    .final-score {
      font-size: 1.5rem;
      color: var(--neon-yellow);
      margin-bottom: 30px;
      text-shadow: 0 0 20px rgba(255, 255, 0, 0.6);
    }

    .hidden {
      display: none !important;
    }
    
    .desktop-only {
      display: inline;
    }
    
    /* Home Button */
    .home-btn {
      position: fixed;
      bottom: 20px;
      left: 20px;
      background: rgba(0, 255, 65, 0.2);
      border: 2px solid var(--neon-green);
      border-radius: 15px;
      padding: 12px 18px;
      color: var(--neon-green);
      font-family: inherit;
      font-weight: 700;
      cursor: pointer;
      transition: all 0.3s ease;
      z-index: 1000;
      display: flex;
      align-items: center;
      gap: 8px;
      text-decoration: none;
      backdrop-filter: blur(10px);
    }
    
    .home-btn:hover {
      background: rgba(0, 255, 65, 0.3);
      box-shadow: 0 0 20px rgba(0, 255, 65, 0.5);
      transform: translateY(-2px);
    }
    
    .home-btn:active {
      transform: translateY(0);
    }
    
    .home-btn:focus {
      outline: 2px solid var(--neon-green);
      outline-offset: 2px;
    }

    @media (max-width: 768px) {
      .title {
        font-size: 2rem;
        margin-bottom: 12px;
      }
      
      .subtitle {
        margin-bottom: 25px;
      }
      
      .menu-card {
        padding: 20px;
      }
      
      .btn {
        padding: 12px 24px;
        font-size: 1rem;
        margin: 8px;
      }
      
      .score-display {
        top: 15px;
        left: 15px;
        padding: 12px;
        font-size: 1rem;
      }
      
      .controls-info {
        padding: 15px;
        margin: 12px 0;
        max-height: 50vh;
      }
      
      .controls-info h3 {
        margin-bottom: 12px;
        font-size: 1.1rem;
      }
      
      .controls-info li {
        margin: 6px 0;
        padding: 4px 0;
      }
      
      .controls-info ul {
        margin-bottom: 15px;
      }
      
      .controls-info ul:last-child {
        margin-bottom: 0;
      }
      
      .key {
        padding: 2px 6px;
        font-size: 0.9rem;
        min-width: 18px;
        margin: 0 1px;
      }
      
      .desktop-only {
        display: none;
      }
      
      .game-over-card {
        padding: 30px;
      }
      
      .game-over-title {
        font-size: 2.2rem;
        margin-bottom: 18px;
      }
      
      .final-score {
        font-size: 1.4rem;
        margin-bottom: 28px;
      }
      
      .pause-screen .title {
        font-size: 1.8rem;
        margin-bottom: 15px;
      }
      
      .pause-screen .subtitle {
        font-size: 0.9rem;
        margin-bottom: 20px;
      }
      
      .home-btn {
        bottom: 15px;
        left: 15px;
        padding: 10px 16px;
        font-size: 0.9rem;
        gap: 6px;
      }
      
      .home-btn:focus {
        outline-width: 1px;
        outline-offset: 1px;
      }
      
      canvas {
        border-width: 3px;
        border-radius: 10px;
      }
      
      #gameContainer {
        padding: 15px;
      }
      
      .overlay {
        padding: 15px 0;
      }
    }
    
    @media (max-width: 480px) {
      .title {
        font-size: 1.8rem;
        margin-bottom: 10px;
      }
      
      .subtitle {
        margin-bottom: 20px;
      }
      
      .menu-card {
        padding: 15px;
      }
      
      .btn {
        padding: 10px 20px;
        font-size: 0.9rem;
        margin: 6px;
      }
      
      .score-display {
        top: 10px;
        left: 10px;
        padding: 10px;
        font-size: 0.9rem;
      }
      
      .controls-info {
        padding: 12px;
        margin: 10px 0;
        max-height: 45vh;
      }
      
      .controls-info h3 {
        margin-bottom: 10px;
        font-size: 1rem;
      }
      
      .controls-info li {
        margin: 5px 0;
        padding: 3px 0;
      }
      
      .controls-info ul {
        margin-bottom: 12px;
      }
      
      .controls-info ul:last-child {
        margin-bottom: 0;
      }
      
      .key {
        padding: 2px 5px;
        font-size: 0.8rem;
        min-width: 16px;
        margin: 0 1px;
      }
      
      .desktop-only {
        display: none;
      }
      
      .game-over-card {
        padding: 25px;
      }
      
      .game-over-title {
        font-size: 2rem;
        margin-bottom: 15px;
      }
      
      .final-score {
        font-size: 1.3rem;
        margin-bottom: 25px;
      }
      
      .pause-screen .title {
        font-size: 1.6rem;
        margin-bottom: 12px;
      }
      
      .pause-screen .subtitle {
        font-size: 0.8rem;
        margin-bottom: 18px;
      }
      
      .home-btn {
        bottom: 10px;
        left: 10px;
        padding: 8px 14px;
        font-size: 0.8rem;
        gap: 4px;
      }
      
      canvas {
        border-width: 2px;
        border-radius: 8px;
      }
      
      #gameContainer {
        padding: 10px;
      }
      
      .overlay {
        padding: 10px 0;
      }
    }
  </style>
</head>
<body>
  <div id="gameContainer">
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    
    <!-- Score Display -->
    <div class="score-display">
      <div>Score: <span id="score">0</span></div>
      <div>Lives: <span id="lives">3</span></div>
      <div>Level: <span id="level">1</span></div>
    </div>

    <!-- Main Menu -->
    <div class="overlay" id="mainMenu">
      <div class="menu-card">
        <h1 class="title">Neon Frogger</h1>
        <p class="subtitle">
          Guide the frog across the busy road and treacherous river to reach the lily pads!<br class="desktop-only">
          Avoid cars, trucks, and don't fall in the water. Use logs and turtles to cross safely.
        </p>
        
        <button class="btn" onclick="startGame()">Start Game</button>
        <button class="btn" onclick="showControls()">How to Play</button>
        
        <div class="controls-info hidden" id="controlsInfo">
          <h3>🎮 Controls</h3>
          <ul>
            <li><span class="key">↑</span> or <span class="key">W</span> - Move Up</li>
            <li><span class="key">↓</span> or <span class="key">S</span> - Move Down</li>
            <li><span class="key">←</span> or <span class="key">A</span> - Move Left</li>
            <li><span class="key">→</span> or <span class="key">D</span> - Move Right</li>
            <li><span class="key">SPACE</span> - Pause/Resume</li>
            <li><span class="key">R</span> - Restart Game</li>
          </ul>
          
          <h3>🎯 Objective</h3>
          <ul>
            <li>Cross the road avoiding vehicles</li>
            <li>Cross the river using logs and turtles</li>
            <li>Reach the lily pads at the top</li>
            <li>Complete all 5 lily pads to advance to next level</li>
            <li>Don't fall in the water or get hit by cars!</li>
          </ul>
        </div>
      </div>
    </div>

    <!-- Game Over Screen -->
    <div class="overlay game-over hidden" id="gameOver">
      <div class="game-over-card">
        <h2 class="game-over-title">Game Over</h2>
        <div class="final-score">Final Score: <span id="finalScore">0</span></div>
        <button class="btn" onclick="restartGame()">Play Again</button>
        <button class="btn" onclick="showMainMenu()">Main Menu</button>
      </div>
    </div>

    <!-- Pause Screen -->
    <div class="overlay pause-screen hidden" id="pauseScreen">
      <div class="menu-card">
        <h2 class="title">Game Paused</h2>
        <p class="subtitle">Press SPACE to resume or R to restart</p>
        <button class="btn" onclick="resumeGame()">Resume</button>
        <button class="btn" onclick="restartGame()">Restart</button>
      </div>
    </div>

  <!-- Home Button -->
  <a href="../index.html" class="home-btn">
    <span>←</span>
    <span>HOME</span>
  </a>

  <script>
    // Game variables
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    // Responsive canvas setup
    let canvasScale = 1;
    let canvasOffsetX = 0;
    let canvasOffsetY = 0;
    
    function resizeCanvas() {
      const container = document.getElementById('gameContainer');
      const containerRect = container.getBoundingClientRect();
      
      // Calculate available space (accounting for padding)
      const maxWidth = Math.min(containerRect.width - 40, 800);
      const maxHeight = Math.min(containerRect.height - 40, 600);
      
      // Calculate scale to fit within container
      const scaleX = maxWidth / 800;
      const scaleY = maxHeight / 600;
      canvasScale = Math.min(scaleX, scaleY);
      
      // Set canvas size
      canvas.style.width = (800 * canvasScale) + 'px';
      canvas.style.height = (600 * canvasScale) + 'px';
      
      // Center canvas
      canvasOffsetX = (containerRect.width - (800 * canvasScale)) / 2;
      canvasOffsetY = (containerRect.height - (600 * canvasScale)) / 2;
      canvas.style.marginLeft = canvasOffsetX + 'px';
      canvas.style.marginTop = canvasOffsetY + 'px';
    }
    
    // Handle window resize
    window.addEventListener('resize', resizeCanvas);
    
    // Handle touch events for mobile
    document.addEventListener('touchstart', function(e) {
      if (e.target.classList.contains('home-btn')) {
        e.preventDefault();
      }
    }, { passive: false });
    
    let gameState = 'menu'; // menu, playing, paused, gameOver
    let score = 0;
    let lives = 3;
    let level = 1;
    let gameTime = 0;
    let lastTime = 0;
    
    // Game objects
    let frog = {
      x: 400,
      y: 550,
      width: 20,
      height: 20,
      speed: 20,
      onLog: false,
      onTurtle: false,
      logOffset: 0,
      turtleOffset: 0
    };
    
    let vehicles = [];
    let logs = [];
    let turtles = [];
    let lilyPads = [];
    let particles = [];
    
    // Game settings
    const GRID_SIZE = 20;
    const ROAD_LANES = 5;
    const RIVER_LANES = 5;
    const SAFE_ZONES = 2;
    
    // Initialize game
    function initGame() {
      createVehicles();
      createLogs();
      createTurtles();
      createLilyPads();
      resetFrog();
    }
    
    function createVehicles() {
      vehicles = [];
      const vehicleTypes = [
        { width: 40, height: 20, speed: 2, color: 'var(--car-red)' },
        { width: 60, height: 20, speed: 3, color: 'var(--car-blue)' },
        { width: 30, height: 20, speed: 4, color: 'var(--car-yellow)' }
      ];
      
      for (let lane = 0; lane < ROAD_LANES; lane++) {
        const y = 450 - (lane * 40);
        const type = vehicleTypes[lane % vehicleTypes.length];
        const direction = lane % 2 === 0 ? 1 : -1;
        
        for (let i = 0; i < 3; i++) {
          vehicles.push({
            x: direction === 1 ? -100 - (i * 200) : canvas.width + 100 + (i * 200),
            y: y,
            width: type.width,
            height: type.height,
            speed: type.speed * direction,
            color: type.color
          });
        }
      }
    }
    
         function createLogs() {
       logs = [];
       const logTypes = [
         { width: 80, height: 20, speed: 0.8 },
         { width: 100, height: 20, speed: 1.0 },
         { width: 60, height: 20, speed: 0.6 }
       ];
       
       for (let lane = 0; lane < RIVER_LANES; lane++) {
         const y = 250 - (lane * 40);
         const type = logTypes[lane % logTypes.length];
         const direction = lane % 2 === 0 ? 1 : -1;
         
         for (let i = 0; i < 2; i++) {
           logs.push({
             x: direction === 1 ? -150 - (i * 300) : canvas.width + 150 + (i * 300),
             y: y,
             width: type.width,
             height: type.height,
             speed: type.speed * direction
           });
         }
       }
     }
    
    function createTurtles() {
      turtles = [];
      for (let lane = 0; lane < 3; lane++) {
        const y = 170 - (lane * 40);
        const direction = lane % 2 === 0 ? 1 : -1;
        
        for (let i = 0; i < 2; i++) {
          turtles.push({
            x: direction === 1 ? -100 - (i * 250) : canvas.width + 100 + (i * 200),
            y: y,
            width: 60,
            height: 20,
            speed: 0.6 * direction,
            diveTimer: 0,
            diving: false
          });
        }
      }
      
      // Add a static turtle for debugging
      turtles.push({
        x: 400,
        y: 130,
        width: 60,
        height: 20,
        speed: 0,
        diveTimer: 0,
        diving: false
      });
    }
    
    function createLilyPads() {
      lilyPads = [];
      for (let i = 0; i < 5; i++) {
        lilyPads.push({
          x: 100 + (i * 140),
          y: 50,
          width: 40,
          height: 20,
          occupied: false
        });
      }
    }
    
    function resetFrog() {
      frog.x = 400;
      frog.y = 550;
      frog.onLog = false;
      frog.onTurtle = false;
      frog.logOffset = 0;
      frog.turtleOffset = 0;
    }
    
    // Game loop
    function gameLoop(currentTime) {
      if (gameState === 'playing') {
        const deltaTime = currentTime - lastTime;
        gameTime += deltaTime;
        
        updateGame(deltaTime);
        renderGame();
      }
      
      lastTime = currentTime;
      requestAnimationFrame(gameLoop);
    }
    
         function updateGame(deltaTime) {
       updateVehicles(deltaTime);
       updateLogs(deltaTime);
       updateTurtles(deltaTime);
       updateFrog();
       moveFrogWithLogs(); // Move frog with logs/turtles every frame
       checkCollisions();
       updateParticles(deltaTime);
     }
    
    function updateVehicles(deltaTime) {
      vehicles.forEach(vehicle => {
        vehicle.x += vehicle.speed * (deltaTime / 16);
        
        // Wrap around screen
        if (vehicle.speed > 0 && vehicle.x > canvas.width + 100) {
          vehicle.x = -100;
        } else if (vehicle.speed < 0 && vehicle.x < -100) {
          vehicle.x = canvas.width + 100;
        }
      });
    }
    
    function updateLogs(deltaTime) {
      logs.forEach(log => {
        log.x += log.speed * (deltaTime / 16);
        
        // Wrap around screen
        if (log.speed > 0 && log.x > canvas.width + 150) {
          log.x = -150;
        } else if (log.speed < 0 && log.x < -150) {
          log.x = canvas.width + 150;
        }
      });
    }
    
    function updateTurtles(deltaTime) {
      turtles.forEach((turtle, index) => {
        turtle.x += turtle.speed * (deltaTime / 16);
        turtle.diveTimer += deltaTime;
        
        // Turtles dive every 3 seconds
        if (turtle.diveTimer > 3000) {
          turtle.diving = !turtle.diving;
          turtle.diveTimer = 0;
        }
        
        // Wrap around screen
        if (turtle.speed > 0 && turtle.x > canvas.width + 100) {
          turtle.x = -100;
        } else if (turtle.speed < 0 && turtle.x < -100) {
          turtle.x = canvas.width + 100;
        }
        

      });
    }
    
    function updateFrog() {
      // Check if frog is on a log
      frog.onLog = false;
      logs.forEach(log => {
        if (frog.y >= log.y && frog.y <= log.y + log.height &&
            frog.x >= log.x && frog.x <= log.x + log.width) {
          frog.onLog = true;
          frog.logOffset = frog.x - log.x;
        }
      });
      
      // Check if frog is on a turtle
      frog.onTurtle = false;
      turtles.forEach(turtle => {
        if (!turtle.diving && 
            frog.y >= turtle.y && frog.y <= turtle.y + turtle.height &&
            frog.x >= turtle.x && frog.x <= turtle.x + turtle.width) {
          frog.onTurtle = true;
          frog.turtleOffset = frog.x - turtle.x;
        }
      });
      
      // Movement logic moved to moveFrogWithLogs() function for smoother movement
      
      // Check if frog fell in water (only in river area, not on road)
      if (frog.y < 270 && frog.y > 50 && !frog.onLog && !frog.onTurtle) {
        loseLife();
      }
      
             // Check if frog reached lily pad
       lilyPads.forEach((pad, index) => {
         if (!pad.occupied && 
             frog.y <= pad.y + pad.height && frog.y >= pad.y &&
             frog.x >= pad.x && frog.x <= pad.x + pad.width) {
           pad.occupied = true;
           score += 100;
           updateScore();
           createParticles(frog.x, frog.y, 'var(--neon-green)');
           
           // Check if all lily pads are occupied
           if (lilyPads.every(pad => pad.occupied)) {
             levelUp();
           } else {
             resetFrog();
           }
         }
       });
     }
     
     function moveFrogWithLogs() {
       // Move frog with log/turtle every frame
       if (frog.onLog) {
         const log = logs.find(l => 
           frog.y >= l.y && frog.y <= l.y + l.height &&
           frog.x >= l.x && frog.x <= l.x + l.width
         );
         if (log) {
           frog.x = log.x + frog.logOffset;
           // Keep frog within canvas bounds
           if (frog.x < 0) frog.x = 0;
           if (frog.x > canvas.width - frog.width) frog.x = canvas.width - frog.width;
         }
       }
       
       if (frog.onTurtle) {
         const currentTurtle = turtles.find(t => 
           !t.diving &&
           frog.y >= t.y && frog.y <= t.y + t.height &&
           frog.x >= t.x && frog.x <= t.x + t.width
         );
         if (currentTurtle) {
           frog.x = currentTurtle.x + frog.turtleOffset;
           // Keep frog within canvas bounds
           if (frog.x < 0) frog.x = 0;
           if (frog.x > canvas.width - frog.width) frog.x = canvas.width - frog.width;
         }
       }
     }
    
    function checkCollisions() {
      // Check vehicle collisions
      vehicles.forEach(vehicle => {
        if (frog.x < vehicle.x + vehicle.width &&
            frog.x + frog.width > vehicle.x &&
            frog.y < vehicle.y + vehicle.height &&
            frog.y + frog.height > vehicle.y) {
          loseLife();
        }
      });
      
      // Check if frog is on diving turtle
      turtles.forEach(t => {
        if (frog.onTurtle && t.diving) {
          loseLife();
        }
      });
    }
    
    function loseLife() {
      lives--;
      updateScore();
      createParticles(frog.x, frog.y, 'var(--neon-red)');
      
      if (lives <= 0) {
        gameOver();
      } else {
        resetFrog();
      }
    }
    
    function levelUp() {
      level++;
      updateScore();
      
      // Increase difficulty
      vehicles.forEach(vehicle => {
        vehicle.speed *= 1.2;
      });
      
      logs.forEach(log => {
        log.speed *= 1.1;
      });
      
      turtles.forEach(t => {
        t.speed *= 1.1;
      });
      
      // Reset lily pads
      lilyPads.forEach(pad => {
        pad.occupied = false;
      });
      
      resetFrog();
    }
    
    function updateParticles(deltaTime) {
      particles = particles.filter(particle => {
        particle.life -= deltaTime;
        particle.x += particle.vx;
        particle.y += particle.vy;
        particle.vy += 0.1; // gravity
        
        return particle.life > 0;
      });
    }
    
    function createParticles(x, y, color) {
      for (let i = 0; i < 10; i++) {
        particles.push({
          x: x + Math.random() * 20 - 10,
          y: y + Math.random() * 20 - 10,
          vx: (Math.random() - 0.5) * 4,
          vy: (Math.random() - 0.5) * 4,
          life: 1000,
          color: color
        });
      }
    }
    
    // Rendering
    function renderGame() {
      // Clear canvas
      ctx.fillStyle = '#001122';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // Draw background zones
      drawBackgroundZones();
      
      // Draw game objects
      drawLilyPads();
      drawLogs();
      drawTurtles();
      drawVehicles();
      drawFrog();
      drawParticles();
      
      // Draw grid lines (for debugging, can be removed)
      // drawGrid();
    }
    
    function drawBackgroundZones() {
      // Safe zone (top)
      ctx.fillStyle = 'rgba(0, 255, 65, 0.1)';
      ctx.fillRect(0, 0, canvas.width, 70);
      
      // River
      ctx.fillStyle = 'rgba(0, 255, 255, 0.1)';
      ctx.fillRect(0, 70, canvas.width, 200);
      
      // Safe zone (middle)
      ctx.fillStyle = 'rgba(0, 255, 65, 0.1)';
      ctx.fillRect(0, 270, canvas.width, 40);
      
      // Road
      ctx.fillStyle = 'rgba(255, 0, 0, 0.1)';
      ctx.fillRect(0, 310, canvas.width, 200);
      
      // Safe zone (bottom)
      ctx.fillStyle = 'rgba(0, 255, 65, 0.1)';
      ctx.fillRect(0, 510, canvas.width, 90);
    }
    
    function drawLilyPads() {
      lilyPads.forEach((pad, index) => {
        if (pad.occupied) {
          ctx.fillStyle = 'var(--neon-green)';
          ctx.shadowColor = 'var(--neon-green)';
          ctx.shadowBlur = 10;
        } else {
          ctx.fillStyle = 'var(--neon-cyan)';
          ctx.shadowColor = 'var(--neon-cyan)';
          ctx.shadowBlur = 5;
        }
        
        ctx.fillRect(pad.x, pad.y, pad.width, pad.height);
        ctx.shadowBlur = 0;
      });
    }
    
    function drawLogs() {
      logs.forEach(log => {
        ctx.fillStyle = 'var(--log-brown)';
        ctx.fillRect(log.x, log.y, log.width, log.height);
        
        // Log texture
        ctx.strokeStyle = '#654321';
        ctx.lineWidth = 1;
        for (let i = 0; i < 3; i++) {
          ctx.beginPath();
          ctx.moveTo(log.x, log.y + (i * 5) + 5);
          ctx.lineTo(log.x + log.width, log.y + (i * 5) + 5);
          ctx.stroke();
        }
      });
    }
    
    function drawTurtles() {
      if (turtles.length === 0) {
        console.log('No turtles to draw');
        return;
      }
      
      turtles.forEach((turtle, index) => {
        if (turtle.diving) {
          ctx.fillStyle = 'rgba(139, 69, 19, 0.5)';
        } else {
          ctx.fillStyle = 'var(--neon-orange)';
          ctx.shadowColor = 'var(--neon-orange)';
          ctx.shadowBlur = 8;
        }
        
        ctx.fillRect(turtle.x, turtle.y, turtle.width, turtle.height);
        
        if (!turtle.diving) {
          // Turtle shell pattern
          ctx.strokeStyle = '#ff8800';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.arc(turtle.x + turtle.width/2, turtle.y + turtle.height/2, 6, 0, Math.PI * 2);
          ctx.stroke();
          
          // Turtle head
          ctx.fillStyle = '#ff6600';
          ctx.fillRect(turtle.x + turtle.width/2 - 3, turtle.y - 5, 6, 5);
        }
        
        ctx.shadowBlur = 0;
        

      });
    }
    
    function drawVehicles() {
      vehicles.forEach(vehicle => {
        ctx.fillStyle = vehicle.color;
        ctx.shadowColor = vehicle.color;
        ctx.shadowBlur = 10;
        ctx.fillRect(vehicle.x, vehicle.y, vehicle.width, vehicle.height);
        ctx.shadowBlur = 0;
        
        // Vehicle details
        ctx.fillStyle = '#000';
        ctx.fillRect(vehicle.x + 2, vehicle.y + 2, vehicle.width - 4, vehicle.height - 4);
        
        // Windows
        ctx.fillStyle = vehicle.color;
        ctx.fillRect(vehicle.x + 4, vehicle.y + 4, vehicle.width - 8, vehicle.height - 8);
      });
    }
    
    function drawFrog() {
      // Frog body
      ctx.fillStyle = 'var(--frog-green)';
      ctx.shadowColor = 'var(--frog-green)';
      ctx.shadowBlur = 15;
      ctx.fillRect(frog.x, frog.y, frog.width, frog.height);
      ctx.shadowBlur = 0;
      
      // Frog eyes
      ctx.fillStyle = '#000';
      ctx.fillRect(frog.x + 3, frog.y + 3, 4, 4);
      ctx.fillRect(frog.x + 13, frog.y + 3, 4, 4);
      
      // Frog mouth
      ctx.fillStyle = '#000';
      ctx.fillRect(frog.x + 7, frog.y + 15, 6, 2);
    }
    
    function drawParticles() {
      particles.forEach(particle => {
        const alpha = particle.life / 1000;
        ctx.globalAlpha = alpha;
        ctx.fillStyle = particle.color;
        ctx.fillRect(particle.x, particle.y, 3, 3);
        ctx.globalAlpha = 1;
      });
    }
    
    function drawGrid() {
      ctx.strokeStyle = 'rgba(0, 255, 255, 0.2)';
      ctx.lineWidth = 1;
      
      for (let x = 0; x <= canvas.width; x += GRID_SIZE) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, canvas.height);
        ctx.stroke();
      }
      
      for (let y = 0; y <= canvas.height; y += GRID_SIZE) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(canvas.width, y);
        ctx.stroke();
      }
    }
    
    // Input handling
    document.addEventListener('keydown', handleKeyDown);
    
    function handleKeyDown(e) {
      if (gameState === 'playing') {
        switch(e.key) {
          case 'ArrowUp':
          case 'w':
          case 'W':
            if (frog.y > 0) {
              frog.y -= frog.speed;
              createParticles(frog.x + frog.width/2, frog.y + frog.height, 'var(--neon-green)');
            }
            break;
          case 'ArrowDown':
          case 's':
          case 'S':
            if (frog.y < canvas.height - frog.height) {
              frog.y += frog.speed;
              createParticles(frog.x + frog.width/2, frog.y + frog.height, 'var(--neon-green)');
            }
            break;
          case 'ArrowLeft':
          case 'a':
          case 'A':
            if (frog.x > 0) {
              frog.x -= frog.speed;
              createParticles(frog.x + frog.width/2, frog.y + frog.height, 'var(--neon-green)');
            }
            break;
          case 'ArrowRight':
          case 'd':
          case 'D':
            if (frog.x < canvas.width - frog.width) {
              frog.x += frog.speed;
              createParticles(frog.x + frog.width/2, frog.y + frog.height, 'var(--neon-green)');
            }
            break;
          case ' ':
            pauseGame();
            break;
          case 'r':
          case 'R':
            restartGame();
            break;
        }
      } else if (gameState === 'paused') {
        if (e.key === ' ') {
          resumeGame();
        } else if (e.key === 'r' || e.key === 'R') {
          restartGame();
        }
      }
    }
    
    // Game state management
    function startGame() {
      gameState = 'playing';
      document.getElementById('mainMenu').classList.add('hidden');
      initGame();
    }
    
    function pauseGame() {
      gameState = 'paused';
      document.getElementById('pauseScreen').classList.remove('hidden');
    }
    
    function resumeGame() {
      gameState = 'playing';
      document.getElementById('pauseScreen').classList.add('hidden');
    }
    
    function gameOver() {
      gameState = 'gameOver';
      document.getElementById('finalScore').textContent = score;
      document.getElementById('gameOver').classList.remove('hidden');
    }
    
    function restartGame() {
      score = 0;
      lives = 3;
      level = 1;
      gameTime = 0;
      
      updateScore();
      initGame();
      
      document.getElementById('gameOver').classList.add('hidden');
      document.getElementById('pauseScreen').classList.add('hidden');
      document.getElementById('mainMenu').classList.add('hidden');
      
      gameState = 'playing';
    }
    
    function showMainMenu() {
      gameState = 'menu';
      document.getElementById('gameOver').classList.add('hidden');
      document.getElementById('pauseScreen').classList.add('hidden');
      document.getElementById('mainMenu').classList.remove('hidden');
    }
    
    function goHome() {
      window.location.href = '../index.html';
    }
    
    function showControls() {
      const controlsInfo = document.getElementById('controlsInfo');
      controlsInfo.classList.toggle('hidden');
    }
    
    function updateScore() {
      document.getElementById('score').textContent = score;
      document.getElementById('lives').textContent = lives;
      document.getElementById('level').textContent = level;
    }
    
    // Initialize
    function init() {
      resizeCanvas();
      updateScore();
      requestAnimationFrame(gameLoop);
    }
    
    // Start the game
    init();
  </script>
</body>
</html>
