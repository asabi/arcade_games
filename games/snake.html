<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Snake Battle - Multiplayer</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');
    
    :root {
      --bg-dark: #0a0a0a;
      --neon-green: #00ff41;
      --neon-red: #ff0040;
      --neon-blue: #0080ff;
      --neon-yellow: #ffff00;
      --neon-cyan: #00ffff;
      --neon-pink: #ff00ff;
      --text-light: #e6f1ff;
      --text-muted: #8892b0;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    html, body {
      height: 100%;
      background: var(--bg-dark);
      color: var(--text-light);
      font-family: 'Orbitron', monospace;
      overflow: hidden;
      user-select: none;
      -webkit-user-select: none;
      touch-action: none;
    }

    #gameContainer {
      position: fixed;
      inset: 0;
      display: grid;
      place-items: center;
    }

    canvas {
      border: 2px solid var(--neon-cyan);
      border-radius: 8px;
      background: #001122;
      box-shadow: 
        0 0 20px rgba(0, 255, 255, 0.3),
        inset 0 0 20px rgba(0, 255, 255, 0.1);
    }

    .overlay {
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
      background: rgba(0, 0, 0, 0.8);
      backdrop-filter: blur(5px);
    }

    .menu-card {
      background: rgba(20, 20, 30, 0.95);
      border: 2px solid var(--neon-cyan);
      border-radius: 15px;
      padding: 30px;
      text-align: center;
      max-width: 500px;
      width: 90vw;
      box-shadow: 0 0 30px rgba(0, 255, 255, 0.3);
    }

    .title {
      font-size: 2.5rem;
      font-weight: 900;
      margin-bottom: 20px;
      background: linear-gradient(45deg, var(--neon-green), var(--neon-cyan));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      text-shadow: 0 0 20px rgba(0, 255, 65, 0.5);
    }

    .subtitle {
      color: var(--text-muted);
      margin-bottom: 30px;
      font-size: 1.1rem;
    }

    .player-setup {
      display: flex;
      gap: 20px;
      margin-bottom: 30px;
      flex-wrap: wrap;
      justify-content: center;
    }

    .player-option {
      background: linear-gradient(135deg, rgba(0, 255, 65, 0.1), rgba(0, 255, 255, 0.1));
      border: 2px solid transparent;
      border-radius: 10px;
      padding: 15px 20px;
      cursor: pointer;
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
    }

    .player-option.active {
      border-color: var(--neon-green);
      background: linear-gradient(135deg, rgba(0, 255, 65, 0.2), rgba(0, 255, 255, 0.2));
      transform: scale(1.05);
    }

    .player-option:hover {
      transform: translateY(-2px);
      box-shadow: 0 10px 20px rgba(0, 255, 65, 0.2);
    }

    .btn {
      background: linear-gradient(135deg, var(--neon-green), var(--neon-cyan));
      border: none;
      border-radius: 10px;
      padding: 15px 30px;
      color: var(--bg-dark);
      font-family: inherit;
      font-weight: 700;
      font-size: 1.1rem;
      cursor: pointer;
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
      margin: 10px;
    }

    .btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 10px 25px rgba(0, 255, 65, 0.4);
    }

    .btn:active {
      transform: translateY(0);
    }

    .controls-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 15px;
      margin-bottom: 20px;
    }

    .control-group {
      background: rgba(0, 0, 0, 0.3);
      border: 1px solid rgba(0, 255, 255, 0.3);
      border-radius: 8px;
      padding: 15px;
    }

    .control-title {
      color: var(--neon-cyan);
      font-weight: 700;
      margin-bottom: 8px;
    }

    .kbd {
      display: inline-block;
      padding: 3px 8px;
      background: rgba(0, 255, 255, 0.1);
      border: 1px solid rgba(0, 255, 255, 0.3);
      border-radius: 4px;
      font-size: 0.9rem;
      margin: 2px;
    }

    .hud {
      position: absolute;
      top: 20px;
      left: 20px;
      right: 20px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-weight: 700;
      pointer-events: none;
      z-index: 10;
    }

    .score-display {
      background: rgba(0, 0, 0, 0.7);
      border: 1px solid var(--neon-cyan);
      border-radius: 8px;
      padding: 10px 15px;
      backdrop-filter: blur(5px);
    }

    .player-score {
      margin-bottom: 5px;
    }

    .player1 { color: var(--neon-green); }
    .player2 { color: var(--neon-red); }
    .player3 { color: var(--neon-blue); }
    .player4 { color: var(--neon-yellow); }

    .back-btn {
      position: absolute;
      top: 20px;
      right: 20px;
      background: rgba(255, 0, 64, 0.2);
      border: 1px solid var(--neon-red);
      border-radius: 8px;
      padding: 10px 15px;
      color: var(--neon-red);
      font-family: inherit;
      font-weight: 700;
      cursor: pointer;
      transition: all 0.3s ease;
      z-index: 20;
    }

    .back-btn:hover {
      background: rgba(255, 0, 64, 0.3);
      transform: translateY(-2px);
    }

    .power-up-indicator {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.8);
      border: 1px solid var(--neon-yellow);
      border-radius: 8px;
      padding: 10px 20px;
      font-size: 0.9rem;
      color: var(--neon-yellow);
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    .power-up-indicator.show {
      opacity: 1;
    }

    /* Touch controls for mobile */
    .touch-controls {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: none;
      gap: 10px;
    }

    .touch-btn {
      width: 60px;
      height: 60px;
      background: rgba(0, 255, 255, 0.2);
      border: 2px solid var(--neon-cyan);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.5rem;
      color: var(--neon-cyan);
      font-weight: 700;
      cursor: pointer;
      transition: all 0.3s ease;
      user-select: none;
      -webkit-user-select: none;
      touch-action: manipulation;
    }

    .touch-btn:active {
      background: rgba(0, 255, 255, 0.4);
      transform: scale(0.95);
    }

    @media (max-width: 768px) {
      .touch-controls {
        display: flex;
      }
      
      .menu-card {
        padding: 20px;
      }
      
      .title {
        font-size: 2rem;
      }
      
      .player-setup {
        gap: 10px;
      }
      
      .player-option {
        padding: 10px 15px;
      }
    }

    /* Particle effects */
    .particle {
      position: absolute;
      pointer-events: none;
      border-radius: 50%;
      animation: particle-float 1s ease-out forwards;
    }

    @keyframes particle-float {
      0% {
        opacity: 1;
        transform: translate(0, 0) scale(1);
      }
      100% {
        opacity: 0;
        transform: translate(var(--dx), var(--dy)) scale(0);
      }
    }

    .paused-overlay {
      position: absolute;
      inset: 0;
      background: rgba(0, 0, 0, 0.7);
      display: none;
      align-items: center;
      justify-content: center;
      font-size: 2rem;
      font-weight: 900;
      color: var(--neon-cyan);
      text-shadow: 0 0 20px rgba(0, 255, 255, 0.7);
    }
  </style>
</head>
<body>
  <div id="gameContainer">
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    
    <div class="hud" id="hud" style="display: none;">
      <div class="score-display" id="scoreDisplay"></div>
      <div class="score-display">
        <div>üçé <span id="foodCount">0</span></div>
      </div>
    </div>

    <button class="back-btn" onclick="goHome()" title="Back to Main Menu">
      ‚Üê HOME
    </button>

    <div class="power-up-indicator" id="powerUpIndicator"></div>

    <div class="paused-overlay" id="pausedOverlay">
      <div>PAUSED<br><small style="font-size: 1rem;">Press P or Start to resume</small></div>
    </div>

    <div class="touch-controls" id="touchControls">
      <div class="touch-btn" data-dir="up">‚Üë</div>
      <div class="touch-btn" data-dir="left">‚Üê</div>
      <div class="touch-btn" data-dir="right">‚Üí</div>
      <div class="touch-btn" data-dir="down">‚Üì</div>
    </div>

    <!-- Menu overlay -->
    <div class="overlay" id="menuOverlay">
      <div class="menu-card">
        <h1 class="title">SNAKE BATTLE</h1>
        <p class="subtitle">Grow, survive, and dominate the arena</p>
        
        <div class="player-setup">
          <div class="player-option active" data-players="1">
            <div style="font-weight: 700; color: var(--neon-green);">1 PLAYER</div>
            <div style="font-size: 0.9rem; color: var(--text-muted);">Solo Challenge</div>
          </div>
          <div class="player-option" data-players="2">
            <div style="font-weight: 700; color: var(--neon-red);">2 PLAYERS</div>
            <div style="font-size: 0.9rem; color: var(--text-muted);">Head to Head</div>
          </div>
          <div class="player-option" data-players="3">
            <div style="font-weight: 700; color: var(--neon-blue);">3 PLAYERS</div>
            <div style="font-size: 0.9rem; color: var(--text-muted);">Triple Threat</div>
          </div>
          <div class="player-option" data-players="4">
            <div style="font-weight: 700; color: var(--neon-yellow);">4 PLAYERS</div>
            <div style="font-size: 0.9rem; color: var(--text-muted);">Battle Royale</div>
          </div>
        </div>

        <div class="controls-grid">
          <div class="control-group">
            <div class="control-title">Player 1</div>
            <div><span class="kbd">‚Üë</span><span class="kbd">‚Üì</span><span class="kbd">‚Üê</span><span class="kbd">‚Üí</span> or <span class="kbd">WASD</span></div>
          </div>
          <div class="control-group">
            <div class="control-title">Player 2</div>
            <div><span class="kbd">I</span><span class="kbd">K</span><span class="kbd">J</span><span class="kbd">L</span></div>
          </div>
          <div class="control-group">
            <div class="control-title">Player 3 & 4</div>
            <div>üéÆ Gamepad Support</div>
          </div>
          <div class="control-group">
            <div class="control-title">Special</div>
            <div><span class="kbd">P</span> Pause ‚Ä¢ <span class="kbd">F</span> Fullscreen</div>
          </div>
        </div>

        <button class="btn" onclick="startGame()">START BATTLE</button>
      </div>
    </div>

    <!-- Game Over overlay -->
    <div class="overlay hidden" id="gameOverOverlay">
      <div class="menu-card">
        <h1 class="title">GAME OVER</h1>
        <div id="finalStats" style="margin: 20px 0; font-size: 1.2rem;"></div>
        <div style="display: flex; gap: 10px; justify-content: center;">
          <button class="btn" onclick="restartGame()">PLAY AGAIN</button>
          <button class="btn" onclick="showMenu()">MAIN MENU</button>
        </div>
      </div>
    </div>
  </div>

  <script>
    // Game configuration
    const CONFIG = {
      CELL_SIZE: 20,
      GRID_WIDTH: 40,
      GRID_HEIGHT: 30,
      INITIAL_SPEED: 150, // ms between moves
      MIN_SPEED: 80,
      SPEED_INCREMENT: 2,
      COLORS: {
        players: ['#00ff41', '#ff0040', '#0080ff', '#ffff00'],
        food: '#ff6600',
        superFood: '#ff00ff',
        poison: '#8000ff',
        background: '#001122',
        grid: 'rgba(0, 255, 255, 0.1)'
      }
    };

    // Game state
    let gameState = {
      running: false,
      paused: false,
      playerCount: 1,
      players: [],
      food: [],
      powerUps: [],
      score: Array(4).fill(0),
      gameSpeed: CONFIG.INITIAL_SPEED,
      foodEaten: 0,
      lastUpdateTime: 0
    };

    // Input handling
    class InputManager {
      constructor() {
        this.keys = new Set();
        this.gamepads = [];
        this.touchDir = null;
        this.setupEventListeners();
      }

      setupEventListeners() {
        document.addEventListener('keydown', (e) => {
          this.keys.add(e.code);
          if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Space'].includes(e.code)) {
            e.preventDefault();
          }
        });

        document.addEventListener('keyup', (e) => {
          this.keys.delete(e.code);
        });

        // Gamepad support
        window.addEventListener('gamepadconnected', (e) => {
          console.log('Gamepad connected:', e.gamepad.id);
        });

        // Touch controls
        document.querySelectorAll('.touch-btn').forEach(btn => {
          btn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            this.touchDir = btn.dataset.dir;
          });
          
          btn.addEventListener('touchend', (e) => {
            e.preventDefault();
            this.touchDir = null;
          });
        });
      }

      getPlayerInput(playerIndex) {
        const gamepadIndex = playerIndex - 2; // Players 3 & 4 use gamepads
        
        if (gamepadIndex >= 0) {
          const gamepad = navigator.getGamepads()[gamepadIndex];
          if (gamepad) {
            const threshold = 0.5;
            if (gamepad.axes[1] < -threshold) return 'up';
            if (gamepad.axes[1] > threshold) return 'down';
            if (gamepad.axes[0] < -threshold) return 'left';
            if (gamepad.axes[0] > threshold) return 'right';
            
            if (gamepad.buttons[12]?.pressed) return 'up';
            if (gamepad.buttons[13]?.pressed) return 'down';
            if (gamepad.buttons[14]?.pressed) return 'left';
            if (gamepad.buttons[15]?.pressed) return 'right';
          }
          return null;
        }

        // Keyboard controls
        switch (playerIndex) {
          case 0: // Player 1
            if (this.keys.has('ArrowUp') || this.keys.has('KeyW')) return 'up';
            if (this.keys.has('ArrowDown') || this.keys.has('KeyS')) return 'down';
            if (this.keys.has('ArrowLeft') || this.keys.has('KeyA')) return 'left';
            if (this.keys.has('ArrowRight') || this.keys.has('KeyD')) return 'right';
            if (this.touchDir && playerIndex === 0) return this.touchDir; // Touch for player 1 only
            break;
          case 1: // Player 2
            if (this.keys.has('KeyI')) return 'up';
            if (this.keys.has('KeyK')) return 'down';
            if (this.keys.has('KeyJ')) return 'left';
            if (this.keys.has('KeyL')) return 'right';
            break;
        }
        return null;
      }

      isPausePressed() {
        if (this.keys.has('KeyP')) return true;
        
        // Check gamepad start buttons
        const gamepads = navigator.getGamepads();
        for (let i = 0; i < gamepads.length; i++) {
          if (gamepads[i]?.buttons[9]?.pressed) return true; // Start button
        }
        return false;
      }

      isFullscreenPressed() {
        return this.keys.has('KeyF');
      }
    }

    // Audio system
    class AudioManager {
      constructor() {
        this.context = null;
        this.enabled = false;
      }

      async init() {
        try {
          this.context = new (window.AudioContext || window.webkitAudioContext)();
          if (this.context.state === 'suspended') {
            await this.context.resume();
          }
          this.enabled = true;
        } catch (e) {
          console.warn('Audio not available');
        }
      }

      playTone(frequency, duration = 0.1, type = 'square', volume = 0.1) {
        if (!this.enabled || !this.context) return;

        const oscillator = this.context.createOscillator();
        const gainNode = this.context.createGain();

        oscillator.connect(gainNode);
        gainNode.connect(this.context.destination);

        oscillator.frequency.value = frequency;
        oscillator.type = type;
        gainNode.gain.value = volume;

        oscillator.start();
        oscillator.stop(this.context.currentTime + duration);
      }

      playEat() {
        this.playTone(800, 0.1, 'square', 0.15);
      }

      playDeath() {
        this.playTone(200, 0.5, 'sawtooth', 0.2);
      }

      playPowerUp() {
        this.playTone(1200, 0.2, 'sine', 0.15);
        setTimeout(() => this.playTone(1600, 0.2, 'sine', 0.15), 100);
      }

      playMove() {
        this.playTone(400, 0.05, 'square', 0.05);
      }
    }

    // Game entities
    class Snake {
      constructor(x, y, color, playerIndex) {
        this.body = [{ x, y }];
        this.direction = { x: 1, y: 0 };
        this.nextDirection = { x: 1, y: 0 };
        this.color = color;
        this.playerIndex = playerIndex;
        this.alive = true;
        this.score = 0;
        this.powerUpTime = 0;
        this.powerUpType = null;
      }

      update() {
        if (!this.alive) return;

        // Update direction
        this.direction = { ...this.nextDirection };

        // Move head
        const head = { ...this.body[0] };
        head.x += this.direction.x;
        head.y += this.direction.y;

        // Check boundaries
        if (head.x < 0 || head.x >= CONFIG.GRID_WIDTH || 
            head.y < 0 || head.y >= CONFIG.GRID_HEIGHT) {
          this.die();
          return;
        }

        // Check self collision
        if (this.body.some(segment => segment.x === head.x && segment.y === head.y)) {
          this.die();
          return;
        }

        // Check collision with other snakes
        for (let otherSnake of gameState.players) {
          if (otherSnake !== this && otherSnake.alive) {
            if (otherSnake.body.some(segment => segment.x === head.x && segment.y === head.y)) {
              this.die();
              return;
            }
          }
        }

        this.body.unshift(head);

        // Check food collision
        let ateFood = false;
        gameState.food = gameState.food.filter(food => {
          if (food.x === head.x && food.y === head.y) {
            this.score += food.points;
            this.handleFoodEffect(food);
            ateFood = true;
            audio.playEat();
            createFoodParticles(food.x * CONFIG.CELL_SIZE, food.y * CONFIG.CELL_SIZE, food.color);
            return false;
          }
          return true;
        });

        if (!ateFood) {
          this.body.pop(); // Remove tail if no food eaten
        } else {
          gameState.foodEaten++;
          // Increase speed every 5 food items
          if (gameState.foodEaten % 5 === 0) {
            gameState.gameSpeed = Math.max(CONFIG.MIN_SPEED, gameState.gameSpeed - CONFIG.SPEED_INCREMENT);
          }
        }

        // Update power-up timer
        if (this.powerUpTime > 0) {
          this.powerUpTime--;
          if (this.powerUpTime <= 0) {
            this.powerUpType = null;
          }
        }
      }

      handleFoodEffect(food) {
        if (food.type === 'super') {
          this.powerUpType = 'speed';
          this.powerUpTime = 300; // 5 seconds at 60fps
          showPowerUpIndicator('Speed Boost!');
        } else if (food.type === 'poison') {
          // Reverse controls temporarily
          this.powerUpType = 'reverse';
          this.powerUpTime = 180; // 3 seconds
          showPowerUpIndicator('Controls Reversed!');
        }
      }

      setDirection(newDir) {
        // Prevent moving directly backwards
        if (newDir.x !== -this.direction.x || newDir.y !== -this.direction.y) {
          this.nextDirection = newDir;
        }
      }

      die() {
        this.alive = false;
        audio.playDeath();
        
        // Create death particles
        const head = this.body[0];
        createDeathParticles(head.x * CONFIG.CELL_SIZE, head.y * CONFIG.CELL_SIZE, this.color);
      }

      render(ctx) {
        if (!this.alive) return;

        ctx.fillStyle = this.color;
        
        // Draw body
        this.body.forEach((segment, index) => {
          const x = segment.x * CONFIG.CELL_SIZE;
          const y = segment.y * CONFIG.CELL_SIZE;
          
          if (index === 0) {
            // Head - make it slightly larger and add glow
            ctx.shadowColor = this.color;
            ctx.shadowBlur = 10;
            ctx.fillRect(x + 1, y + 1, CONFIG.CELL_SIZE - 2, CONFIG.CELL_SIZE - 2);
            ctx.shadowBlur = 0;
            
            // Add eyes
            ctx.fillStyle = '#000';
            ctx.fillRect(x + 4, y + 4, 3, 3);
            ctx.fillRect(x + 13, y + 4, 3, 3);
            ctx.fillStyle = this.color;
          } else {
            // Body segments with slight transparency gradient
            const alpha = Math.max(0.3, 1 - (index * 0.02));
            ctx.globalAlpha = alpha;
            ctx.fillRect(x + 2, y + 2, CONFIG.CELL_SIZE - 4, CONFIG.CELL_SIZE - 4);
            ctx.globalAlpha = 1;
          }
        });
      }
    }

    class Food {
      constructor(x, y, type = 'normal') {
        this.x = x;
        this.y = y;
        this.type = type;
        this.animationOffset = Math.random() * Math.PI * 2;
        
        switch (type) {
          case 'super':
            this.color = CONFIG.COLORS.superFood;
            this.points = 5;
            break;
          case 'poison':
            this.color = CONFIG.COLORS.poison;
            this.points = 1;
            break;
          default:
            this.color = CONFIG.COLORS.food;
            this.points = 1;
        }
      }

      render(ctx) {
        const x = this.x * CONFIG.CELL_SIZE;
        const y = this.y * CONFIG.CELL_SIZE;
        const centerX = x + CONFIG.CELL_SIZE / 2;
        const centerY = y + CONFIG.CELL_SIZE / 2;
        
        // Animated pulsing effect
        const time = Date.now() * 0.005 + this.animationOffset;
        const scale = 0.8 + Math.sin(time) * 0.2;
        const size = CONFIG.CELL_SIZE * 0.6 * scale;
        
        ctx.fillStyle = this.color;
        ctx.shadowColor = this.color;
        ctx.shadowBlur = 15;
        
        if (this.type === 'super') {
          // Star shape for super food
          drawStar(ctx, centerX, centerY, size / 2, 5);
        } else if (this.type === 'poison') {
          // Skull shape for poison
          ctx.fillRect(centerX - size/2, centerY - size/2, size, size);
        } else {
          // Circle for normal food
          ctx.beginPath();
          ctx.arc(centerX, centerY, size / 2, 0, Math.PI * 2);
          ctx.fill();
        }
        
        ctx.shadowBlur = 0;
      }
    }

    // Initialize game systems
    const input = new InputManager();
    const audio = new AudioManager();

    // Canvas setup
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    ctx.imageSmoothingEnabled = false;

    // Particle system
    function createFoodParticles(x, y, color) {
      const particleCount = 8;
      for (let i = 0; i < particleCount; i++) {
        createParticle(x + CONFIG.CELL_SIZE/2, y + CONFIG.CELL_SIZE/2, color);
      }
    }

    function createDeathParticles(x, y, color) {
      const particleCount = 15;
      for (let i = 0; i < particleCount; i++) {
        createParticle(x + CONFIG.CELL_SIZE/2, y + CONFIG.CELL_SIZE/2, color, true);
      }
    }

    function createParticle(x, y, color, isDeath = false) {
      const particle = document.createElement('div');
      particle.className = 'particle';
      particle.style.left = x + 'px';
      particle.style.top = y + 'px';
      particle.style.background = color;
      particle.style.width = (isDeath ? 8 : 4) + 'px';
      particle.style.height = (isDeath ? 8 : 4) + 'px';
      
      const angle = Math.random() * Math.PI * 2;
      const distance = (isDeath ? 80 : 40) + Math.random() * 40;
      const dx = Math.cos(angle) * distance;
      const dy = Math.sin(angle) * distance;
      
      particle.style.setProperty('--dx', dx + 'px');
      particle.style.setProperty('--dy', dy + 'px');
      
      document.getElementById('gameContainer').appendChild(particle);
      
      setTimeout(() => {
        if (particle.parentNode) {
          particle.parentNode.removeChild(particle);
        }
      }, 1000);
    }

    function drawStar(ctx, cx, cy, radius, points) {
      const angle = Math.PI / points;
      ctx.beginPath();
      for (let i = 0; i < 2 * points; i++) {
        const r = i % 2 === 0 ? radius : radius * 0.5;
        const x = cx + Math.cos(i * angle - Math.PI / 2) * r;
        const y = cy + Math.sin(i * angle - Math.PI / 2) * r;
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.closePath();
      ctx.fill();
    }

    // Game functions
    function initializeGame() {
      gameState.players = [];
      gameState.food = [];
      gameState.score = Array(4).fill(0);
      gameState.gameSpeed = CONFIG.INITIAL_SPEED;
      gameState.foodEaten = 0;

      // Create players
      const startPositions = [
        { x: 5, y: 15 },
        { x: 35, y: 15 },
        { x: 15, y: 5 },
        { x: 25, y: 25 }
      ];

      for (let i = 0; i < gameState.playerCount; i++) {
        const pos = startPositions[i];
        const snake = new Snake(pos.x, pos.y, CONFIG.COLORS.players[i], i);
        gameState.players.push(snake);
      }

      spawnFood();
    }

    function spawnFood() {
      // Clear existing food
      gameState.food = [];
      
      // Spawn regular food
      for (let i = 0; i < 3; i++) {
        spawnSingleFood('normal');
      }
      
      // 20% chance for super food
      if (Math.random() < 0.2) {
        spawnSingleFood('super');
      }
      
      // 10% chance for poison
      if (Math.random() < 0.1) {
        spawnSingleFood('poison');
      }
    }

    function spawnSingleFood(type = 'normal') {
      let x, y;
      let attempts = 0;
      
      do {
        x = Math.floor(Math.random() * CONFIG.GRID_WIDTH);
        y = Math.floor(Math.random() * CONFIG.GRID_HEIGHT);
        attempts++;
      } while (attempts < 50 && isPositionOccupied(x, y));
      
      if (attempts < 50) {
        gameState.food.push(new Food(x, y, type));
      }
    }

    function isPositionOccupied(x, y) {
      // Check if position is occupied by any snake
      for (let snake of gameState.players) {
        if (snake.alive && snake.body.some(segment => segment.x === x && segment.y === y)) {
          return true;
        }
      }
      
      // Check if position is occupied by existing food
      return gameState.food.some(food => food.x === x && food.y === y);
    }

    function updateGame() {
      if (!gameState.running || gameState.paused) return;

      // Update players
      gameState.players.forEach(player => player.update());

      // Check if all players are dead or only one remains
      const alivePlayers = gameState.players.filter(p => p.alive);
      if (alivePlayers.length <= (gameState.playerCount > 1 ? 1 : 0)) {
        endGame();
        return;
      }

      // Spawn new food if needed
      if (gameState.food.length < 3) {
        spawnFood();
      }

      // Update score display
      updateScoreDisplay();
    }

    function handleInput() {
      if (!gameState.running) return;

      // Check pause
      if (input.isPausePressed() && !gameState.pausePressed) {
        gameState.paused = !gameState.paused;
        document.getElementById('pausedOverlay').style.display = gameState.paused ? 'flex' : 'none';
        gameState.pausePressed = true;
      } else if (!input.isPausePressed()) {
        gameState.pausePressed = false;
      }

      // Check fullscreen
      if (input.isFullscreenPressed() && !gameState.fullscreenPressed) {
        toggleFullscreen();
        gameState.fullscreenPressed = true;
      } else if (!input.isFullscreenPressed()) {
        gameState.fullscreenPressed = false;
      }

      if (gameState.paused) return;

      // Handle player input
      gameState.players.forEach((player, index) => {
        if (!player.alive) return;

        const inputDir = input.getPlayerInput(index);
        if (inputDir) {
          let direction;
          
          // Handle reverse controls power-up
          const isReversed = player.powerUpType === 'reverse';
          
          switch (inputDir) {
            case 'up': direction = { x: 0, y: isReversed ? 1 : -1 }; break;
            case 'down': direction = { x: 0, y: isReversed ? -1 : 1 }; break;
            case 'left': direction = { x: isReversed ? 1 : -1, y: 0 }; break;
            case 'right': direction = { x: isReversed ? -1 : 1, y: 0 }; break;
          }
          
          if (direction) {
            player.setDirection(direction);
          }
        }
      });
    }

    function render() {
      // Clear canvas
      ctx.fillStyle = CONFIG.COLORS.background;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Draw grid
      ctx.strokeStyle = CONFIG.COLORS.grid;
      ctx.lineWidth = 1;
      for (let x = 0; x <= canvas.width; x += CONFIG.CELL_SIZE) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, canvas.height);
        ctx.stroke();
      }
      for (let y = 0; y <= canvas.height; y += CONFIG.CELL_SIZE) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(canvas.width, y);
        ctx.stroke();
      }

      // Draw food
      gameState.food.forEach(food => food.render(ctx));

      // Draw players
      gameState.players.forEach(player => player.render(ctx));
    }

    function updateScoreDisplay() {
      const scoreDisplay = document.getElementById('scoreDisplay');
      let html = '';
      
      gameState.players.forEach((player, index) => {
        const status = player.alive ? '‚óè' : 'üíÄ';
        const powerUp = player.powerUpType ? ` ‚ö°${player.powerUpType}` : '';
        html += `<div class="player-score player${index + 1}">P${index + 1}: ${player.score} ${status}${powerUp}</div>`;
      });
      
      scoreDisplay.innerHTML = html;
      document.getElementById('foodCount').textContent = gameState.foodEaten;
    }

    function showPowerUpIndicator(text) {
      const indicator = document.getElementById('powerUpIndicator');
      indicator.textContent = text;
      indicator.classList.add('show');
      setTimeout(() => {
        indicator.classList.remove('show');
      }, 2000);
    }

    // Game loop
    let lastTime = 0;
    function gameLoop(currentTime) {
      if (currentTime - lastTime >= gameState.gameSpeed) {
        handleInput();
        updateGame();
        lastTime = currentTime;
      }
      
      render();
      requestAnimationFrame(gameLoop);
    }

    // UI functions
    function showMenu() {
      gameState.running = false;
      document.getElementById('menuOverlay').classList.remove('hidden');
      document.getElementById('gameOverOverlay').classList.add('hidden');
      document.getElementById('hud').style.display = 'none';
    }

    function startGame() {
      audio.init();
      gameState.running = true;
      gameState.paused = false;
      document.getElementById('menuOverlay').classList.add('hidden');
      document.getElementById('gameOverOverlay').classList.add('hidden');
      document.getElementById('pausedOverlay').style.display = 'none';
      document.getElementById('hud').style.display = 'flex';
      
      initializeGame();
      requestAnimationFrame(gameLoop);
    }

    function restartGame() {
      startGame();
    }

    function endGame() {
      gameState.running = false;
      
      // Calculate final stats
      const alivePlayers = gameState.players.filter(p => p.alive);
      const winnerIndex = alivePlayers.length > 0 ? alivePlayers[0].playerIndex : -1;
      
      let statsHtml = '';
      if (winnerIndex >= 0) {
        statsHtml += `<div style="color: ${CONFIG.COLORS.players[winnerIndex]}; font-size: 1.5rem; margin-bottom: 10px;">Player ${winnerIndex + 1} Wins!</div>`;
      }
      
      statsHtml += '<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 10px;">';
      gameState.players.forEach((player, index) => {
        const status = player.alive ? 'WINNER' : 'DEFEATED';
        statsHtml += `
          <div style="padding: 10px; border: 1px solid ${CONFIG.COLORS.players[index]}; border-radius: 8px;">
            <div style="color: ${CONFIG.COLORS.players[index]}; font-weight: 700;">Player ${index + 1}</div>
            <div>Score: ${player.score}</div>
            <div>Length: ${player.body.length}</div>
            <div style="font-size: 0.9rem; opacity: 0.8;">${status}</div>
          </div>
        `;
      });
      statsHtml += '</div>';
      
      document.getElementById('finalStats').innerHTML = statsHtml;
      document.getElementById('gameOverOverlay').classList.remove('hidden');
    }

    function goHome() {
      window.location.href = '../index.html';
    }

    async function toggleFullscreen() {
      try {
        if (!document.fullscreenElement) {
          await canvas.requestFullscreen();
        } else {
          await document.exitFullscreen();
        }
      } catch (e) {
        console.warn('Fullscreen not supported');
      }
    }

    // Player selection
    document.querySelectorAll('.player-option').forEach(option => {
      option.addEventListener('click', () => {
        document.querySelectorAll('.player-option').forEach(opt => opt.classList.remove('active'));
        option.classList.add('active');
        gameState.playerCount = parseInt(option.dataset.players);
      });
    });

    // Initialize
    showMenu();
    
    // Handle visibility change to pause game
    document.addEventListener('visibilitychange', () => {
      if (document.hidden && gameState.running && !gameState.paused) {
        gameState.paused = true;
        document.getElementById('pausedOverlay').style.display = 'flex';
      }
    });
  </script>
</body>
</html>
