<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Scorched Earth - Artillery Combat</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');
    
    :root {
      --bg-dark: #0a0a0a;
      --terrain-green: #228b22;
      --terrain-brown: #8b4513;
      --tank-green: #32cd32;
      --tank-red: #ff4444;
      --explosion-orange: #ff6600;
      --explosion-yellow: #ffff00;
      --bullet-yellow: #ffd700;
      --text-light: #ffffff;
      --neon-cyan: #00ffff;
      --neon-green: #00ff41;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    html, body {
      height: 100%;
      background: var(--bg-dark);
      color: var(--text-light);
      font-family: 'Orbitron', monospace;
      overflow: hidden;
      user-select: none;
      -webkit-user-select: none;
      touch-action: none;
    }

    #gameContainer {
      position: fixed;
      inset: 0;
      display: grid;
      place-items: center;
      background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 50%, #16213e 100%);
    }

    canvas {
      border: 3px solid var(--neon-cyan);
      border-radius: 10px;
      background: linear-gradient(180deg, #87ceeb 0%, #228b22 70%, #8b4513 100%);
      box-shadow: 
        0 0 30px rgba(0, 255, 255, 0.4),
        inset 0 0 20px rgba(0, 255, 255, 0.1);
    }

    .overlay {
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
      background: rgba(10, 10, 10, 0.9);
      backdrop-filter: blur(8px);
    }

    .menu-card {
      background: linear-gradient(135deg, rgba(0, 255, 255, 0.1), rgba(0, 255, 65, 0.1));
      border: 3px solid var(--neon-cyan);
      border-radius: 20px;
      padding: 40px;
      text-align: center;
      max-width: 650px;
      width: 90vw;
      max-height: 90vh;
      overflow-y: auto;
      box-shadow: 
        0 0 40px rgba(0, 255, 255, 0.4),
        inset 0 0 20px rgba(0, 255, 255, 0.1);
    }

    .title {
      font-size: 3.5rem;
      font-weight: 900;
      margin-bottom: 20px;
      background: linear-gradient(45deg, var(--tank-green), var(--tank-red), var(--explosion-orange));
      background-size: 300% 300%;
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      animation: gradient-shift 2s ease-in-out infinite;
      text-shadow: 0 0 30px rgba(255, 68, 68, 0.6);
    }

    @keyframes gradient-shift {
      0%, 100% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
    }

    .subtitle {
      color: var(--text-light);
      margin-bottom: 30px;
      font-size: 1.3rem;
      opacity: 0.9;
    }

    .game-options {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 20px;
      margin-bottom: 30px;
    }

    .option-card {
      background: linear-gradient(135deg, rgba(50, 205, 50, 0.1), rgba(255, 68, 68, 0.1));
      border: 2px solid transparent;
      border-radius: 15px;
      padding: 20px;
      cursor: pointer;
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
    }

    .option-card.active {
      border-color: var(--neon-green);
      background: linear-gradient(135deg, rgba(50, 205, 50, 0.2), rgba(255, 68, 68, 0.2));
      transform: scale(1.05);
      box-shadow: 0 0 25px rgba(0, 255, 65, 0.4);
    }

    .option-card:hover {
      transform: translateY(-3px);
      box-shadow: 0 10px 25px rgba(0, 255, 255, 0.3);
    }

    .option-title {
      font-weight: 700;
      font-size: 1.2rem;
      margin-bottom: 8px;
      color: var(--neon-green);
    }

    .option-desc {
      font-size: 0.9rem;
      opacity: 0.8;
      line-height: 1.3;
    }

    .btn {
      background: linear-gradient(135deg, var(--neon-green), var(--neon-cyan));
      border: none;
      border-radius: 12px;
      padding: 15px 30px;
      color: var(--bg-dark);
      font-family: inherit;
      font-weight: 700;
      font-size: 1.2rem;
      cursor: pointer;
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
      margin: 10px;
      text-transform: uppercase;
    }

    .btn:hover {
      transform: translateY(-3px) scale(1.05);
      box-shadow: 0 15px 30px rgba(0, 255, 65, 0.4);
    }

    .controls-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 15px;
      margin-bottom: 25px;
    }

    .control-section {
      background: rgba(0, 0, 0, 0.4);
      border: 1px solid rgba(0, 255, 255, 0.3);
      border-radius: 10px;
      padding: 15px;
    }

    .control-title {
      color: var(--neon-cyan);
      font-weight: 700;
      margin-bottom: 10px;
      font-size: 1.1rem;
    }

    .kbd {
      display: inline-block;
      padding: 4px 8px;
      background: rgba(0, 255, 255, 0.2);
      border: 1px solid rgba(0, 255, 255, 0.4);
      border-radius: 5px;
      font-size: 0.9rem;
      margin: 2px;
      font-weight: 600;
    }

    .hud {
      position: absolute;
      top: 20px;
      left: 20px;
      right: 20px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-weight: 700;
      pointer-events: none;
      z-index: 10;
    }

    .player-panel {
      background: rgba(10, 10, 10, 0.8);
      border: 2px solid var(--neon-cyan);
      border-radius: 10px;
      padding: 15px 20px;
      backdrop-filter: blur(5px);
      min-width: 200px;
    }

    .player-stats {
      display: flex;
      align-items: center;
      gap: 15px;
      margin-bottom: 8px;
    }

    .tank-icon {
      width: 24px;
      height: 16px;
      border-radius: 3px;
      position: relative;
    }

    .tank-icon::after {
      content: '';
      position: absolute;
      top: 6px;
      right: -8px;
      width: 12px;
      height: 4px;
      background: currentColor;
      border-radius: 2px;
    }

    .player1-color { background: var(--tank-green); color: var(--tank-green); }
    .player2-color { background: var(--tank-red); color: var(--tank-red); }

    .health-bar {
      width: 100%;
      height: 8px;
      background: rgba(255, 255, 255, 0.2);
      border-radius: 4px;
      overflow: hidden;
      margin-top: 5px;
    }

    .health-fill {
      height: 100%;
      background: linear-gradient(90deg, #ff0000, #ffff00, #00ff00);
      transition: width 0.3s ease;
      border-radius: 4px;
    }

    .game-info {
      background: rgba(10, 10, 10, 0.8);
      border: 2px solid var(--neon-cyan);
      border-radius: 10px;
      padding: 15px 20px;
      backdrop-filter: blur(5px);
      text-align: center;
    }

    .back-btn {
      position: fixed;
      bottom: 20px;
      left: 20px;
      background: rgba(255, 0, 64, 0.2);
      border: 2px solid #ff0040;
      border-radius: 15px;
      padding: 15px 22px;
      color: #ff0040;
      font-family: inherit;
      font-weight: 700;
      cursor: pointer;
      transition: all 0.3s ease;
      z-index: 10;
      width: auto;
      height: auto;
      pointer-events: auto;
    }

    .back-btn:hover {
      background: rgba(255, 0, 64, 0.3);
      box-shadow: 0 0 20px rgba(255, 0, 64, 0.5);
      transform: scale(1.05);
    }

    @media (max-width: 768px) {
      .back-btn {
        padding: 12px 18px;
        font-size: 0.9rem;
        bottom: 15px;
        left: 15px;
      }
    }

    @media (max-width: 480px) {
      .back-btn {
        padding: 10px 15px;
        font-size: 0.8rem;
        bottom: 10px;
        left: 10px;
      }
    }

    .paused-overlay {
      position: absolute;
      inset: 0;
      background: rgba(10, 10, 10, 0.8);
      display: none;
      align-items: center;
      justify-content: center;
      font-size: 2.5rem;
      font-weight: 900;
      color: var(--neon-green);
      text-shadow: 0 0 30px rgba(0, 255, 65, 0.8);
      backdrop-filter: blur(5px);
    }

    .crosshair {
      position: absolute;
      width: 20px;
      height: 20px;
      border: 2px solid var(--bullet-yellow);
      border-radius: 50%;
      pointer-events: none;
      opacity: 0.8;
      z-index: 5;
      transform: translate(-50%, -50%);
    }

    .crosshair::before,
    .crosshair::after {
      content: '';
      position: absolute;
      background: var(--bullet-yellow);
    }

    .crosshair::before {
      width: 2px;
      height: 12px;
      top: 2px;
      left: 50%;
      transform: translateX(-50%);
    }

    .crosshair::after {
      width: 12px;
      height: 2px;
      top: 50%;
      left: 2px;
      transform: translateY(-50%);
    }

    .touch-controls {
      position: absolute;
      bottom: 30px;
      left: 20px;
      right: 20px;
      display: none;
      justify-content: space-between;
      align-items: center;
    }

    .movement-pad {
      display: grid;
      grid-template-columns: repeat(3, 50px);
      grid-template-rows: repeat(3, 50px);
      gap: 5px;
    }

    .action-controls {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .touch-btn {
      background: rgba(0, 255, 255, 0.3);
      border: 2px solid var(--neon-cyan);
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.2rem;
      color: var(--neon-cyan);
      font-weight: 700;
      cursor: pointer;
      transition: all 0.2s ease;
      user-select: none;
      -webkit-user-select: none;
      touch-action: manipulation;
    }

    .touch-btn:active {
      background: rgba(0, 255, 255, 0.5);
      transform: scale(0.95);
    }

    .move-up { grid-column: 2; grid-row: 1; }
    .move-left { grid-column: 1; grid-row: 2; }
    .move-right { grid-column: 3; grid-row: 2; }
    .move-down { grid-column: 2; grid-row: 3; }

    .fire-btn {
      width: 70px;
      height: 70px;
      border-radius: 50%;
      background: rgba(255, 215, 0, 0.3);
      border: 3px solid var(--bullet-yellow);
      color: var(--bullet-yellow);
      font-size: 1.5rem;
    }

    @media (max-width: 768px) {
      .touch-controls {
        display: flex;
      }
      
      .menu-card {
        padding: 20px;
        margin: 10px;
      }
      
      .title {
        font-size: 2.2rem;
        margin-bottom: 15px;
      }
      
      .subtitle {
        font-size: 1.1rem;
        margin-bottom: 20px;
      }
      
      .game-options {
        grid-template-columns: 1fr;
        gap: 12px;
      }
      
      .option-card {
        padding: 15px;
      }
      
      .option-title {
        font-size: 1.1rem;
      }
      
      .option-desc {
        font-size: 0.85rem;
      }
      
      .btn {
        padding: 12px 24px;
        font-size: 1.1rem;
        margin: 8px;
      }
      
      .control-section {
        padding: 12px;
      }
      
      .control-title {
        font-size: 1rem;
      }
      
      .controls-grid {
        grid-template-columns: 1fr;
      }
    }

    @media (max-width: 480px) {
      .menu-card {
        padding: 15px;
        margin: 5px;
        border-radius: 15px;
      }
      
      .title {
        font-size: 1.8rem;
        margin-bottom: 10px;
      }
      
      .subtitle {
        font-size: 1rem;
        margin-bottom: 15px;
      }
      
      .game-options {
        gap: 10px;
      }
      
      .option-card {
        padding: 12px;
        border-radius: 10px;
      }
      
      .option-title {
        font-size: 1rem;
        margin-bottom: 6px;
      }
      
      .option-desc {
        font-size: 0.8rem;
      }
      
      .btn {
        padding: 10px 20px;
        font-size: 1rem;
        margin: 6px;
        border-radius: 10px;
      }
      
      .control-section {
        padding: 10px;
        border-radius: 8px;
      }
      
      .control-title {
        font-size: 0.95rem;
        margin-bottom: 8px;
      }
      
      .kbd {
        padding: 3px 6px;
        font-size: 0.8rem;
      }
    }

    /* Animation effects */
    .muzzle-flash {
      position: absolute;
      width: 30px;
      height: 30px;
      background: radial-gradient(circle, var(--explosion-yellow), var(--explosion-orange));
      border-radius: 50%;
      pointer-events: none;
      animation: muzzle-flash 0.1s ease-out;
    }

    @keyframes muzzle-flash {
      0% { transform: scale(0); opacity: 1; }
      100% { transform: scale(1); opacity: 0; }
    }

    .explosion {
      position: absolute;
      pointer-events: none;
      animation: explosion 0.5s ease-out forwards;
    }

    @keyframes explosion {
      0% { transform: scale(0); opacity: 1; }
      50% { transform: scale(1.2); opacity: 0.8; }
      100% { transform: scale(1.5); opacity: 0; }
    }

    .hidden {
      display: none !important;
    }
  </style>
</head>
<body>
  <div id="gameContainer">
    <canvas id="gameCanvas" width="1000" height="700"></canvas>
    
    <div class="hud" id="hud" style="display: none;">
      <div class="player-panel">
        <div class="player-stats">
          <div class="tank-icon player1-color"></div>
          <span>Player 1</span>
        </div>
        <div>Health: <span id="player1Health">100</span>%</div>
        <div class="health-bar">
          <div class="health-fill player1-color" id="player1HealthBar" style="width: 100%;"></div>
        </div>
        <div style="margin-top: 8px;">Kills: <span id="player1Kills">0</span></div>
      </div>
      
      <div class="game-info">
        <div style="font-size: 1.3rem; margin-bottom: 5px;">TANK COMBAT</div>
        <div>Round: <span id="roundDisplay">1</span></div>
        <div>Time: <span id="timeDisplay">0:00</span></div>
      </div>
      
      <div class="player-panel" id="player2Panel" style="display: none;">
        <div class="player-stats">
          <div class="tank-icon player2-color"></div>
          <span>Player 2</span>
        </div>
        <div>Health: <span id="player2Health">100</span>%</div>
        <div class="health-bar">
          <div class="health-fill player2-color" id="player2HealthBar" style="width: 100%;"></div>
        </div>
        <div style="margin-top: 8px;">Kills: <span id="player2Kills">0</span></div>
      </div>
    </div>

    <button class="back-btn" onclick="goHome()" title="Back to Main Menu">
      ‚Üê HOME
    </button>

    <div class="paused-overlay" id="pausedOverlay">
      <div>PAUSED<br><small style="font-size: 1rem;">Press P or Start to resume</small></div>
    </div>

    <div class="touch-controls" id="touchControls">
      <div class="movement-pad">
        <div class="touch-btn move-up" data-action="move-up">‚Üë</div>
        <div class="touch-btn move-left" data-action="move-left">‚Üê</div>
        <div class="touch-btn move-right" data-action="move-right">‚Üí</div>
        <div class="touch-btn move-down" data-action="move-down">‚Üì</div>
      </div>
      
      <div class="action-controls">
        <div class="touch-btn fire-btn" data-action="fire">üî•</div>
      </div>
    </div>

    <!-- Menu overlay -->
    <div class="overlay" id="menuOverlay">
      <div class="menu-card">
        <h1 class="title">SCORCHED EARTH</h1>
        <p class="subtitle">Turn-based artillery warfare with destructible terrain!</p>
        
        <div class="game-options">
          <div class="option-card active" data-mode="single">
            <div class="option-title">üéØ SINGLE PLAYER</div>
            <div class="option-desc">Artillery vs AI<br>Classic Scorched Earth gameplay</div>
          </div>
          <div class="option-card" data-mode="versus">
            <div class="option-title">‚öîÔ∏è VERSUS</div>
            <div class="option-desc">Player vs Player<br>Turn-based artillery duel</div>
          </div>
          <div class="option-card" data-mode="survival">
            <div class="option-title">üõ°Ô∏è SURVIVAL</div>
            <div class="option-desc">Waves of enemy artillery<br>Survive the bombardment!</div>
          </div>
        </div>

        <div class="controls-grid">
          <div class="control-section">
            <div class="control-title">Artillery Controls</div>
            <div>
              <span class="kbd">‚Üê</span><span class="kbd">‚Üí</span> Adjust Angle<br>
              <span class="kbd">‚Üë</span><span class="kbd">‚Üì</span> Adjust Power
            </div>
            <div style="margin-top: 5px;">
              Fire: <span class="kbd">Space</span> or <span class="kbd">Enter</span>
            </div>
          </div>
          <div class="control-section">
            <div class="control-title">Turn-Based System</div>
            <div>
              Players take turns<br>
              One shot per turn
            </div>
          </div>
          <div class="control-section">
            <div class="control-title">Game Controls</div>
            <div>
              <span class="kbd">P</span> Pause ‚Ä¢ <span class="kbd">F</span> Fullscreen<br>
              <span class="kbd">R</span> Restart Battle
            </div>
          </div>
        </div>

        <button class="btn" id="startGameBtn">START ARTILLERY</button>
      </div>
    </div>

    <!-- Game Over overlay -->
    <div class="overlay hidden" id="gameOverOverlay">
      <div class="menu-card">
        <h1 class="title">BATTLE COMPLETE</h1>
        <div id="finalStats" style="margin: 25px 0; font-size: 1.3rem;"></div>
        <div style="display: flex; gap: 15px; justify-content: center; flex-wrap: wrap;">
          <button class="btn" id="restartGameBtn">ARTILLERY AGAIN</button>
          <button class="btn" id="showMenuBtn">MAIN MENU</button>
        </div>
      </div>
    </div>
  </div>

  <script>
    // Game configuration
    const CONFIG = {
      CANVAS_WIDTH: 1000,
      CANVAS_HEIGHT: 700,
      TERRAIN_HEIGHT: 100,
      TANK_SIZE: 20,
      TANK_SPEED: 3.5,
      BULLET_SPEED: 16,
      BULLET_SIZE: 4,
      EXPLOSION_SIZE: 40,
      GRAVITY: 0.2,
      TERRAIN_DESTRUCTION_RADIUS: 25,
      MAX_HEALTH: 100,
      DAMAGE_PER_HIT: 25,
      COLORS: {
        sky: '#87CEEB',
        terrain: '#228B22',
        terrainBorder: '#8B4513',
        player1: '#32CD32',
        player2: '#FF4444',
        bullet: '#FFD700',
        explosion: '#FF6600',
        ai: '#8A2BE2'
      }
    };

    // Game state
    let gameState = {
      running: false,
      paused: false,
      mode: 'single', // single, versus, survival
      round: 1,
      gameTime: 0,
      currentPlayer: 0, // Index of current player's turn
      turnPhase: 'aiming', // 'aiming', 'firing', 'waiting'
      wind: 0, // Wind speed (-5 to 5)
      terrain: [],
      players: [],
      bullets: [],
      explosions: [],
      particles: [],
      aiTanks: [],
      gameSpeed: 16, // 60fps
      lastUpdateTime: 0,
      pausePressed: false,
      fullscreenPressed: false,
      restartPressed: false
    };

    // Input handling
    class InputManager {
      constructor() {
        this.keys = new Set();
        this.touchActions = new Set();
        this.setupEventListeners();
      }

      setupEventListeners() {
        document.addEventListener('keydown', (e) => {
          this.keys.add(e.code);
          if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Space'].includes(e.code)) {
            e.preventDefault();
          }
        });

        document.addEventListener('keyup', (e) => {
          this.keys.delete(e.code);
        });

        // Touch controls
        document.querySelectorAll('.touch-btn').forEach(btn => {
          const action = btn.dataset.action;
          if (action) {
            btn.addEventListener('touchstart', (e) => {
              e.preventDefault();
              this.touchActions.add(action);
            });
            
            btn.addEventListener('touchend', (e) => {
              e.preventDefault();
              this.touchActions.delete(action);
            });
          }
        });
      }

      getPlayerInput(playerIndex) {
        const input = { left: false, right: false, up: false, down: false, fire: false };
        
        if (playerIndex === 0) {
          // Player 1 - Arrow keys, WASD, and touch
          input.left = this.keys.has('ArrowLeft') || this.keys.has('KeyA') || this.touchActions.has('move-left');
          input.right = this.keys.has('ArrowRight') || this.keys.has('KeyD') || this.touchActions.has('move-right');
          input.up = this.keys.has('ArrowUp') || this.keys.has('KeyW') || this.touchActions.has('move-up');
          input.down = this.keys.has('ArrowDown') || this.keys.has('KeyS') || this.touchActions.has('move-down');
          input.fire = this.keys.has('Space') || this.keys.has('Enter') || this.touchActions.has('fire');
        } else if (playerIndex === 1) {
          // Player 2 - IJKL and gamepad
          input.left = this.keys.has('KeyJ');
          input.right = this.keys.has('KeyL');
          input.up = this.keys.has('KeyI');
          input.down = this.keys.has('KeyK');
          input.fire = this.keys.has('KeyU');
          
          // Gamepad support
          const gamepad = navigator.getGamepads()[0];
          if (gamepad) {
            const threshold = 0.5;
            if (gamepad.axes[0] < -threshold || gamepad.buttons[14]?.pressed) input.left = true;
            if (gamepad.axes[0] > threshold || gamepad.buttons[15]?.pressed) input.right = true;
            if (gamepad.axes[1] < -threshold || gamepad.buttons[12]?.pressed) input.up = true;
            if (gamepad.axes[1] > threshold || gamepad.buttons[13]?.pressed) input.down = true;
            if (gamepad.buttons[0]?.pressed || gamepad.buttons[1]?.pressed) input.fire = true;
          }
        }
        
        return input;
      }

      isPausePressed() {
        if (this.keys.has('KeyP')) return true;
        const gamepad = navigator.getGamepads()[0];
        return gamepad?.buttons[9]?.pressed;
      }

      isFullscreenPressed() {
        return this.keys.has('KeyF');
      }

      isRestartPressed() {
        return this.keys.has('KeyR');
      }
    }

    // Audio system
    class AudioManager {
      constructor() {
        this.context = null;
        this.enabled = false;
      }

      async init() {
        try {
          this.context = new (window.AudioContext || window.webkitAudioContext)();
          if (this.context.state === 'suspended') {
            await this.context.resume();
          }
          this.enabled = true;
        } catch (e) {
          console.warn('Audio not available');
        }
      }

      playTone(frequency, duration = 0.1, type = 'square', volume = 0.1) {
        if (!this.enabled || !this.context) return;

        const oscillator = this.context.createOscillator();
        const gainNode = this.context.createGain();

        oscillator.connect(gainNode);
        gainNode.connect(this.context.destination);

        oscillator.frequency.value = frequency;
        oscillator.type = type;
        gainNode.gain.value = volume;

        oscillator.start();
        oscillator.stop(this.context.currentTime + duration);
      }

      playFire() {
        this.playTone(1200, 0.1, 'square', 0.15);
        setTimeout(() => this.playTone(800, 0.05, 'square', 0.1), 50);
      }

      playExplosion() {
        this.playTone(200, 0.3, 'sawtooth', 0.2);
        setTimeout(() => this.playTone(150, 0.2, 'sawtooth', 0.15), 100);
      }

      playHit() {
        this.playTone(600, 0.2, 'triangle', 0.12);
      }

      playEngine() {
        this.playTone(100, 0.1, 'sawtooth', 0.05);
      }
    }

    // Game entities
    class Tank {
      constructor(x, y, color, isPlayer = true, playerIndex = 0, dropping = false) {
        this.x = x;
        this.y = y;
        this.vx = 0; // Add velocity for physics
        this.vy = 0;
        this.color = color;
        this.isPlayer = isPlayer;
        this.playerIndex = playerIndex;
        this.angle = 0; // Tank body rotation (fixed for artillery)
        this.turretAngle = -Math.PI/2; // Start pointing straight up (center of shooting arc)
        this.power = 50; // Start at 50% power
        this.health = CONFIG.MAX_HEALTH;
        this.alive = true;
        this.kills = 0;
        this.lastFired = 0;
        this.fireRate = 1000; // Artillery has slower rate of fire
        this.hasShot = false; // Track if player has shot this turn
        
        // Parachute drop properties
        this.dropping = dropping || false;
        this.parachuteOpen = dropping || false;
        this.landed = !dropping; // If not dropping, already landed
        
        console.log(`ü™Ç Tank created: dropping=${this.dropping}, parachuteOpen=${this.parachuteOpen}, landed=${this.landed}`);
        
        // AI properties
        this.aiTarget = null;
        this.aiThinkTimer = 0;
        this.aiAction = 'aiming';
        
        // Debug tank creation
        const playerType = isPlayer ? "HUMAN" : "AI";
        console.log(`üöó Tank created: ${playerType} at (${x}, ${y}) color: ${color}`);
      }

      update() {
        // Don't update if tank is dead
        if (!this.alive) return;
        
        // Don't update if game is over
        if (!gameState.running) return;
        
        // Handle parachute drop physics
        if (this.dropping && !this.landed) {
          this.updateParachuteDrop();
          return; // Don't update normal behavior while dropping
        }

        if (this.isPlayer) {
          this.updatePlayer();
        } else {
          this.updateAI();
        }
        
        // Apply gravity so tanks fall when terrain is destroyed
        this.applyPhysics();
        this.checkTerrainCollision();
      }

      updateParachuteDrop() {
        // Parachute drop physics - slower descent
        const parachuteGravity = 0.05; // Much slower than normal gravity (reduced from 0.1)
        const terminalVelocity = 1; // Maximum falling speed with parachute (reduced from 2)
        
        // Apply gentle downward acceleration
        this.vy += parachuteGravity;
        
        // Limit falling speed (parachute effect)
        if (this.vy > terminalVelocity) {
          this.vy = terminalVelocity;
        }
        
        // Add slight horizontal drift (wind effect)
        const windDrift = (Math.sin(Date.now() * 0.001) * 0.1);
        this.vx = windDrift;
        
        // Update position
        this.x += this.vx;
        this.y += this.vy;
        
        // Check if we've hit the terrain
        const terrainHeight = getTerrainHeight(this.x);
        if (this.y + CONFIG.TANK_SIZE/2 >= terrainHeight) {
          // Land on terrain
          this.y = terrainHeight - CONFIG.TANK_SIZE;
          this.vx = 0;
          this.vy = 0;
          this.dropping = false;
          this.parachuteOpen = false;
          this.landed = true;
          
          console.log(`ü™Ç Tank ${this.playerIndex} landed at (${this.x.toFixed(1)}, ${this.y.toFixed(1)})`);
          
          // Check if all tanks have landed
          this.checkAllTanksLanded();
        }
        
        // Keep tank on screen horizontally
        this.x = Math.max(CONFIG.TANK_SIZE, Math.min(CONFIG.CANVAS_WIDTH - CONFIG.TANK_SIZE, this.x));
      }
      
      checkAllTanksLanded() {
        const allLanded = gameState.players.every(tank => tank.landed);
        if (allLanded) {
          console.log('üéØ All tanks have landed! Game can begin.');
          
          // Start the game properly
          gameState.turnPhase = 'aiming';
          gameState.currentPlayer = 0; // Start with first player
          
          // Reset all tanks for gameplay
          gameState.players.forEach(tank => {
            tank.hasShot = false;
            tank.aiThinkTimer = 0;
          });
          
          console.log('üéÆ Game started! First turn: Player 1');
        }
      }

      updatePlayer() {
        // Only update during player's turn
        if (!this.isPlayer || gameState.currentPlayer !== this.playerIndex) return;
        
        const input = this.getInput();
        
        // Artillery controls: Adjust angle and power
        if (input.left) {
          this.turretAngle -= 0.02; // Decrease angle (aim more left)
        }
        if (input.right) {
          this.turretAngle += 0.02; // Increase angle (aim more right)
        }
        
        if (input.up) {
          this.power = Math.min(100, this.power + 1); // Increase power
        }
        if (input.down) {
          this.power = Math.max(10, this.power - 1); // Decrease power
        }
        
        // Clamp turret angle to reasonable range (left to right with upward arc - pointing to sky)
        this.turretAngle = Math.max(-Math.PI/2 - Math.PI/2.4, Math.min(-Math.PI/2 + Math.PI/2.4, this.turretAngle));
        
        // For AI, allow more flexible aiming angles
        if (!this.isPlayer) {
          this.turretAngle = Math.max(-Math.PI/6, Math.min(5*Math.PI/6, this.turretAngle));
        }

        // Firing
        if (input.fire && Date.now() - this.lastFired > this.fireRate) {
          this.fire();
          this.endTurn();
        }
      }

      updateAI() {
        // Only update AI during their turn in artillery mode
        if (this.isPlayer || gameState.currentPlayer !== this.playerIndex) return;
        
        // Exit if game is over
        if (!gameState.running) return;
        
        // Exit if AI has already shot this turn
        if (this.hasShot) return;
        
        // Debug: Log AI turn status
        if (this.aiThinkTimer === 0) {
          console.log(`ü§ñ AI ${this.playerIndex} starting turn, hasShot: ${this.hasShot}`);
        }
        
        // Debug: Log AI phases occasionally
        if (this.aiThinkTimer % 20 === 0) {
          console.log(`ü§ñ AI ${this.playerIndex} phase: ${this.aiThinkTimer < 30 ? 'Phase 1' : this.aiThinkTimer < 80 ? 'Phase 2' : 'Phase 3'}, target: ${this.aiTarget ? 'Found' : 'None'}, hasShot: ${this.hasShot}`);
        }
        
        this.aiThinkTimer++;
        
                // AI takes time to think and aim
        if (this.aiThinkTimer < 30) {
          // Phase 1: AI "looks around" and adjusts aim gradually
          if (!this.aiTarget) {
            // Find human player targets first, then other AI tanks if no humans available
            let foundTarget = false;
            for (const tank of gameState.players) {
              if (tank.alive && tank.isPlayer) {
                this.aiTarget = tank;
                foundTarget = true;
                break;
              }
            }
            
            // If no human targets found, target other AI tanks
            if (!foundTarget) {
              for (const tank of gameState.players) {
                if (tank.alive && tank !== this) {
                  this.aiTarget = tank;
                  foundTarget = true;
                  break;
                }
              }
            }
            
            // Debug: Log target found
            if (foundTarget) {
              console.log(`üéØ AI ${this.playerIndex} targeting ${this.aiTarget.isPlayer ? 'HUMAN' : 'AI'} tank at (${this.aiTarget.x}, ${this.aiTarget.y})`);
            }
          }
          
          // Validate current target - if dead, clear it
          if (this.aiTarget && !this.aiTarget.alive) {
            console.log(`üíÄ AI ${this.playerIndex} target died, clearing target`);
            this.aiTarget = null;
            return; // Wait for next frame to find new target
          }
          
          if (this.aiTarget) {
            // Calculate distance to target
            const dx = this.aiTarget.x - this.x;
            const dy = this.aiTarget.y - this.y;
            const distance = Math.hypot(dy, dx);
            
            // For close targets, aim more directly; for far targets, use ballistic arcs
            if (distance < 200) {
              // Close range: aim directly
              const targetAngle = Math.atan2(dy, dx);
              const angleDiff = targetAngle - this.turretAngle;
              let shortestAngle = ((angleDiff + Math.PI) % (2 * Math.PI)) - Math.PI;
              this.turretAngle += shortestAngle * 0.05;
            } else {
              // Long range: start with ballistic arc
              const ballisticSolution = this.calculateBallisticSolution(this.aiTarget.x, this.aiTarget.y);
              if (ballisticSolution) {
                const angleDiff = ballisticSolution.angle - this.turretAngle;
                let shortestAngle = ((angleDiff + Math.PI) % (2 * Math.PI)) - Math.PI;
                this.turretAngle += shortestAngle * 0.05;
              }
            }
            
            // Clamp turret angle (AI uses same artillery system as player)
            this.turretAngle = Math.max(-Math.PI/2 - Math.PI/2.4, Math.min(-Math.PI/2 + Math.PI/2.4, this.turretAngle));
            this.power = Math.max(10, Math.min(100, this.power));
          }
        } else if (this.aiThinkTimer < 80) {
          // Phase 2: Calculate ballistic solution
          if (this.aiTarget) {
            // Validate target is still alive
            if (!this.aiTarget.alive) {
              console.log(`üíÄ AI ${this.playerIndex} target died during Phase 2, clearing target`);
              this.aiTarget = null;
              this.aiThinkTimer = 0; // Reset to Phase 1
              return;
            }
            
            const solution = this.calculateBallisticSolution(this.aiTarget.x, this.aiTarget.y);
            if (solution) {
              // Gradually adjust to the calculated solution
              const angleDiff = solution.angle - this.turretAngle;
              let shortestAngle = ((angleDiff + Math.PI) % (2 * Math.PI)) - Math.PI;
              this.turretAngle += shortestAngle * 0.1;
              
              // Set power towards calculated value
              this.power += (solution.power - this.power) * 0.1;
              
              // Clamp values (AI uses same artillery system as player)
              this.turretAngle = Math.max(-Math.PI/2 - Math.PI/2.4, Math.min(-Math.PI/2 + Math.PI/2.4, this.turretAngle));
              this.power = Math.max(10, Math.min(100, this.power));
            }
          }
        } else if (this.aiThinkTimer > 100 && !this.hasShot) {
          // Phase 3: Fire after final adjustment
          console.log(`üéØ AI ${this.playerIndex} entering Phase 3 - ready to fire!`);
          if (this.aiTarget && !this.hasShot) { // Double-check hasShot flag
            // Validate target is still alive before firing
            if (!this.aiTarget.alive) {
              console.log(`üíÄ AI ${this.playerIndex} target died before firing, clearing target`);
              this.aiTarget = null;
              this.aiThinkTimer = 0; // Reset to Phase 1
              return;
            }
            
            // Add some randomness for imperfect AI (skill level)
            const aimError = (Math.random() - 0.5) * 0.15; // Reduced error for better AI
            const powerError = (Math.random() - 0.5) * 10;
            
            this.turretAngle += aimError;
            this.power += powerError;
            
            // Clamp final values (AI uses same artillery system as player)
            this.turretAngle = Math.max(-Math.PI/2 - Math.PI/2.4, Math.min(-Math.PI/2 + Math.PI/2.4, this.turretAngle));
            this.power = Math.max(10, Math.min(100, this.power));
            
            // Fire at target!
            console.log(`üéØ AI ${this.playerIndex} FIRING at target! Angle: ${this.turretAngle.toFixed(2)}, Power: ${this.power.toFixed(1)}`);
            this.fire();
            this.endTurn();
          } else {
            this.endTurn();
          }
        } else if (this.aiThinkTimer > 150) {
          // Fallback: end turn if something went wrong
          this.endTurn();
        }
      }

      getInput() {
        return input.getPlayerInput(this.playerIndex);
      }

      calculateBallisticSolution(targetX, targetY) {
        const dx = targetX - this.x;
        const dy = targetY - this.y;
        const gravity = CONFIG.GRAVITY;
        
        // Try different angles to find a solution
        for (let power = 30; power <= 100; power += 5) {
          for (let angle = -Math.PI/2 - Math.PI/2.4; angle <= -Math.PI/2 + Math.PI/2.4; angle += 0.1) {
            const velocity = (power / 100) * CONFIG.BULLET_SPEED;
            const vx = Math.cos(angle) * velocity;
            const vy = Math.sin(angle) * velocity;
            
            // Simulate trajectory to see if it hits target
            let x = this.x;
            let y = this.y;
            let vxCurrent = vx;
            let vyCurrent = vy;
            
            for (let step = 0; step < 200; step++) {
              // Apply physics
              vyCurrent += gravity;
              vxCurrent += gameState.wind * 0.01;
              x += vxCurrent;
              y += vyCurrent;
              
              // Check if we're close to target
              const distanceToTarget = Math.hypot(x - targetX, y - targetY);
              if (distanceToTarget < 30) { // Within 30 pixels is "close enough"
                return { angle, power };
              }
              
              // Check if we hit terrain or went off screen
              if (y >= getTerrainHeight(x) || x < 0 || x > CONFIG.CANVAS_WIDTH || y > CONFIG.CANVAS_HEIGHT) {
                break;
              }
            }
          }
        }
        
        // Fallback: use ballistic arc instead of direct line
        // Calculate a reasonable arc that accounts for gravity
        const distance = Math.hypot(dx, dy);
        const gravityValue = CONFIG.GRAVITY;
        
        // Use a formula for projectile motion: angle = arctan(dy/dx + g*distance/(2*v0^2))
        // This gives a more realistic arc trajectory
        const baseAngle = Math.atan2(dy, dx);
        const velocity = 50; // Medium velocity
        const gravityCorrection = (gravityValue * distance) / (2 * velocity * velocity);
        const arcAngle = baseAngle + gravityCorrection;
        
        return {
          angle: arcAngle,
          power: 70
        };
      }

      updateTurretAiming() {
        if (!this.isPlayer) return; // AI handles their own turret aiming
        
        // For players, turret aims at nearest enemy or follows movement
        let targetAngle = this.turretAngle; // Keep current angle as default
        
        // Find nearest enemy
        let nearestEnemy = null;
        let nearestDistance = Infinity;
        
        // Check AI tanks
        for (const tank of gameState.aiTanks) {
          if (tank.alive) {
            const distance = Math.hypot(tank.x - this.x, tank.y - this.y);
            if (distance < nearestDistance && distance < 300) { // Within 300px range
              nearestDistance = distance;
              nearestEnemy = tank;
            }
          }
        }
        
        // Check other players (for versus mode)
        for (const tank of gameState.players) {
          if (tank !== this && tank.alive) {
            const distance = Math.hypot(tank.x - this.x, tank.y - this.y);
            if (distance < nearestDistance && distance < 300) { // Within 300px range
              nearestDistance = distance;
              nearestEnemy = tank;
            }
          }
        }
        
        if (nearestEnemy) {
          // Aim at nearest enemy
          targetAngle = Math.atan2(nearestEnemy.y - this.y, nearestEnemy.x - this.x);
        } else if (Math.abs(this.vx) > 0.1 || Math.abs(this.vy) > 0.1) {
          // No enemies nearby, aim in movement direction
          targetAngle = Math.atan2(this.vy, this.vx);
        }
        
        // Smooth turret rotation
        const angleDiff = targetAngle - this.turretAngle;
        let shortestAngle = ((angleDiff + Math.PI) % (2 * Math.PI)) - Math.PI;
        this.turretAngle += shortestAngle * 0.1; // Smooth turret rotation
      }

      applyPhysics() {
        // In artillery mode, tanks are stationary except for falling when terrain is destroyed
        // Heavy friction to prevent sliding
        this.vx *= 0.3; // Very high friction - tanks don't slide around
        
        // Apply gravity
        if (!this.onGround) {
          this.vy += CONFIG.GRAVITY;
        } else {
          this.vy = 0; // Stop falling when on ground
        }
        
        // Update position (mainly for falling)
        this.x += this.vx;
        this.y += this.vy;
        
        // Keep in bounds
        this.x = Math.max(CONFIG.TANK_SIZE, Math.min(CONFIG.CANVAS_WIDTH - CONFIG.TANK_SIZE, this.x));
        this.y = Math.max(CONFIG.TANK_SIZE, Math.min(CONFIG.CANVAS_HEIGHT - CONFIG.TANK_SIZE, this.y));
      }

      checkTerrainCollision() {
        const terrainY = getTerrainHeight(this.x);
        this.onGround = false;
        
        if (this.y + CONFIG.TANK_SIZE / 2 >= terrainY) {
          this.y = terrainY - CONFIG.TANK_SIZE / 2;
          this.vy = 0;
          this.onGround = true;
        }
      }

      fire() {
        if (this.hasShot) return; // Can only fire once per turn
        
        this.lastFired = Date.now();
        this.hasShot = true;
        
        // Calculate bullet starting position
        const bulletX = this.x + Math.cos(this.turretAngle) * (CONFIG.TANK_SIZE / 2 + 8);
        const bulletY = this.y + Math.sin(this.turretAngle) * (CONFIG.TANK_SIZE / 2 + 8);
        
        // Calculate velocity based on power and angle
        const velocity = (this.power / 100) * CONFIG.BULLET_SPEED;
        const bulletVx = Math.cos(this.turretAngle) * velocity;
        const bulletVy = Math.sin(this.turretAngle) * velocity;
        
        gameState.bullets.push(new Bullet(bulletX, bulletY, bulletVx, bulletVy, this));
        
        // Muzzle flash effect
        createMuzzleFlash(bulletX, bulletY);
        
        audio.playFire();
      }

      endTurn() {
        // End current turn and move to next player
        gameState.nextTurn();
      }

      takeDamage(damage) {
        this.health -= damage;
        if (this.health <= 0) {
          this.health = 0; // Ensure health doesn't go negative
          this.alive = false;
          this.explode();
          
          // If this was the current player's turn, end the turn immediately
          if (gameState.currentPlayer === this.playerIndex && gameState.turnPhase === 'aiming') {
            console.log(`üíÄ Current player ${this.playerIndex} died, ending turn immediately`);
            gameState.turnPhase = 'changing';
            setTimeout(() => gameState.nextTurn(), 1000);
          }
        }
        audio.playHit();
      }

      explode() {
        createExplosion(this.x, this.y, CONFIG.EXPLOSION_SIZE);
        destroyTerrain(this.x, this.y, CONFIG.TERRAIN_DESTRUCTION_RADIUS);
        audio.playExplosion();
      }

      render(ctx) {
        if (!this.alive) return;
        
        // GUARD: Skip rendering if tank has invalid position
        if (isNaN(this.x) || isNaN(this.y)) {
          console.warn(`‚ö†Ô∏è Tank has invalid position (${this.x}, ${this.y}), skipping render`);
          return;
        }

        // Debug: Log tank rendering position occasionally
        if (Math.random() < 0.01) { // Log 1% of the time to avoid spam
          console.log(`üé® Rendering tank at (${this.x}, ${this.y}), alive: ${this.alive}`);
        }

        ctx.save();
        ctx.translate(this.x, this.y);
        
        // Draw parachute if dropping
        if (this.dropping && this.parachuteOpen) {
          this.renderParachute(ctx);
        }
        
        // Draw cannon base (circular)
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(0, 0, CONFIG.TANK_SIZE / 2, 0, Math.PI * 2);
        ctx.fill();
        
        // Draw cannon base details
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 2;
        ctx.stroke();
        
        // Draw cannon platform (rectangular base)
        ctx.fillStyle = this.color;
        ctx.fillRect(-CONFIG.TANK_SIZE / 2 - 2, 0, CONFIG.TANK_SIZE + 4, CONFIG.TANK_SIZE / 3);
        
        // Draw tracks/wheels
        ctx.fillStyle = '#333';
        for (let i = -1; i <= 1; i++) {
          ctx.beginPath();
          ctx.arc(i * (CONFIG.TANK_SIZE / 3), CONFIG.TANK_SIZE / 3, 4, 0, Math.PI * 2);
          ctx.fill();
        }
        
        ctx.restore();
        
        // Draw cannon barrel
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.turretAngle);
        
        // Draw barrel with better proportions
        ctx.fillStyle = '#666'; // Darker metal color
        ctx.fillRect(0, -6, CONFIG.TANK_SIZE / 2 + 16, 12); // Thicker barrel
        
        // Draw barrel rings/bands for detail
        ctx.fillStyle = '#444';
        for (let i = 0; i <= 3; i++) {
          const x = i * (CONFIG.TANK_SIZE / 2 + 16) / 3;
          ctx.fillRect(x, -7, 2, 14);
        }
        
        // Draw barrel tip with muzzle flare
        ctx.fillStyle = '#333';
        ctx.fillRect(CONFIG.TANK_SIZE / 2 + 16, -5, 6, 10);
        
        // Draw muzzle opening
        ctx.fillStyle = '#000';
        ctx.fillRect(CONFIG.TANK_SIZE / 2 + 22, -4, 2, 8);
        
        // Draw turret base (circular platform)
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(0, 0, 8, 0, Math.PI * 2);
        ctx.fill();
        
        // Draw turret base outline
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 2;
        ctx.stroke();
        
        ctx.restore();
        
        // Draw health bar
        if (this.health < CONFIG.MAX_HEALTH) {
          const barWidth = CONFIG.TANK_SIZE;
          const barHeight = 4;
          const healthPercent = this.health / CONFIG.MAX_HEALTH;
          
          ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
          ctx.fillRect(this.x - barWidth / 2, this.y - CONFIG.TANK_SIZE / 2 - 10, barWidth, barHeight);
          
          ctx.fillStyle = healthPercent > 0.5 ? '#00ff00' : healthPercent > 0.25 ? '#ffff00' : '#ff0000';
          ctx.fillRect(this.x - barWidth / 2, this.y - CONFIG.TANK_SIZE / 2 - 10, barWidth * healthPercent, barHeight);
        }
        
        // Draw aiming indicators for current player (human or AI)
        if (gameState.currentPlayer === this.playerIndex && gameState.turnPhase === 'aiming') {
          // Draw trajectory preview
          this.drawTrajectoryPreview(ctx);
          
          // Draw power indicator
          this.drawPowerIndicator(ctx);
          
          // Draw shooting angle range indicator
          this.drawShootingAngleRange(ctx);
        }
      }
      
      drawTrajectoryPreview(ctx) {
        ctx.save();
        ctx.strokeStyle = 'rgba(255, 255, 0, 0.6)';
        ctx.lineWidth = 2;
        ctx.setLineDash([5, 5]);
        
        // Calculate trajectory points
        const velocity = (this.power / 100) * CONFIG.BULLET_SPEED;
        let x = this.x + Math.cos(this.turretAngle) * (CONFIG.TANK_SIZE / 2 + 8);
        let y = this.y + Math.sin(this.turretAngle) * (CONFIG.TANK_SIZE / 2 + 8);
        let vx = Math.cos(this.turretAngle) * velocity;
        let vy = Math.sin(this.turretAngle) * velocity;
        
        ctx.beginPath();
        ctx.moveTo(x, y);
        
        // Simulate trajectory for preview
        for (let i = 0; i < 100; i++) {
          vy += CONFIG.GRAVITY;
          vx += gameState.wind * 0.01;
          x += vx;
          y += vy;
          
          if (i % 3 === 0) ctx.lineTo(x, y); // Every few steps for smoother line
          
          // Stop if hitting terrain or going off screen
          if (y >= getTerrainHeight(x) || x < 0 || x > CONFIG.CANVAS_WIDTH || y > CONFIG.CANVAS_HEIGHT) {
            break;
          }
        }
        
        ctx.stroke();
        ctx.restore();
      }
      
      renderParachute(ctx) {
        // Draw parachute lines
        ctx.strokeStyle = '#8B4513'; // Brown ropes
        ctx.lineWidth = 1;
        
        // Draw lines from tank to parachute
        const parachuteOffset = -40; // Parachute above tank
        const parachuteWidth = 30;
        
        ctx.beginPath();
        ctx.moveTo(-5, -5); // Left side of tank
        ctx.lineTo(-parachuteWidth/2, parachuteOffset);
        ctx.moveTo(5, -5); // Right side of tank
        ctx.lineTo(parachuteWidth/2, parachuteOffset);
        ctx.moveTo(0, -8); // Center of tank
        ctx.lineTo(0, parachuteOffset + 5);
        ctx.stroke();
        
        // Draw parachute canopy
        ctx.fillStyle = '#FF6B6B'; // Red parachute
        ctx.strokeStyle = '#CC0000';
        ctx.lineWidth = 2;
        
        // Draw proper parachute canopy as a realistic parachute shape
        ctx.beginPath();
        
        // Draw the main canopy as a curved parachute shape
        const canopyWidth = parachuteWidth;
        const canopyHeight = parachuteWidth * 0.6; // Parachute height is 60% of width
        
        // Draw the main canopy curve (like a real parachute)
        ctx.moveTo(-canopyWidth/2, parachuteOffset);
        ctx.quadraticCurveTo(0, parachuteOffset - canopyHeight, canopyWidth/2, parachuteOffset);
        ctx.lineTo(canopyWidth/2, parachuteOffset + 5);
        ctx.quadraticCurveTo(0, parachuteOffset + 10, -canopyWidth/2, parachuteOffset + 5);
        ctx.closePath();
        ctx.fill();
        
        // Add parachute lines connecting to the tank
        ctx.strokeStyle = '#CC0000';
        ctx.lineWidth = 1;
        for (let i = -2; i <= 2; i++) {
          const lineX = i * (canopyWidth/6);
          ctx.beginPath();
          ctx.moveTo(lineX, parachuteOffset + 5);
          ctx.lineTo(lineX * 0.3, 0); // Lines converge slightly toward center
          ctx.stroke();
        }
        
        // Add some depth with a darker outline
        ctx.strokeStyle = '#CC0000';
        ctx.lineWidth = 2;
        ctx.stroke();
      }
      
      drawPowerIndicator(ctx) {
        // Power bar above tank
        const barWidth = 60;
        const barHeight = 8;
        const barX = this.x - barWidth / 2;
        const barY = this.y - CONFIG.TANK_SIZE / 2 - 25;
        
        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        ctx.fillRect(barX, barY, barWidth, barHeight);
        
        const powerPercent = this.power / 100;
        ctx.fillStyle = powerPercent < 0.3 ? '#00ff00' : powerPercent < 0.7 ? '#ffff00' : '#ff0000';
        ctx.fillRect(barX, barY, barWidth * powerPercent, barHeight);
        
        // Power text
        ctx.fillStyle = '#ffffff';
        ctx.font = '12px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(`${this.power}%`, this.x, barY - 5);
      }
      
      drawShootingAngleRange(ctx) {
        // Draw shooting angle range indicator
        ctx.save();
        ctx.translate(this.x, this.y);
        
        // Draw the available shooting angle range
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
        ctx.lineWidth = 1;
        ctx.setLineDash([3, 3]);
        
        // Draw left boundary (minimum angle - left direction)
        ctx.beginPath();
        ctx.moveTo(0, 0);
        const leftAngle = -Math.PI/2 - Math.PI/2.4; // 75 degrees left of straight up
        const leftX = Math.cos(leftAngle) * 60;
        const leftY = Math.sin(leftAngle) * 60;
        ctx.lineTo(leftX, leftY);
        ctx.stroke();
        
        // Draw right boundary (maximum angle - right direction)
        ctx.beginPath();
        ctx.moveTo(0, 0);
        const rightAngle = -Math.PI/2 + Math.PI/2.4; // 75 degrees right of straight up
        const rightX = Math.cos(rightAngle) * 60;
        const rightY = Math.sin(rightAngle) * 60;
        ctx.lineTo(rightX, rightY);
        ctx.stroke();
        
        // Draw arc showing the range
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
        ctx.lineWidth = 2;
        ctx.setLineDash([]);
        ctx.beginPath();
        ctx.arc(0, 0, 60, leftAngle, rightAngle);
        ctx.stroke();
        
        // Draw current aim line
        ctx.strokeStyle = 'rgba(255, 255, 0, 0.8)';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        const currentX = Math.cos(this.turretAngle) * 60;
        const currentY = Math.sin(this.turretAngle) * 60;
        ctx.lineTo(currentX, currentY);
        ctx.stroke();
        
        ctx.restore();
      }
    }

    class Bullet {
      constructor(x, y, vx, vy, owner) {
        this.x = x;
        this.y = y;
        this.vx = vx;
        this.vy = vy;
        this.owner = owner;
        this.alive = true;
        this.trail = [];
      }

      update() {
        if (!this.alive) return;

        // Add to trail
        this.trail.push({ x: this.x, y: this.y });
        if (this.trail.length > 5) {
          this.trail.shift();
        }

        // Apply artillery physics
        this.vy += CONFIG.GRAVITY; // Full gravity for realistic ballistics
        this.vx += gameState.wind * 0.01; // Wind effect

        // Update position
        this.x += this.vx;
        this.y += this.vy;

        // Check bounds
        if (this.x < 0 || this.x > CONFIG.CANVAS_WIDTH || 
            this.y < 0 || this.y > CONFIG.CANVAS_HEIGHT) {
          this.alive = false;
          return;
        }

        // Check terrain collision
        const terrainY = getTerrainHeight(this.x);
        if (this.y >= terrainY) {
          console.log(`Bullet hit terrain at (${this.x}, ${this.y}), terrain height: ${terrainY}`);
          this.explode();
          return;
        }

        // Check tank collisions
        this.checkTankCollisions();
      }

      checkTankCollisions() {
        const allTanks = [...gameState.players, ...gameState.aiTanks];
        
        for (const tank of allTanks) {
          if (tank === this.owner || !tank.alive) continue;
          
          const distance = Math.hypot(tank.x - this.x, tank.y - this.y);
          if (distance < CONFIG.TANK_SIZE / 2) {
            tank.takeDamage(CONFIG.DAMAGE_PER_HIT);
            if (!tank.alive) {
              this.owner.kills++;
            }
            this.explode();
            return;
          }
        }
      }

      explode() {
        console.log(`Bullet exploding at (${this.x}, ${this.y})`);
        this.alive = false;
        createExplosion(this.x, this.y, CONFIG.EXPLOSION_SIZE / 2);
        console.log(`Calling destroyTerrain with radius ${CONFIG.TERRAIN_DESTRUCTION_RADIUS}`);
        destroyTerrain(this.x, this.y, CONFIG.TERRAIN_DESTRUCTION_RADIUS);
        audio.playExplosion();
      }

      render(ctx) {
        if (!this.alive) return;

        // Draw trail
        ctx.strokeStyle = CONFIG.COLORS.bullet;
        ctx.lineWidth = 2;
        ctx.globalAlpha = 0.5;
        
        if (this.trail.length > 1) {
          ctx.beginPath();
          ctx.moveTo(this.trail[0].x, this.trail[0].y);
          for (let i = 1; i < this.trail.length; i++) {
            ctx.lineTo(this.trail[i].x, this.trail[i].y);
          }
          ctx.stroke();
        }
        
        ctx.globalAlpha = 1;

        // Draw bullet
        ctx.fillStyle = CONFIG.COLORS.bullet;
        ctx.shadowColor = CONFIG.COLORS.bullet;
        ctx.shadowBlur = 10;
        ctx.beginPath();
        ctx.arc(this.x, this.y, CONFIG.BULLET_SIZE, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
      }
    }

    class Explosion {
      constructor(x, y, maxSize) {
        this.x = x;
        this.y = y;
        this.size = 0;
        this.maxSize = maxSize;
        this.life = 30; // frames
        this.particles = [];
        
        // Create particles
        for (let i = 0; i < 15; i++) {
          this.particles.push({
            x: x + (Math.random() - 0.5) * 20,
            y: y + (Math.random() - 0.5) * 20,
            vx: (Math.random() - 0.5) * 10,
            vy: (Math.random() - 0.5) * 10 - 5,
            life: 20 + Math.random() * 20,
            maxLife: 20 + Math.random() * 20,
            size: 3 + Math.random() * 5
          });
        }
      }

      update() {
        this.life--;
        this.size = Math.min(this.maxSize, this.size + this.maxSize / 15);
        
        // Update particles
        this.particles.forEach(particle => {
          particle.x += particle.vx;
          particle.y += particle.vy;
          particle.vy += 0.2; // gravity
          particle.life--;
          particle.vx *= 0.98;
          particle.vy *= 0.98;
        });
        
        this.particles = this.particles.filter(p => p.life > 0);
      }

      render(ctx) {
        // Draw explosion circle
        const alpha = this.life / 30;
        ctx.globalAlpha = alpha;
        
        const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.size);
        gradient.addColorStop(0, CONFIG.COLORS.explosion);
        gradient.addColorStop(0.5, '#FFD700');
        gradient.addColorStop(1, 'transparent');
        
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fill();
        
        // Draw particles
        this.particles.forEach(particle => {
          const particleAlpha = particle.life / particle.maxLife;
          ctx.globalAlpha = alpha * particleAlpha;
          
          ctx.fillStyle = particleAlpha > 0.5 ? '#FFD700' : CONFIG.COLORS.explosion;
          ctx.beginPath();
          ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
          ctx.fill();
        });
        
        ctx.globalAlpha = 1;
      }

      get alive() {
        return this.life > 0 || this.particles.length > 0;
      }
    }

    // Initialize game systems
    const input = new InputManager();
    const audio = new AudioManager();

    // Canvas setup
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    ctx.imageSmoothingEnabled = false;

    // Terrain generation
    function generateTerrain() {
      gameState.terrain = [];
      const width = CONFIG.CANVAS_WIDTH;
      const baseHeight = CONFIG.CANVAS_HEIGHT - CONFIG.TERRAIN_HEIGHT;
      
      // Create more varied, random terrain
      let currentHeight = baseHeight;
      for (let x = 0; x < width; x++) {
        // Multiple layers of noise for realistic mountains
        const wave1 = Math.sin(x * 0.008) * 40;      // Large hills
        const wave2 = Math.sin(x * 0.03) * 25;       // Medium ridges  
        const wave3 = Math.sin(x * 0.08) * 15;       // Small bumps
        const noise = (Math.random() - 0.5) * 10;    // Random variation
        
        // Add some steep cliffs and valleys
        const cliffNoise = Math.sin(x * 0.004) * 60;
        
        const terrainHeight = baseHeight + wave1 + wave2 + wave3 + noise + cliffNoise;
        
        // Smooth terrain slightly to avoid extreme spikes
        if (x > 0) {
          const smoothing = (currentHeight + terrainHeight) / 2;
          gameState.terrain[x] = Math.max(baseHeight - 100, Math.min(baseHeight + 80, smoothing));
          currentHeight = gameState.terrain[x];
        } else {
          gameState.terrain[x] = Math.max(baseHeight - 100, Math.min(baseHeight + 80, terrainHeight));
          currentHeight = gameState.terrain[x];
        }
      }
    }

    function generateTankDropPositions(mode) {
      console.log('ü™Ç generateTankDropPositions() called with mode:', mode);
      
      const positions = [];
      
      // Determine how many tanks we need
      let tankCount = 1; // Always at least one human player
      if (mode === 'versus') {
        tankCount = 2; // Human vs Human (no AI in versus mode for now)
      } else if (mode === 'single') {
        tankCount = 3; // 1 human + 2 AI
      } else if (mode === 'survival') {
        tankCount = 4; // 1 human + 3 AI
      }
      
      console.log(`ü™Ç Creating ${tankCount} parachute drop positions for ${mode} mode`);
      
      // Generate random X positions with minimum distance between tanks
      const margin = 100;
      const availableWidth = CONFIG.CANVAS_WIDTH - 2 * margin;
      const minDistance = 150; // Minimum distance between tanks
      
      for (let i = 0; i < tankCount; i++) {
        let attempts = 0;
        let x, validPosition = false;
        
        // Try to find a valid position that's not too close to existing tanks
        while (!validPosition && attempts < 50) {
          x = margin + Math.random() * availableWidth;
          
          // Check distance from existing tanks
          validPosition = positions.every(pos => Math.abs(pos.x - x) >= minDistance);
          attempts++;
        }
        
        // If we couldn't find a good position, use a fallback
        if (!validPosition) {
          x = margin + (i * availableWidth / Math.max(1, tankCount - 1));
          console.warn(`‚ö†Ô∏è Using fallback position for tank ${i}: x=${x}`);
        }
        
        // Start tanks high above the screen for parachute drop
        const y = -50; // Start above the visible area
        
        console.log(`ü™Ç Tank ${i} drop position: x=${x.toFixed(1)}, y=${y} (will fall to terrain)`);
        positions.push({ x, y, dropping: true }); // Add dropping flag
      }
      
      console.log(`ü™Ç Generated ${positions.length} parachute drop positions:`, positions);
      return positions;
    }

    function getTerrainHeight(x) {
      const clampedX = Math.max(0, Math.min(CONFIG.CANVAS_WIDTH - 1, Math.floor(x)));
      const height = gameState.terrain[clampedX];
      
      if (height === undefined || height === null) {
        console.warn(`‚ö†Ô∏è No terrain height at x=${x}, using default`);
        return CONFIG.CANVAS_HEIGHT - 100; // Default terrain height
      }
      
      return height;
    }

    function destroyTerrain(centerX, centerY, radius) {
      console.log(`üéØ Destroying terrain at (${Math.round(centerX)}, ${Math.round(centerY)}) with radius ${radius}`);
      
      let modified = 0;
      for (let x = Math.floor(centerX - radius); x <= Math.ceil(centerX + radius); x++) {
        if (x >= 0 && x < CONFIG.CANVAS_WIDTH) {
          const distance = Math.abs(x - centerX);
          if (distance <= radius) {
            const factor = 1 - (distance / radius);
            const oldHeight = gameState.terrain[x];
            
            // Create a crater: in canvas coordinates, higher Y = lower on screen
            // So to create a crater (hole), we need to INCREASE the Y value
            const craterDepth = factor * radius;
            const craterBottomY = Math.max(centerY, oldHeight) + craterDepth;
            
            // Ensure we don't go below canvas bottom
            const newHeight = Math.min(craterBottomY, CONFIG.CANVAS_HEIGHT - 10);
            
            if (newHeight > oldHeight) {
              gameState.terrain[x] = newHeight;
              modified++;
            }
          }
        }
      }
      console.log(`üí• Modified ${modified} terrain points`);
    }

    function createMuzzleFlash(x, y) {
      const flash = document.createElement('div');
      flash.className = 'muzzle-flash';
      flash.style.left = x + 'px';
      flash.style.top = y + 'px';
      document.getElementById('gameContainer').appendChild(flash);
      
      setTimeout(() => {
        if (flash.parentNode) {
          flash.parentNode.removeChild(flash);
        }
      }, 100);
    }

    function createExplosion(x, y, size) {
      gameState.explosions.push(new Explosion(x, y, size));
    }

    // Game functions
    function initializeGame() {
      // Generate terrain first
      generateTerrain();
      console.log('üèîÔ∏è Terrain generated');
      
      // Create players with randomized positions
      gameState.players = [];
      gameState.aiTanks = [];
      
      const positions = generateTankDropPositions(gameState.mode);
      console.log('üéØ Tank positions:', positions);
      
      // DEBUG: Check for NaN positions
      positions.forEach((pos, i) => {
        console.log(`üîç Position ${i}: x=${pos.x} (isNaN: ${isNaN(pos.x)}), y=${pos.y} (isNaN: ${isNaN(pos.y)})`);
      });
      
      // Create human player(s)
      const player1Pos = positions[0];
      console.log(`üë§ Creating human player at (${player1Pos.x}, ${player1Pos.y})`);
      gameState.players.push(new Tank(player1Pos.x, player1Pos.y, CONFIG.COLORS.player1, true, 0, player1Pos.dropping));
      
      if (gameState.mode === 'versus') {
        const player2Pos = positions[1];
        gameState.players.push(new Tank(player2Pos.x, player2Pos.y, CONFIG.COLORS.player2, true, 1, player2Pos.dropping));
        document.getElementById('player2Panel').style.display = 'block';
        
        // Create AI tanks for remaining positions
        for (let i = 2; i < positions.length; i++) {
          const pos = positions[i];
          const aiTank = new Tank(pos.x, pos.y, CONFIG.COLORS.ai, false, i, pos.dropping);
          gameState.aiTanks.push(aiTank);
          gameState.players.push(aiTank);
        }
      } else {
        document.getElementById('player2Panel').style.display = 'none';
        
        // Create AI tanks for remaining positions
        for (let i = 1; i < positions.length; i++) {
          const pos = positions[i];
          console.log(`ü§ñ Creating AI tank ${i} at (${pos.x}, ${pos.y})`);
          const aiTank = new Tank(pos.x, pos.y, CONFIG.COLORS.ai, false, i, pos.dropping);
          gameState.aiTanks.push(aiTank);
          gameState.players.push(aiTank);
        }
      }
      
      // Reset game state
      gameState.bullets = [];
      gameState.explosions = [];
      gameState.particles = [];
      gameState.gameTime = 0;
      
      // Debug: Summary of game initialization
      console.log(`üéÆ Game initialized: ${gameState.players.length} total tanks`);
      gameState.players.forEach((tank, i) => {
        const type = tank.isPlayer ? "HUMAN" : "AI";
        console.log(`  Tank ${i}: ${type} at (${tank.x.toFixed(1)}, ${tank.y.toFixed(1)})`);
      });
      
      updateHUD();
    }

    function updateGame() {
      if (!gameState.running || gameState.paused) return;

      // Check if game should be over (only one player left alive)
      const alivePlayers = gameState.players.filter(p => p.alive);
      if (alivePlayers.length <= 1 && gameState.running) {
        console.log(`üèÜ Game Over detected in updateGame! ${alivePlayers.length === 1 ? 'Winner: ' + (alivePlayers[0].isPlayer ? 'HUMAN' : 'AI') + ' Player ' + (gameState.players.indexOf(alivePlayers[0]) + 1) : 'All players destroyed'}`);
        console.log(`üìä Final alive count: ${alivePlayers.length}/${gameState.players.length}`);
        endGame();
        return;
      }
      
      // Additional safety: if any tank has negative health, force them dead
      gameState.players.forEach(tank => {
        if (tank.health <= 0 && tank.alive) {
          console.log(`‚ö†Ô∏è Tank ${tank.playerIndex} has ${tank.health} health but is marked alive, forcing death`);
          tank.health = 0;
          tank.alive = false;
        }
      });

      gameState.gameTime += gameState.gameSpeed;

      // Update entities
      gameState.players.forEach(player => player.update());
      gameState.aiTanks.forEach(ai => ai.update());
      gameState.bullets.forEach(bullet => bullet.update());
      gameState.explosions.forEach(explosion => explosion.update());

      // Remove dead entities
      gameState.bullets = gameState.bullets.filter(bullet => bullet.alive);
      gameState.explosions = gameState.explosions.filter(explosion => explosion.alive);

      // Check for turn change if waiting and no bullets left
      if (gameState.turnPhase === 'waiting' && gameState.bullets.length === 0) {
        setTimeout(() => gameState.nextTurn(), 1000); // 1 second delay between turns
        gameState.turnPhase = 'changing';
      }
      
      // Safety timeout: if waiting too long, force turn change
      if (gameState.turnPhase === 'waiting' && gameState.gameTime % 5000 === 0) {
        console.log('‚ö†Ô∏è Safety timeout: forcing turn change after 5 seconds');
        gameState.turnPhase = 'changing';
        setTimeout(() => gameState.nextTurn(), 1000);
      }

      // Check win conditions
      checkWinConditions();
      
      updateHUD();
    }

    function checkWinConditions() {
      const alivePlayers = gameState.players.filter(p => p.alive);
      const aliveAI = gameState.aiTanks.filter(ai => ai.alive);
      
      if (gameState.mode === 'versus') {
        if (alivePlayers.length <= 1) {
          endGame();
        }
      } else if (gameState.mode === 'single') {
        if (alivePlayers.length === 0) {
          endGame();
        } else if (aliveAI.length === 0) {
          // Next round
          nextRound();
        }
      } else if (gameState.mode === 'survival') {
        if (alivePlayers.length === 0) {
          endGame();
        } else if (aliveAI.length === 0) {
          // Spawn more AI tanks
          spawnSurvivalWave();
        }
      }
    }

    function nextRound() {
      gameState.round++;
      // Heal players partially
      gameState.players.forEach(player => {
        if (player.alive) {
          player.health = Math.min(CONFIG.MAX_HEALTH, player.health + 50);
        }
      });
      
      setTimeout(() => {
        initializeGame();
      }, 2000);
    }

    function spawnSurvivalWave() {
      const waveSize = Math.min(6, 2 + Math.floor(gameState.round / 2));
      for (let i = 0; i < waveSize; i++) {
        const x = Math.random() * (CONFIG.CANVAS_WIDTH - 100) + 50;
        const y = getTerrainHeight(x) - CONFIG.TANK_SIZE / 2;
        gameState.aiTanks.push(new Tank(x, y, CONFIG.COLORS.ai, false));
      }
      gameState.round++;
    }

    function handleInput() {
      if (!gameState.running) return;

      // Check pause
      if (input.isPausePressed() && !gameState.pausePressed) {
        gameState.paused = !gameState.paused;
        document.getElementById('pausedOverlay').style.display = gameState.paused ? 'flex' : 'none';
        gameState.pausePressed = true;
      } else if (!input.isPausePressed()) {
        gameState.pausePressed = false;
      }

      // Check fullscreen
      if (input.isFullscreenPressed() && !gameState.fullscreenPressed) {
        toggleFullscreen();
        gameState.fullscreenPressed = true;
      } else if (!input.isFullscreenPressed()) {
        gameState.fullscreenPressed = false;
      }

      // Check restart
      if (input.isRestartPressed() && !gameState.restartPressed) {
        restartGame();
        gameState.restartPressed = true;
      } else if (!input.isRestartPressed()) {
        gameState.restartPressed = false;
      }
    }

    function render() {
      // Clear canvas with sky gradient
      const gradient = ctx.createLinearGradient(0, 0, 0, CONFIG.CANVAS_HEIGHT);
      gradient.addColorStop(0, CONFIG.COLORS.sky);
      gradient.addColorStop(0.7, '#87CEEB');
      gradient.addColorStop(1, CONFIG.COLORS.terrain);
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, CONFIG.CANVAS_WIDTH, CONFIG.CANVAS_HEIGHT);

      // Draw terrain
      ctx.fillStyle = CONFIG.COLORS.terrain;
      ctx.beginPath();
      ctx.moveTo(0, CONFIG.CANVAS_HEIGHT);
      for (let x = 0; x < CONFIG.CANVAS_WIDTH; x++) {
        ctx.lineTo(x, gameState.terrain[x]);
      }
      ctx.lineTo(CONFIG.CANVAS_WIDTH, CONFIG.CANVAS_HEIGHT);
      ctx.closePath();
      ctx.fill();

      // Draw terrain border
      ctx.strokeStyle = CONFIG.COLORS.terrainBorder;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(0, gameState.terrain[0]);
      for (let x = 1; x < CONFIG.CANVAS_WIDTH; x++) {
        ctx.lineTo(x, gameState.terrain[x]);
      }
      ctx.lineTo(CONFIG.CANVAS_WIDTH, gameState.terrain[CONFIG.CANVAS_WIDTH]);
      ctx.stroke();

      // Debug: Draw test markers at known positions
      // Removed debug markers - no more orange squares!
      
      // Tank rendering is now handled by Tank.render() method
      // No more debug red squares!

      // Draw game entities
      gameState.explosions.forEach(explosion => explosion.render(ctx));
      gameState.bullets.forEach(bullet => bullet.render(ctx));
      
      // Render all tanks (players array includes both human and AI tanks)
      gameState.players.forEach(player => player.render(ctx));
      
      // Draw wind indicator
      drawWindIndicator(ctx);
      
      // Debug: Show how many tanks we're trying to render
      if (Math.random() < 0.01) { // Log occasionally
        console.log(`üé® Rendering ${gameState.players.length} tanks`);
      }
    }

    function updateHUD() {
      if (gameState.players.length > 0) {
        const p1 = gameState.players[0];
        document.getElementById('player1Health').textContent = Math.max(0, p1.health);
        document.getElementById('player1HealthBar').style.width = Math.max(0, (p1.health / CONFIG.MAX_HEALTH) * 100) + '%';
        document.getElementById('player1Kills').textContent = p1.kills;
      }
      
      if (gameState.players.length > 1) {
        const p2 = gameState.players[1];
        document.getElementById('player2Health').textContent = Math.max(0, p2.health);
        document.getElementById('player2HealthBar').style.width = Math.max(0, (p2.health / CONFIG.MAX_HEALTH) * 100) + '%';
        document.getElementById('player2Kills').textContent = p2.kills;
      }
      
      document.getElementById('roundDisplay').textContent = gameState.round;
      
      const minutes = Math.floor(gameState.gameTime / 60000);
      const seconds = Math.floor((gameState.gameTime % 60000) / 1000);
      document.getElementById('timeDisplay').textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
    }

    function endGame() {
      gameState.running = false;
      
      let statsHtml = '';
      if (gameState.mode === 'versus') {
        const alivePlayers = gameState.players.filter(p => p.alive);
        if (alivePlayers.length > 0) {
          const winner = alivePlayers[0];
          const winnerNum = gameState.players.indexOf(winner) + 1;
          statsHtml += `<div style="color: ${winner.color}; font-size: 2rem; margin-bottom: 15px;">Player ${winnerNum} Wins!</div>`;
        } else {
          statsHtml += `<div style="font-size: 2rem; margin-bottom: 15px;">Draw!</div>`;
        }
      } else {
        const alivePlayers = gameState.players.filter(p => p.alive);
        if (alivePlayers.length > 0) {
          statsHtml += `<div style="color: ${CONFIG.COLORS.player1}; font-size: 2rem; margin-bottom: 15px;">Mission Complete!</div>`;
        } else {
          statsHtml += `<div style="color: #ff4444; font-size: 2rem; margin-bottom: 15px;">Mission Failed!</div>`;
        }
      }
      
      statsHtml += `<div style="font-size: 1.4rem; margin-bottom: 15px;">Round ${gameState.round} ‚Ä¢ Time: ${document.getElementById('timeDisplay').textContent}</div>`;
      statsHtml += '<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">';
      
      gameState.players.forEach((player, index) => {
        const status = player.alive ? 'ALIVE' : 'DESTROYED';
        statsHtml += `
          <div style="padding: 15px; border: 2px solid ${player.color}; border-radius: 10px;">
            <div style="color: ${player.color}; font-weight: 700; font-size: 1.2rem;">Player ${index + 1}</div>
            <div style="margin-top: 8px;">Health: ${Math.max(0, player.health)}%</div>
            <div>Kills: ${player.kills}</div>
            <div style="font-size: 0.9rem; opacity: 0.8;">${status}</div>
          </div>
        `;
      });
      statsHtml += '</div>';
      
      document.getElementById('finalStats').innerHTML = statsHtml;
      document.getElementById('gameOverOverlay').classList.remove('hidden');
    }

    // Turn management functions
    gameState.nextTurn = function() {
      // Mark current player as having shot
      const currentPlayer = this.getCurrentPlayer();
      if (currentPlayer) {
        currentPlayer.hasShot = true;
      }
      
      // Wait for bullet to land before changing turns
      if (this.bullets.length > 0) {
        this.turnPhase = 'waiting';
        return;
      }
      
      // Find next alive player
      let attempts = 0;
      let nextPlayerFound = false;
      
      // Check if game is over (only one player left alive)
      const alivePlayers = this.players.filter(p => p.alive);
      if (alivePlayers.length <= 1) {
        console.log(`üèÜ Game Over! ${alivePlayers.length === 1 ? 'Winner: ' + (alivePlayers[0].isPlayer ? 'HUMAN' : 'AI') + ' Player ' + (this.players.indexOf(alivePlayers[0]) + 1) : 'All players destroyed'}`);
        console.log(`üìä Final stats: ${alivePlayers.length} alive out of ${this.players.length} total`);
        this.players.forEach((p, i) => {
          console.log(`  Tank ${i}: ${p.isPlayer ? 'HUMAN' : 'AI'} - Alive: ${p.alive}, Health: ${p.health}`);
        });
        this.endGame();
        return;
      }
      
      // Additional safety check: ensure we're not trying to cycle to a dead player
      if (!this.players[this.currentPlayer].alive) {
        console.log(`‚ö†Ô∏è Current player ${this.currentPlayer} is dead, forcing next turn`);
        this.currentPlayer = (this.currentPlayer + 1) % this.players.length;
      }
      
      do {
        this.currentPlayer = (this.currentPlayer + 1) % this.players.length;
        attempts++;
        
        // Prevent infinite loop if all players are dead
        if (attempts > this.players.length) {
          console.warn('‚ö†Ô∏è All players are dead, ending game');
          this.endGame();
          return;
        }
        
        // Check if this player is alive
        if (this.players[this.currentPlayer].alive) {
          nextPlayerFound = true;
        }
      } while (!nextPlayerFound);
      
      // Reset shot flag and AI timer for new player
      this.players[this.currentPlayer].hasShot = false;
      this.players[this.currentPlayer].aiThinkTimer = 0; // Reset AI thinking
      this.turnPhase = 'aiming';
      
      // Debug: Show whose turn it is
      const currentTank = this.players[this.currentPlayer];
      const playerType = currentTank.isPlayer ? "HUMAN" : "AI";
      console.log(`üéØ Turn ${this.currentPlayer + 1}: ${playerType} (${this.players.length} total players)`);
      
      // Generate new wind
      this.wind = (Math.random() - 0.5) * 10; // -5 to 5
    };
    
    gameState.getCurrentPlayer = function() {
      return this.players[this.currentPlayer];
    };
    
    gameState.getAlivePlayers = function() {
      return this.players.filter(p => p.alive);
    };

    // Game loop
    let lastTime = 0;
    function gameLoop(currentTime) {
      if (currentTime - lastTime >= gameState.gameSpeed) {
        handleInput();
        updateGame();
        lastTime = currentTime;
      }
      
      render();
      
      if (gameState.running) {
        requestAnimationFrame(gameLoop);
      }
    }

    // UI functions
    function showMenu() {
      gameState.running = false;
      document.getElementById('menuOverlay').classList.remove('hidden');
      document.getElementById('gameOverOverlay').classList.add('hidden');
      document.getElementById('hud').style.display = 'none';
    }

    function startGame() {
      audio.init();
      gameState.running = true;
      gameState.paused = false;
      document.getElementById('menuOverlay').classList.add('hidden');
      document.getElementById('gameOverOverlay').classList.add('hidden');
      document.getElementById('pausedOverlay').style.display = 'none';
      document.getElementById('hud').style.display = 'flex';
      
      // Set initial wind so indicator shows from start
      gameState.wind = (Math.random() - 0.5) * 10; // -5 to 5
      
      initializeGame();
      requestAnimationFrame(gameLoop);
    }

    function restartGame() {
      gameState.round = 1;
      startGame();
    }

    function goHome() {
      window.location.href = '../index.html';
    }

    async function toggleFullscreen() {
      try {
        if (!document.fullscreenElement) {
          await canvas.requestFullscreen();
        } else {
          await document.exitFullscreen();
        }
      } catch (e) {
        console.warn('Fullscreen not supported');
      }
    }

    // Game mode selection
    document.querySelectorAll('.option-card').forEach(option => {
      option.addEventListener('click', () => {
        document.querySelectorAll('.option-card').forEach(opt => opt.classList.remove('active'));
        option.classList.add('active');
        gameState.mode = option.dataset.mode;
      });
    });

    // Button event listeners
    document.getElementById('startGameBtn').addEventListener('click', startGame);
    document.getElementById('restartGameBtn').addEventListener('click', restartGame);
    document.getElementById('showMenuBtn').addEventListener('click', showMenu);

    // Initialize
    showMenu();
    
    // Handle visibility change to pause game
    document.addEventListener('visibilitychange', () => {
      if (document.hidden && gameState.running && !gameState.paused) {
        gameState.paused = true;
        document.getElementById('pausedOverlay').style.display = 'flex';
      }
    });

    // Wind indicator function
    function drawWindIndicator(ctx) {
      // Always show wind indicator, even with 0 wind
      const windX = CONFIG.CANVAS_WIDTH - 130;
      const windY = 70;
      const windWidth = 110;
      const windHeight = 50;
      
      // Create gradient background
      const gradient = ctx.createLinearGradient(windX, windY, windX, windY + windHeight);
      gradient.addColorStop(0, 'rgba(40, 44, 52, 0.95)');
      gradient.addColorStop(1, 'rgba(20, 24, 32, 0.95)');
      
      // Draw shadow
      ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
      ctx.shadowBlur = 8;
      ctx.shadowOffsetX = 2;
      ctx.shadowOffsetY = 2;
      
      // Draw rounded rectangle background
      ctx.fillStyle = gradient;
      ctx.beginPath();
      // Manual rounded rectangle
      const radius = 8;
      ctx.moveTo(windX + radius, windY);
      ctx.lineTo(windX + windWidth - radius, windY);
      ctx.quadraticCurveTo(windX + windWidth, windY, windX + windWidth, windY + radius);
      ctx.lineTo(windX + windWidth, windY + windHeight - radius);
      ctx.quadraticCurveTo(windX + windWidth, windY + windHeight, windX + windWidth - radius, windY + windHeight);
      ctx.lineTo(windX + radius, windY + windHeight);
      ctx.quadraticCurveTo(windX, windY + windHeight, windX, windY + windHeight - radius);
      ctx.lineTo(windX, windY + radius);
      ctx.quadraticCurveTo(windX, windY, windX + radius, windY);
      ctx.closePath();
      ctx.fill();
      
      // Reset shadow for other elements
      ctx.shadowColor = 'transparent';
      ctx.shadowBlur = 0;
      ctx.shadowOffsetX = 0;
      ctx.shadowOffsetY = 0;
      
      // Draw border with gradient
      const borderGradient = ctx.createLinearGradient(windX, windY, windX + windWidth, windY + windHeight);
      borderGradient.addColorStop(0, 'rgba(100, 200, 255, 0.8)');
      borderGradient.addColorStop(1, 'rgba(150, 100, 255, 0.8)');
      
      ctx.strokeStyle = borderGradient;
      ctx.lineWidth = 2;
      ctx.beginPath();
      // Manual rounded rectangle for border
      ctx.moveTo(windX + radius, windY);
      ctx.lineTo(windX + windWidth - radius, windY);
      ctx.quadraticCurveTo(windX + windWidth, windY, windX + windWidth, windY + radius);
      ctx.lineTo(windX + windWidth, windY + windHeight - radius);
      ctx.quadraticCurveTo(windX + windWidth, windY + windHeight, windX + windWidth - radius, windY + windHeight);
      ctx.lineTo(windX + radius, windY + windHeight);
      ctx.quadraticCurveTo(windX, windY + windHeight, windX, windY + windHeight - radius);
      ctx.lineTo(windX, windY + radius);
      ctx.quadraticCurveTo(windX, windY, windX + radius, windY);
      ctx.closePath();
      ctx.stroke();
      
      // Draw wind icon (cloud symbol)
      const iconX = windX + 15;
      const iconY = windY + 15;
      ctx.fillStyle = 'rgba(150, 200, 255, 0.9)';
      ctx.beginPath();
      ctx.arc(iconX, iconY, 6, 0, Math.PI * 2);
      ctx.arc(iconX + 8, iconY, 4, 0, Math.PI * 2);
      ctx.arc(iconX + 4, iconY - 3, 5, 0, Math.PI * 2);
      ctx.fill();
      
      // Draw wind text with better styling
      ctx.fillStyle = '#ffffff';
      ctx.font = 'bold 12px Arial';
      ctx.textAlign = 'left';
      ctx.fillText('WIND', windX + 35, windY + 20);
      
      // Draw wind arrow and strength
      const arrowX = windX + windWidth/2;
      const arrowY = windY + 35;
      const windStrength = Math.abs(gameState.wind);
      const arrowLength = Math.min(windStrength * 4, 35); // Scale arrow length
      
      if (windStrength < 0.1) {
        // No wind - show a calm indicator
        ctx.fillStyle = 'rgba(100, 200, 100, 0.8)';
        ctx.beginPath();
        ctx.arc(arrowX, arrowY, 4, 0, Math.PI * 2);
        ctx.fill();
        
        // Draw calm symbol (horizontal lines)
        ctx.strokeStyle = 'rgba(100, 200, 100, 0.9)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(arrowX - 8, arrowY);
        ctx.lineTo(arrowX + 8, arrowY);
        ctx.stroke();
        
        ctx.fillStyle = 'rgba(100, 200, 100, 0.9)';
        ctx.font = 'bold 11px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('CALM', arrowX, arrowY + 15);
      } else {
        // Wind present - show animated arrow
        const time = Date.now() * 0.005;
        const wiggle = Math.sin(time) * 2; // Subtle animation
        
        // Draw wind strength bar
        const barWidth = 40;
        const barHeight = 4;
        const barX = arrowX - barWidth/2;
        const barY = arrowY + 8;
        
        // Background bar
        ctx.fillStyle = 'rgba(100, 100, 100, 0.3)';
        ctx.fillRect(barX, barY, barWidth, barHeight);
        
        // Filled bar based on wind strength
        const fillWidth = (windStrength / 10) * barWidth; // Normalize to max wind of 10
        const barGradient = ctx.createLinearGradient(barX, barY, barX + fillWidth, barY);
        
        if (gameState.wind > 0) {
          // Right wind - red to orange gradient
          barGradient.addColorStop(0, '#ff6b6b');
          barGradient.addColorStop(1, '#ffa500');
        } else {
          // Left wind - blue to cyan gradient
          barGradient.addColorStop(0, '#6b6bff');
          barGradient.addColorStop(1, '#00ffff');
        }
        
        ctx.fillStyle = barGradient;
        ctx.fillRect(barX, barY, fillWidth, barHeight);
        
        // Draw animated arrow
        ctx.strokeStyle = gameState.wind > 0 ? '#ff6b6b' : '#6b6bff';
        ctx.lineWidth = 3;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        ctx.beginPath();
        
        if (gameState.wind > 0) {
          // Wind blowing right with animation
          ctx.moveTo(arrowX - arrowLength/2, arrowY + wiggle);
          ctx.lineTo(arrowX + arrowLength/2, arrowY + wiggle);
          ctx.lineTo(arrowX + arrowLength/2 - 6, arrowY + wiggle - 4);
          ctx.moveTo(arrowX + arrowLength/2, arrowY + wiggle);
          ctx.lineTo(arrowX + arrowLength/2 - 6, arrowY + wiggle + 4);
        } else {
          // Wind blowing left with animation
          ctx.moveTo(arrowX + arrowLength/2, arrowY + wiggle);
          ctx.lineTo(arrowX - arrowLength/2, arrowY + wiggle);
          ctx.lineTo(arrowX - arrowLength/2 + 6, arrowY + wiggle - 4);
          ctx.moveTo(arrowX - arrowLength/2, arrowY + wiggle);
          ctx.lineTo(arrowX - arrowLength/2 + 6, arrowY + wiggle + 4);
        }
        ctx.stroke();
        
        // Draw wind strength text with better styling
        ctx.fillStyle = '#ffffff';
        ctx.font = 'bold 12px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(`${windStrength.toFixed(1)}`, arrowX, arrowY + 25);
        
        // Draw wind direction text
        ctx.fillStyle = gameState.wind > 0 ? '#ff6b6b' : '#6b6bff';
        ctx.font = '10px Arial';
        ctx.fillText(gameState.wind > 0 ? '‚Üí EAST' : '‚Üê WEST', arrowX, arrowY + 38);
      }
    }
  </script>
</body>
</html>
