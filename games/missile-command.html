<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" />
  <title>Neon Missile Command - Defend the Cities</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');
    
    :root {
      --bg-space: #000011;
      --city-green: #00ff41;
      --missile-red: #ff0040;
      --explosion-yellow: #ffff00;
      --base-cyan: #00ffff;
      --text-light: #e6f1ff;
      --neon-purple: #8a2be2;
      --powerup-pink: #ff00ff;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    html, body {
      height: 100%;
      background: var(--bg-space);
      color: var(--text-light);
      font-family: 'Orbitron', monospace;
      overflow: visible;
      user-select: none;
      -webkit-user-select: none;
      touch-action: none;
      margin: 0;
      padding: 0;
      position: relative;
    }

    #gameContainer {
      position: fixed;
      inset: 0;
      display: grid;
      place-items: center;
      background: 
        radial-gradient(circle at 20% 30%, rgba(0, 255, 65, 0.1) 0%, transparent 30%),
        radial-gradient(circle at 80% 70%, rgba(255, 0, 64, 0.1) 0%, transparent 30%),
        radial-gradient(circle at 50% 20%, rgba(0, 255, 255, 0.05) 0%, transparent 40%);
    }

    canvas {
      border: 4px solid var(--base-cyan);
      border-radius: 15px;
      background: 
        radial-gradient(2px 2px at 20% 30%, white, transparent),
        radial-gradient(2px 2px at 40% 70%, white, transparent),
        radial-gradient(1px 1px at 90% 40%, white, transparent),
        radial-gradient(1px 1px at 70% 90%, white, transparent),
        var(--bg-space);
      background-size: 200px 200px, 300px 300px, 150px 150px, 250px 250px;
      box-shadow: 
        0 0 50px rgba(0, 255, 255, 0.5),
        inset 0 0 50px rgba(0, 255, 255, 0.1);
      cursor: crosshair;
      z-index: 1;
    }

    .overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      display: flex;
      justify-content: center;
      align-items: center;
      background: rgba(0, 0, 17, 0.95);
      backdrop-filter: blur(12px);
      overflow-y: auto;
      padding: 20px 0;
      z-index: 100;
      min-height: 100vh;
      min-width: 100vw;
    }

    .menu-card {
      background: rgba(0, 0, 0, 0.9);
      border: 5px solid yellow;
      border-radius: 25px;
      padding: 30px;
      text-align: center;
      max-width: 650px;
      width: 90vw;
      min-height: 400px;
      overflow-y: auto;
      box-shadow: 
        0 0 60px rgba(255, 255, 0, 0.8),
        inset 0 0 40px rgba(255, 255, 0, 0.2);
      position: relative;
    }

    .game-over-card {
      border-color: #ff0040;
      box-shadow: 
        0 0 80px rgba(255, 0, 64, 0.9),
        inset 0 0 50px rgba(255, 0, 64, 0.3);
      animation: game-over-pulse 2s ease-in-out infinite;
    }

    .game-over-title {
      color: #ff0040 !important;
      text-shadow: 0 0 50px rgba(255, 0, 64, 0.9) !important;
      font-size: 4rem !important;
      animation: game-over-title-glow 1.5s ease-in-out infinite alternate;
    }

    .game-over-subtitle {
      color: #ff6b6b;
      font-size: 1.5rem;
      margin: 20px 0;
      text-shadow: 0 0 20px rgba(255, 107, 107, 0.8);
      animation: subtitle-pulse 2s ease-in-out infinite;
    }

    @keyframes subtitle-pulse {
      0%, 100% { opacity: 0.8; }
      50% { opacity: 1; }
    }

    .restart-btn {
      background: linear-gradient(135deg, #00ff41, #00cc33);
      border-color: #00ff41;
      box-shadow: 0 0 30px rgba(0, 255, 65, 0.6);
    }

    .restart-btn:hover {
      background: linear-gradient(135deg, #00cc33, #009926);
      box-shadow: 0 0 40px rgba(0, 255, 65, 0.8);
    }

    .menu-btn {
      background: linear-gradient(135deg, #00ffff, #00cccc);
      border-color: #00ffff;
      box-shadow: 0 0 30px rgba(0, 255, 255, 0.6);
    }

    .menu-btn:hover {
      background: linear-gradient(135deg, #00cccc, #009999);
      box-shadow: 0 0 40px rgba(0, 255, 255, 0.8);
    }

    .title {
      font-size: 3rem;
      font-weight: 900;
      margin-bottom: 15px;
      color: white;
      text-shadow: 0 0 20px red, 0 0 40px red;
      animation: gradient-flow 4s ease-in-out infinite;
    }

    @keyframes gradient-flow {
      0% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
      100% { background-position: 0% 50%; }
    }

    @keyframes game-over-pulse {
      0%, 100% { 
        box-shadow: 0 0 80px rgba(255, 0, 64, 0.9), inset 0 0 50px rgba(255, 0, 64, 0.3);
      }
      50% { 
        box-shadow: 0 0 120px rgba(255, 0, 64, 1), inset 0 0 70px rgba(255, 0, 64, 0.5);
      }
    }

    @keyframes game-over-title-glow {
      0% { 
        text-shadow: 0 0 50px rgba(255, 0, 64, 0.9), 0 0 100px rgba(255, 0, 64, 0.6);
      }
      100% { 
        text-shadow: 0 0 70px rgba(255, 0, 64, 1), 0 0 140px rgba(255, 0, 64, 0.8);
      }
    }

    .subtitle {
      color: var(--text-light);
      margin-bottom: 25px;
      font-size: 1.2rem;
      opacity: 0.9;
    }

    .game-modes {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 20px;
      margin-bottom: 30px;
    }

    .mode-card {
      background: linear-gradient(135deg, rgba(0, 255, 65, 0.1), rgba(255, 0, 64, 0.1));
      border: 2px solid var(--base-cyan);
      border-radius: 20px;
      padding: 20px;
      text-align: center;
      cursor: pointer;
      transition: all 0.3s ease;
      backdrop-filter: blur(10px);
    }

    .mode-card:hover {
      transform: translateY(-5px);
      border-color: var(--city-green);
      box-shadow: 0 10px 30px rgba(0, 255, 65, 0.3);
    }

    .mode-card.active {
      border-color: var(--city-green);
      background: linear-gradient(135deg, rgba(0, 255, 65, 0.2), rgba(255, 0, 64, 0.2));
      box-shadow: 0 0 30px rgba(0, 255, 65, 0.4);
    }

    .mode-title {
      font-size: 1.3rem;
      font-weight: 700;
      margin-bottom: 10px;
      color: var(--city-green);
      text-shadow: 0 0 15px rgba(0, 255, 65, 0.6);
    }

    .mode-desc {
      font-size: 0.9rem;
      color: var(--text-light);
      line-height: 1.4;
    }

    .btn {
      background: linear-gradient(135deg, var(--base-cyan), var(--powerup-pink));
      border: none;
      border-radius: 18px;
      padding: 16px 35px;
      color: var(--bg-space);
      font-family: inherit;
      font-weight: 700;
      font-size: 1.3rem;
      cursor: pointer;
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
      margin: 15px;
      text-transform: uppercase;
      letter-spacing: 2px;
    }

    .btn:hover {
      transform: translateY(-4px) scale(1.05);
      box-shadow: 0 25px 50px rgba(0, 255, 255, 0.4);
    }

    .btn:active {
      transform: translateY(-2px) scale(1.02);
    }

    #gameCanvas {
      border: 2px solid var(--base-cyan);
      border-radius: 10px;
      box-shadow: 0 0 30px rgba(0, 255, 255, 0.3);
      cursor: crosshair;
      outline: none;
    }

    #gameCanvas:focus {
      border-color: var(--city-green);
      box-shadow: 0 0 40px rgba(0, 255, 65, 0.5);
    }

    .controls-info {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 15px;
      margin-bottom: 20px;
    }

    .control-section {
      background: rgba(0, 0, 0, 0.4);
      border: 1px solid rgba(0, 255, 255, 0.3);
      border-radius: 12px;
      padding: 12px;
    }

    .control-title {
      color: var(--base-cyan);
      font-weight: 700;
      margin-bottom: 8px;
      font-size: 1.1rem;
    }

    .kbd {
      display: inline-block;
      padding: 3px 8px;
      background: rgba(0, 255, 255, 0.2);
      border: 1px solid rgba(0, 255, 255, 0.4);
      border-radius: 5px;
      font-size: 0.85rem;
      margin: 2px;
      font-weight: 600;
    }

    .hud {
      position: absolute;
      top: 60px;
      left: 20px;
      right: 80px;
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      font-weight: 700;
      pointer-events: none;
      z-index: 10;
    }

    .hud-panel {
      background: rgba(0, 0, 17, 0.8);
      border: 2px solid var(--base-cyan);
      border-radius: 15px;
      padding: 18px 25px;
      backdrop-filter: blur(10px);
      min-width: 200px;
    }

    .hud-item {
      margin-bottom: 10px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .hud-label {
      color: var(--base-cyan);
      font-size: 1rem;
    }

    .hud-value {
      color: var(--text-light);
      font-size: 1.3rem;
      font-weight: 900;
    }

    .back-btn {
      position: absolute;
      bottom: 20px;
      left: 20px;
      background: rgba(255, 0, 64, 0.2);
      border: 2px solid var(--missile-red);
      border-radius: 15px;
      padding: 15px 22px;
      color: var(--missile-red);
      font-family: inherit;
      font-weight: 700;
      cursor: pointer;
      transition: all 0.3s ease;
      z-index: 20;
    }

    .back-btn:hover {
      background: rgba(255, 0, 64, 0.3);
      transform: translateY(-3px);
      box-shadow: 0 12px 30px rgba(255, 0, 64, 0.3);
    }

    .paused-overlay {
      position: absolute;
      inset: 0;
      background: rgba(0, 0, 17, 0.8);
      display: none;
      align-items: center;
      justify-content: center;
      font-size: 3.5rem;
      font-weight: 900;
      color: var(--base-cyan);
      text-shadow: 0 0 50px rgba(0, 255, 255, 0.8);
      backdrop-filter: blur(10px);
    }

    .touch-controls {
      position: absolute;
      bottom: 30px;
      left: 30px;
      right: 30px;
      display: none;
      justify-content: space-between;
      align-items: center;
    }

    .touch-actions {
      display: flex;
      gap: 15px;
    }

    .touch-btn {
      background: rgba(0, 255, 255, 0.3);
      border: 2px solid var(--base-cyan);
      border-radius: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.4rem;
      color: var(--base-cyan);
      font-weight: 700;
      cursor: pointer;
      transition: all 0.2s ease;
      user-select: none;
      -webkit-user-select: none;
      touch-action: manipulation;
      width: 80px;
      height: 80px;
    }

    .touch-btn:active {
      background: rgba(0, 255, 255, 0.5);
      transform: scale(0.95);
    }

    .touch-btn.fire {
      border-radius: 50%;
      background: rgba(255, 255, 0, 0.3);
      border: 3px solid var(--explosion-yellow);
      color: var(--explosion-yellow);
      font-size: 1.8rem;
    }

    .touch-btn.smart-bomb {
      background: rgba(255, 0, 255, 0.3);
      border: 2px solid var(--powerup-pink);
      color: var(--powerup-pink);
      font-size: 1.2rem;
    }

    @media (max-width: 768px) {
      .touch-controls {
        display: flex;
      }
      
      .menu-card {
        padding: 20px;
        margin: 10px;
      }
      
      .title {
        font-size: 2.5rem;
        margin-bottom: 10px;
      }
      
      .subtitle {
        font-size: 1.1rem;
        margin-bottom: 20px;
      }
      
      .game-modes {
        grid-template-columns: 1fr;
        gap: 15px;
        margin-bottom: 20px;
      }
      
      .controls-info {
        grid-template-columns: 1fr;
        gap: 10px;
        margin-bottom: 15px;
      }
      
      .control-section {
        padding: 10px;
      }
      
      .control-title {
        font-size: 1rem;
        margin-bottom: 6px;
      }
      
      .back-btn {
        right: 20px;
      }
    }

    @media (max-width: 480px) {
      .menu-card {
        padding: 15px;
        margin: 5px;
      }
      
      .title {
        font-size: 2.2rem;
        margin-bottom: 8px;
      }
      
      .subtitle {
        font-size: 1rem;
        margin-bottom: 15px;
      }
      
      .game-modes {
        gap: 12px;
        margin-bottom: 15px;
      }
      
      .mode-card {
        padding: 15px 12px;
      }
      
      .mode-title {
        font-size: 1.1rem;
        margin-bottom: 6px;
      }
      
      .mode-desc {
        font-size: 0.8rem;
      }
      
      .controls-info {
        gap: 8px;
        margin-bottom: 12px;
      }
      
      .control-section {
        padding: 8px;
      }
      
      .control-title {
        font-size: 0.95rem;
        margin-bottom: 5px;
      }
      
      .kbd {
        padding: 2px 6px;
        font-size: 0.8rem;
        margin: 1px;
      }
      
      .btn {
        padding: 14px 28px;
        font-size: 1.2rem;
      }
    }

    .hidden {
      display: none !important;
    }

    .home-btn {
      position: fixed;
      width: 130px;
      height: 30px;
      bottom: 20px;
      left: 20px;
      background: linear-gradient(135deg, #ff0040, #ff2056);
      border: 2px solid #ff4070;
      border-radius: 8px;
      padding: 8px 16px;
      color: white;
      font-family: 'Orbitron', monospace;
      font-weight: 700;
      font-size: 0.85rem;
      cursor: pointer;
      transition: all 0.3s ease;
      z-index: 1000;
      text-decoration: none;
      display: flex;
      align-items: center;
      gap: 6px;
      backdrop-filter: blur(8px);
      box-shadow: 
        0 2px 10px rgba(255, 0, 64, 0.4),
        inset 0 0 15px rgba(255, 255, 255, 0.1);
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .home-btn:hover {
      background: linear-gradient(135deg, #ff2060, #ff4080);
      border-color: #ff6090;
      transform: translateY(-1px);
      box-shadow: 
        0 4px 15px rgba(255, 0, 64, 0.6),
        inset 0 0 20px rgba(255, 255, 255, 0.15);
    }

    .home-btn:active {
      transform: translateY(0px);
    }

    /* Hide external/injected home buttons in top area */
    *[style*="position: fixed"][style*="top"],
    *[style*="position: absolute"][style*="top"] {
      z-index: -1 !important;
    }

    /* Target elements that appear in top-right corner */
    body > *:not(#gameContainer):not(.home-btn):not(script) {
      position: static !important;
      top: auto !important;
      right: auto !important;
      z-index: -1 !important;
    }

    .score-popup {
      position: absolute;
      color: var(--explosion-yellow);
      font-weight: 700;
      font-size: 1.2rem;
      pointer-events: none;
      animation: score-rise 1s ease-out forwards;
      font-family: 'Orbitron', monospace;
      text-shadow: 0 0 10px rgba(255, 255, 0, 0.8);
      z-index: 50;
    }

    @keyframes score-rise {
      0% {
        opacity: 1;
        transform: translateY(0) scale(1);
      }
      100% {
        opacity: 0;
        transform: translateY(-50px) scale(1.2);
      }
    }

    /* HUD Styles */
    .hud {
      position: absolute;
      top: 20px;
      left: 20px;
      right: 20px;
      display: flex;
      justify-content: space-between;
      pointer-events: none;
      z-index: 100;
    }

    .hud-panel {
      background: rgba(0, 0, 17, 0.8);
      border: 2px solid var(--base-cyan);
      border-radius: 15px;
      padding: 15px 20px;
      backdrop-filter: blur(10px);
      box-shadow: 0 0 30px rgba(0, 255, 255, 0.3);
    }

    .hud-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
      min-width: 120px;
    }

    .hud-item:last-child {
      margin-bottom: 0;
    }

    .hud-label {
      color: var(--text-light);
      font-size: 0.9rem;
      font-weight: 400;
    }

    .hud-value {
      color: var(--city-green);
      font-size: 1.1rem;
      font-weight: 700;
      text-shadow: 0 0 10px rgba(0, 255, 65, 0.6);
    }

    /* Back Button */
    .back-btn {
      position: absolute;
      top: 20px;
      right: 20px;
      background: linear-gradient(135deg, var(--missile-red), #ff2056);
      border: 2px solid #ff4070;
      border-radius: 12px;
      padding: 12px 20px;
      color: white;
      font-family: 'Orbitron', monospace;
      font-weight: 700;
      font-size: 1rem;
      cursor: pointer;
      transition: all 0.3s ease;
      z-index: 1000;
      text-decoration: none;
      display: flex;
      align-items: center;
      gap: 8px;
      backdrop-filter: blur(8px);
      box-shadow: 
        0 4px 15px rgba(255, 0, 64, 0.4),
        inset 0 0 20px rgba(255, 255, 255, 0.1);
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .back-btn:hover {
      background: linear-gradient(135deg, #ff2060, #ff4080);
      border-color: #ff6090;
      transform: translateY(-2px);
      box-shadow: 
        0 6px 20px rgba(255, 0, 64, 0.6),
        inset 0 0 25px rgba(255, 255, 255, 0.15);
    }

    .back-btn:active {
      transform: translateY(0px);
    }

    /* Paused Overlay */
    .paused-overlay {
      position: absolute;
      inset: 0;
      display: none;
      place-items: center;
      background: rgba(0, 0, 17, 0.9);
      backdrop-filter: blur(12px);
      z-index: 200;
      font-family: 'Orbitron', monospace;
      font-size: 2rem;
      font-weight: 900;
      color: var(--base-cyan);
      text-align: center;
      text-shadow: 0 0 30px rgba(0, 255, 255, 0.8);
    }

    /* Touch Controls */
    .touch-controls {
      position: absolute;
      bottom: 30px;
      right: 30px;
      display: none;
      z-index: 100;
    }

    .touch-actions {
      display: flex;
      gap: 20px;
    }

    .touch-btn {
      width: 60px;
      height: 60px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.5rem;
      cursor: pointer;
      transition: all 0.3s ease;
      user-select: none;
      -webkit-user-select: none;
    }

    .touch-btn.fire {
      background: linear-gradient(135deg, var(--missile-red), #ff2056);
      border: 3px solid #ff4070;
      box-shadow: 
        0 4px 15px rgba(255, 0, 64, 0.4),
        inset 0 0 20px rgba(255, 255, 255, 0.1);
    }

    .touch-btn.smart-bomb {
      background: linear-gradient(135deg, var(--powerup-pink), #ff20ff);
      border: 3px solid #ff40ff;
      box-shadow: 
        0 4px 15px rgba(255, 0, 255, 0.4),
        inset 0 0 20px rgba(255, 255, 255, 0.1);
    }

    .touch-btn:hover {
      transform: scale(1.1);
    }

    .touch-btn:active {
      transform: scale(0.95);
    }

    /* Responsive Design */
    @media (max-width: 1200px) {
      .menu-card {
        max-width: 90vw;
        width: 95vw;
        padding: 25px;
      }
      
      .title {
        font-size: 2.5rem;
      }
      
      .game-modes {
        grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
        gap: 15px;
      }
      
      .mode-card {
        padding: 15px;
      }
      
      .mode-title {
        font-size: 1.1rem;
      }
      
      .controls-info {
        grid-template-columns: 1fr;
        gap: 15px;
      }
    }

    @media (max-width: 768px) {
      .hud {
        top: 10px;
        left: 10px;
        right: 10px;
      }

      .hud-panel {
        padding: 10px 15px;
      }

      .hud-item {
        min-width: 100px;
      }

      .hud-label {
        font-size: 0.8rem;
      }

      .hud-value {
        font-size: 1rem;
      }      

      .touch-controls {
        bottom: 20px;
        right: 20px;
      }

      .touch-btn {
        width: 50px;
        height: 50px;
        font-size: 1.2rem;
      }
      
      /* Menu responsive adjustments */
      .menu-card {
        padding: 20px;
        margin: 10px;
      }
      
      .title {
        font-size: 2rem;
        margin-bottom: 10px;
      }
      
      .subtitle {
        font-size: 1rem;
        margin-bottom: 20px;
      }
      
      .game-modes {
        grid-template-columns: 1fr;
        gap: 15px;
        margin-bottom: 20px;
      }
      
      .mode-card {
        padding: 15px;
      }
      
      .mode-title {
        font-size: 1rem;
      }
      
      .mode-desc {
        font-size: 0.8rem;
      }
      
      .controls-info {
        grid-template-columns: 1fr;
        gap: 15px;
      }
      
      .control-section {
        padding: 15px;
      }
      
      .control-title {
        font-size: 1rem;
      }
      
      .btn {
        padding: 14px 28px;
        font-size: 1rem;
      }
    }

    @media (max-width: 480px) {
      .hud {
        top: 5px;
        left: 5px;
        right: 5px;
      }

      .hud-panel {
        padding: 8px 12px;
      }

      .hud-item {
        min-width: 80px;
        margin-bottom: 5px;
      }

      .hud-label {
        font-size: 0.7rem;
      }

      .hud-value {
        font-size: 0.9rem;
      }
      

      .touch-controls {
        bottom: 15px;
        right: 15px;
      }

      .touch-btn {
        width: 45px;
        height: 45px;
        font-size: 1rem;
      }
      
      /* Menu responsive adjustments for very small screens */
      .menu-card {
        padding: 15px;
        margin: 5px;
        border-radius: 15px;
      }
      
      .title {
        font-size: 1.5rem;
        margin-bottom: 8px;
      }
      
      .subtitle {
        font-size: 0.9rem;
        margin-bottom: 15px;
      }
      
      .game-modes {
        gap: 10px;
        margin-bottom: 15px;
      }
      
      .mode-card {
        padding: 12px;
        border-radius: 15px;
      }
      
      .mode-title {
        font-size: 0.9rem;
        margin-bottom: 8px;
      }
      
      .mode-desc {
        font-size: 0.75rem;
        line-height: 1.3;
      }
      
      .controls-info {
        gap: 10px;
      }
      
      .control-section {
        padding: 12px;
        border-radius: 12px;
      }
      
      .control-title {
        font-size: 0.9rem;
        margin-bottom: 8px;
      }
      
      .kbd {
        padding: 2px 6px;
        font-size: 0.7rem;
      }
      
      .btn {
        padding: 12px 24px;
        font-size: 0.9rem;
        border-radius: 15px;
      }
    }

    /* Landscape orientation adjustments */
    @media (max-height: 600px) and (orientation: landscape) {
      .menu-card {
        max-height: 80vh;
        padding: 20px;
      }
      
      .title {
        font-size: 1.8rem;
        margin-bottom: 10px;
      }
      
      .subtitle {
        font-size: 0.9rem;
        margin-bottom: 15px;
      }
      
      .game-modes {
        grid-template-columns: repeat(2, 1fr);
        gap: 15px;
        margin-bottom: 15px;
      }
      
      .controls-info {
        grid-template-columns: repeat(2, 1fr);
        gap: 15px;
      }
      
      .btn {
        padding: 12px 24px;
        font-size: 0.9rem;
      }
    }

    /* High DPI displays */
    @media (-webkit-min-device-pixel-ratio: 2), (min-resolution: 192dpi) {
      .title {
        text-shadow: 0 0 30px red, 0 0 60px red;
      }
      
      .mode-title {
        text-shadow: 0 0 20px rgba(0, 255, 65, 0.8);
      }
      
      .btn {
        box-shadow: 
          0 6px 20px rgba(0, 255, 255, 0.5),
          inset 0 0 20px rgba(255, 255, 255, 0.1);
      }
    }

    /* Touch-friendly improvements */
    @media (pointer: coarse) {
      .btn {
        min-height: 44px;
        min-width: 44px;
      }
      
      .mode-card {
        min-height: 60px;
        cursor: pointer;
      }
      
      .touch-btn {
        min-width: 60px;
        min-height: 60px;
      }
    }

    /* Safe area support for notched devices */
    @supports (padding: max(0px)) {
      .overlay {
        padding-left: max(20px, env(safe-area-inset-left));
        padding-right: max(20px, env(safe-area-inset-right));
        padding-top: max(20px, env(safe-area-inset-top));
        padding-bottom: max(20px, env(safe-area-inset-bottom));
      }
      
      .touch-controls {
        bottom: max(20px, env(safe-area-inset-bottom) + 10px);
        right: max(20px, env(safe-area-inset-right) + 10px);
      }
    }

    /* Print styles */
    @media print {
      .overlay, .hud, .touch-controls {
        display: none !important;
      }
      
      canvas {
        border: 2px solid #000;
        box-shadow: none;
      }
    }
  </style>
</head>
  <body>    
    <div id="gameContainer">
    
    <canvas id="gameCanvas" width="1000" height="700" tabindex="0"></canvas>
    <div class="hud" id="hud" style="display: none;">
      <div class="hud-panel">
        <div class="hud-item">
          <span class="hud-label">Score:</span>
          <span class="hud-value" id="scoreDisplay">0</span>
        </div>
        <div class="hud-item">
          <span class="hud-label">Wave:</span>
          <span class="hud-value" id="waveDisplay">1</span>
        </div>
        <div class="hud-item">
          <span class="hud-label">Cities:</span>
          <span class="hud-value" id="citiesDisplay">6</span>
        </div>
      </div>
      
      <div class="hud-panel">
        <div class="hud-item">
          <span class="hud-label">High Score:</span>
          <span class="hud-value" id="highScoreDisplay">0</span>
        </div>
        <div class="hud-item">
          <span class="hud-label">Missiles:</span>
          <span class="hud-value" id="missilesDisplay">0</span>
        </div>
        <div class="hud-item">
          <span class="hud-label">Smart Bombs:</span>
          <span class="hud-value" id="smartBombsDisplay">3</span>
        </div>
      </div>
    </div>

    <button class="home-btn" onclick="goHome()" title="Back to Main Menu">
      ← HOME
    </button>

    <div class="paused-overlay" id="pausedOverlay">
      <div>PAUSED<br><small style="font-size: 1.2rem;">Press P or Start to resume</small></div>
    </div>

    <div class="touch-controls" id="touchControls">
      <div class="touch-actions">
        <div class="touch-btn fire" data-action="fire">🔥</div>
        <div class="touch-btn smart-bomb" data-action="smart-bomb">💣</div>
      </div>
    </div>

    <!-- Menu overlay -->
    <div class="overlay" id="menuOverlay" style="display: flex;">
      <div class="menu-card">
        <h1 class="title">MISSILE COMMAND</h1>
        <p class="subtitle">Defend your cities from incoming missiles!</p>
        
        <div class="game-modes">
          <div class="mode-card active" data-mode="classic">
            <div class="mode-title">🏙️ CLASSIC</div>
            <div class="mode-desc">Traditional missile defense<br>6 cities to protect<br>Balanced difficulty progression</div>
          </div>
          <div class="mode-card" data-mode="survival">
            <div class="mode-title">💀 SURVIVAL</div>
            <div class="mode-desc">Endless waves<br>No city respawns<br>Ultimate challenge</div>
          </div>
          <div class="mode-card" data-mode="cooperative">
            <div class="mode-title">🤝 CO-OP</div>
            <div class="mode-desc">2-player defense<br>Shared cities<br>Combined score</div>
          </div>
          <div class="mode-card" data-mode="time-attack">
            <div class="mode-title">⏱️ TIME ATTACK</div>
            <div class="mode-desc">Survive 5 minutes<br>Bonus points<br>Speed challenge</div>
          </div>
        </div>

        <div class="controls-info">
          <div class="control-section">
            <div class="control-title">Game Controls</div>
            <div>
              <span class="kbd">Mouse</span> or <span class="kbd">Touch</span> Aim<br>
              <span class="kbd">Click</span> or <span class="kbd">Tap</span> Fire<br>
              <span class="kbd">Space</span> Smart Bomb
            </div>
          </div>
          <div class="control-section">
            <div class="control-title">Game Controls</div>
            <div>
              <span class="kbd">P</span> Pause • <span class="kbd">F</span> Fullscreen<br>
              <span class="kbd">R</span> Restart Wave<br>
              📱 Touch Controls Available
            </div>
          </div>
          <div class="control-section">
            <div class="control-title">Objective</div>
            <div>
              🎯 Destroy incoming missiles<br>
              🏙️ Protect your cities<br>
              💣 Use smart bombs wisely<br>
              🌟 Easier to start, gradual difficulty
            </div>
          </div>
        </div>

        <button class="btn" onclick="startGame()">LAUNCH DEFENSE</button>
      </div>
    </div>

    <!-- Game Over overlay -->
    <div class="overlay" id="gameOverOverlay" style="display: none;">
      <div class="menu-card game-over-card">
        <h1 class="title game-over-title">GAME OVER</h1>
        <div class="game-over-subtitle">Your cities have been destroyed!</div>
        <div id="finalStats" style="margin: 30px 0; font-size: 1.4rem;"></div>
        <div style="display: flex; gap: 20px; justify-content: center; flex-wrap: wrap;">
          <button class="btn restart-btn" onclick="restartGame()">PLAY AGAIN</button>
          <button class="btn menu-btn" onclick="showMenu()">MAIN MENU</button>
        </div>
      </div>
    </div>
  </div>

  <script>
    // Game configuration with balanced difficulty progression
    // - Initial missile speed: 1.2 (reduced from 2.0 for easier start)
    // - Initial missiles per wave: 4 (reduced from 8 for easier start)
    // - Speed increase: 5% per wave (reduced from 10% for gradual progression)
    // - Missile count increase: +1 every 2 waves (more gradual than +1 per wave)
    const CONFIG = {
      CANVAS_WIDTH: 1000,
      CANVAS_HEIGHT: 700,
      CITY_SIZE: 15,
      MISSILE_SPEED: 0.8, // Reduced from 1.2 for slower initial speed
      EXPLOSION_RADIUS: 60,
      EXPLOSION_DURATION: 30,
      SMART_BOMB_RADIUS: 200,
      INITIAL_CITIES: 6,
      INITIAL_SMART_BOMBS: 3,
      MISSILES_PER_WAVE: 3, // Reduced from 4 for easier start
      WAVE_DELAY: 5000, // Increased from 3000 for longer delay between waves
      COLORS: {
        city: '#00ff41',
        missile: '#ff0040',
        explosion: '#ffff00',
        base: '#00ffff',
        powerup: '#ff00ff',
        background: '#000011'
      }
    };

    // Game state
    let gameState = {
      running: false,
      paused: false,
      mode: 'classic',
      wave: 1,
      score: 0,
      highScore: 0,
      cities: CONFIG.INITIAL_CITIES,
      smartBombs: CONFIG.INITIAL_SMART_BOMBS,
      missiles: [],
      explosions: [],
      particles: [],
      gameSpeed: 16,
      lastUpdateTime: 0,
      pausePressed: false,
      fullscreenPressed: false,
      restartPressed: false,
      smartBombPressed: false,
      waveTimer: 0,
      missileSpawnTimer: 0,
      missilesSpawned: 0,
      missilesPerWave: CONFIG.MISSILES_PER_WAVE,
      cityPositions: [],
      basePositions: [],
      timeAttackTimer: 300, // 5 minutes for time attack mode
      timeAttackMode: false,
      rapidFire: false,
      rapidFireTimer: 0,
      combo: 0,
      comboTimer: 0,
      gameLoopRunning: false
    };

    // Input handling
    class InputManager {
      constructor() {
        this.keys = new Set();
        this.mouseX = 0;
        this.mouseY = 0;
        this.mousePressed = false;
        this.touchActions = new Set();
        this.setupEventListeners();
      }

      setupEventListeners() {
        // Keyboard events
        document.addEventListener('keydown', (e) => {
          console.log('Key pressed:', e.code);
          this.keys.add(e.code);
          if (['Space', 'KeyP', 'KeyF', 'KeyR'].includes(e.code)) {
            e.preventDefault();
            console.log('Prevented default for:', e.code);
          }
        });

        document.addEventListener('keyup', (e) => {
          this.keys.delete(e.code);
        });

        // Mouse events
        const canvas = document.getElementById('gameCanvas');
        canvas.addEventListener('mousemove', (e) => {
          const rect = canvas.getBoundingClientRect();
          this.mouseX = e.clientX - rect.left;
          this.mouseY = e.clientY - rect.top;
        });

        canvas.addEventListener('mousedown', (e) => {
          this.mousePressed = true;
          // Focus canvas to receive keyboard events
          canvas.focus();
          if (e.button === 0) { // Left click
            fireAtPosition(this.mouseX, this.mouseY);
          }
        });

        // Ensure canvas is focused when game starts
        canvas.addEventListener('focus', () => {
          console.log('Canvas focused - keyboard events should work now');
        });

        canvas.addEventListener('blur', () => {
          console.log('Canvas lost focus');
        });

        canvas.addEventListener('mouseup', () => {
          this.mousePressed = false;
        });

        // Touch events
        canvas.addEventListener('touchstart', (e) => {
          e.preventDefault();
          const rect = canvas.getBoundingClientRect();
          const touch = e.touches[0];
          this.mouseX = touch.clientX - rect.left;
          this.mouseY = touch.clientY - rect.top;
          fireAtPosition(this.mouseX, this.mouseY);
        });

        // Touch controls
        document.querySelectorAll('.touch-btn').forEach(btn => {
          const action = btn.dataset.action;
          if (action) {
            btn.addEventListener('touchstart', (e) => {
              e.preventDefault();
              this.touchActions.add(action);
              if (action === 'fire') {
                fireAtPosition(this.mouseX, this.mouseY);
              } else if (action === 'smart-bomb') {
                useSmartBomb();
              }
            });
            
            btn.addEventListener('touchend', (e) => {
              e.preventDefault();
              this.touchActions.delete(action);
            });
          }
        });
      }

      isPausePressed() {
        return this.keys.has('KeyP');
      }

      isFullscreenPressed() {
        return this.keys.has('KeyF');
      }

      isRestartPressed() {
        return this.keys.has('KeyR');
      }

      isSmartBombPressed() {
        const spacePressed = this.keys.has('Space');
        const touchPressed = this.touchActions.has('smart-bomb');
        if (spacePressed) {
          console.log('Space key detected for smart bomb');
        }
        return spacePressed || touchPressed;
      }
    }

    // Audio system
    class AudioManager {
      constructor() {
        this.context = null;
        this.enabled = false;
      }

      async init() {
        try {
          this.context = new (window.AudioContext || window.webkitAudioContext)();
          if (this.context.state === 'suspended') {
            await this.context.resume();
          }
          this.enabled = true;
        } catch (e) {
          console.warn('Audio not available');
        }
      }

      playTone(frequency, duration = 0.1, type = 'square', volume = 0.1) {
        if (!this.enabled || !this.context) return;

        const oscillator = this.context.createOscillator();
        const gainNode = this.context.createGain();

        oscillator.connect(gainNode);
        gainNode.connect(this.context.destination);

        oscillator.frequency.value = frequency;
        oscillator.type = type;
        gainNode.gain.value = volume;

        oscillator.start();
        oscillator.stop(this.context.currentTime + duration);
      }

      playFire() {
        this.playTone(800, 0.1, 'square', 0.1);
      }

      playExplosion() {
        this.playTone(150, 0.3, 'sawtooth', 0.15);
        setTimeout(() => this.playTone(100, 0.2, 'sawtooth', 0.1), 100);
      }

      playMissileHit() {
        this.playTone(440, 0.15, 'triangle', 0.12);
      }

      playSmartBomb() {
        for (let i = 0; i < 8; i++) {
          setTimeout(() => {
            this.playTone(2000 - i * 200, 0.05, 'sine', 0.08);
          }, i * 30);
        }
      }

      playCityDestroyed() {
        for (let i = 0; i < 5; i++) {
          setTimeout(() => {
            this.playTone(200 + i * 100, 0.2, 'sawtooth', 0.15);
          }, i * 100);
        }
      }
    }

    // Game entities
    class Missile {
      constructor(x, y, targetX, targetY) {
        this.x = x;
        this.y = y;
        this.targetX = targetX;
        this.targetY = targetY;
        this.speed = CONFIG.MISSILE_SPEED;
        this.angle = Math.atan2(targetY - y, targetX - x);
        this.vx = Math.cos(this.angle) * this.speed;
        this.vy = Math.sin(this.angle) * this.speed;
        this.trail = [];
        this.destroyed = false;
      }

      update() {
        if (this.destroyed) return false;

        this.x += this.vx;
        this.y += this.vy;

        // Add to trail
        this.trail.push({ x: this.x, y: this.y });
        if (this.trail.length > 8) {
          this.trail.shift();
        }

        // Check if missile reached target
        const distanceToTarget = Math.hypot(this.x - this.targetX, this.y - this.targetY);
        if (distanceToTarget < 10) {
          this.destroyed = true;
          return false;
        }

        return true;
      }

      render(ctx) {
        if (this.destroyed) return;

        // Draw trail
        if (this.trail.length > 1) {
          ctx.strokeStyle = CONFIG.COLORS.missile;
          ctx.lineWidth = 2;
          ctx.shadowColor = CONFIG.COLORS.missile;
          ctx.shadowBlur = 8;
          
          ctx.beginPath();
          for (let i = 0; i < this.trail.length; i++) {
            const alpha = i / this.trail.length;
            ctx.globalAlpha = alpha;
            if (i === 0) {
              ctx.moveTo(this.trail[i].x, this.trail[i].y);
            } else {
              ctx.lineTo(this.trail[i].x, this.trail[i].y);
            }
          }
          ctx.stroke();
          ctx.globalAlpha = 1;
          ctx.shadowBlur = 0;
        }

        // Draw missile
        ctx.fillStyle = CONFIG.COLORS.missile;
        ctx.shadowColor = CONFIG.COLORS.missile;
        ctx.shadowBlur = 10;
        ctx.beginPath();
        ctx.arc(this.x, this.y, 3, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
      }
    }

    class Explosion {
      constructor(x, y, radius, duration) {
        this.x = x;
        this.y = y;
        this.radius = radius;
        this.maxRadius = radius;
        this.duration = duration;
        this.maxDuration = duration;
        this.particles = [];
        
        // Create explosion particles
        for (let i = 0; i < 35; i++) { // Increased from 20 to 35 particles
          const angle = (Math.PI * 2 * i) / 35;
          const speed = 3 + Math.random() * 5; // Increased speed range
          this.particles.push({
            x: this.x,
            y: this.y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            life: duration + Math.random() * 30 // Increased random life variation
          });
        }
      }

      update() {
        this.duration--;
        this.radius = this.maxRadius * (this.duration / this.maxDuration);

        // Update particles
        this.particles.forEach(particle => {
          particle.x += particle.vx;
          particle.y += particle.vy;
          particle.vx *= 0.98;
          particle.vy *= 0.98;
          particle.life--;
        });

        this.particles = this.particles.filter(p => p.life > 0);

        return this.duration > 0;
      }

      render(ctx) {
        // Draw explosion circle
        const alpha = this.duration / this.maxDuration;
        ctx.globalAlpha = alpha;
        ctx.strokeStyle = CONFIG.COLORS.explosion;
        ctx.lineWidth = 3;
        ctx.shadowColor = CONFIG.COLORS.explosion;
        ctx.shadowBlur = 15;
        
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.stroke();

        // Draw particles
        this.particles.forEach(particle => {
          const particleAlpha = particle.life / this.maxDuration;
          ctx.globalAlpha = particleAlpha;
          ctx.fillStyle = CONFIG.COLORS.explosion;
          ctx.beginPath();
          ctx.arc(particle.x, particle.y, 2, 0, Math.PI * 2);
          ctx.fill();
        });

        ctx.globalAlpha = 1;
        ctx.shadowBlur = 0;
      }
    }

    class Particle {
      constructor(x, y, vx, vy, color, lifetime) {
        this.x = x;
        this.y = y;
        this.vx = vx;
        this.vy = vy;
        this.color = color;
        this.lifetime = lifetime;
        this.maxLifetime = lifetime;
      }

      update() {
        this.x += this.vx;
        this.y += this.vy;
        this.vx *= 0.98;
        this.vy *= 0.98;
        this.lifetime--;
        return this.lifetime > 0;
      }

      render(ctx) {
        const alpha = this.lifetime / this.maxLifetime;
        ctx.globalAlpha = alpha;
        ctx.fillStyle = this.color;
        ctx.shadowColor = this.color;
        ctx.shadowBlur = 5;
        ctx.beginPath();
        ctx.arc(this.x, this.y, 2, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;
        ctx.shadowBlur = 0;
      }
    }

    // Initialize game systems (will be done after functions are defined)
    let input;
    let audio;

    // Canvas setup
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    ctx.imageSmoothingEnabled = false;

    // Game functions
    function initializeGame() {
      // Load high score
      gameState.highScore = parseInt(localStorage.getItem('missile_command_highscore') || '0');
      
      // Reset state
      gameState.missiles = [];
      gameState.explosions = [];
      gameState.particles = [];
      gameState.score = 0;
      gameState.cities = CONFIG.INITIAL_CITIES;
      gameState.smartBombs = CONFIG.INITIAL_SMART_BOMBS;
      gameState.wave = 1;
      gameState.waveTimer = 0;
      gameState.missileSpawnTimer = 0;
      
      // Set up city and base positions
      setupPositions();
      
      updateHUD();
    }

    function setupPositions() {
      // Cities at the bottom
      gameState.cityPositions = [];
      const citySpacing = CONFIG.CANVAS_WIDTH / (CONFIG.INITIAL_CITIES + 1);
      for (let i = 1; i <= CONFIG.INITIAL_CITIES; i++) {
        gameState.cityPositions.push({
          x: citySpacing * i,
          y: CONFIG.CANVAS_HEIGHT - 75, // Adjusted for new building height
          destroyed: false
        });
      }

      // Bases (missile silos) at the bottom
      gameState.basePositions = [];
      const baseSpacing = CONFIG.CANVAS_WIDTH / 4;
      for (let i = 1; i <= 3; i++) {
        gameState.basePositions.push({
          x: baseSpacing * i,
          y: CONFIG.CANVAS_HEIGHT - 75, // Adjusted for new building height
          destroyed: false
        });
      }
    }

    function spawnMissile() {
      // Don't spawn if we've already spawned the full wave
      if (gameState.missilesSpawned >= gameState.missilesPerWave) return;
      
      // Don't spawn if we have too many active missiles
      if (gameState.missiles.length >= gameState.missilesPerWave + Math.floor(gameState.wave / 2)) return;

      // Choose a random target (city or base)
      const targets = [...gameState.cityPositions, ...gameState.basePositions].filter(t => !t.destroyed);
      if (targets.length === 0) return;

      const target = targets[Math.floor(Math.random() * targets.length)];
      const startX = Math.random() * CONFIG.CANVAS_WIDTH;
      const startY = 0;

      // Create missile with difficulty-based speed
      const difficultyMultiplier = 1 + (gameState.wave - 1) * 0.03; // 3% speed increase per wave (reduced from 5%)
      const missile = new Missile(startX, startY, target.x, target.y);
      missile.speed = CONFIG.MISSILE_SPEED * difficultyMultiplier;
      missile.vx = Math.cos(missile.angle) * missile.speed;
      missile.vy = Math.sin(missile.angle) * missile.speed;

      gameState.missiles.push(missile);
      gameState.missilesSpawned++;
    }

    function fireAtPosition(x, y) {
      // Check if any missiles are hit
      let hit = false;
      let missilesHit = 0;
      
      for (let i = gameState.missiles.length - 1; i >= 0; i--) {
        const missile = gameState.missiles[i];
        const distance = Math.hypot(missile.x - x, missile.y - y);
        
        if (distance < CONFIG.EXPLOSION_RADIUS) {
          // Hit missile
          missilesHit++;
          gameState.missiles.splice(i, 1);
          
          // Create explosion
          gameState.explosions.push(new Explosion(missile.x, missile.y, CONFIG.EXPLOSION_RADIUS, CONFIG.EXPLOSION_DURATION));
          
          // Create particles
          createExplosionParticles(missile.x, missile.y, CONFIG.COLORS.missile);
          
          hit = true;
          if (audio && audio.playMissileHit) {
            audio.playMissileHit();
          }
        }
      }

      if (hit) {
        // Calculate combo bonus
        gameState.combo++;
        gameState.comboTimer = 60; // 1 second to maintain combo
        
        // Calculate score with combo multiplier
        const baseScore = 100 * gameState.wave;
        const comboMultiplier = Math.min(gameState.combo, 5); // Max 5x combo
        const finalScore = baseScore * missilesHit * comboMultiplier;
        
        gameState.score += finalScore;
        
        // Show combo score
        showScorePopup(x, y, finalScore);
        
        // Check for rapid fire power-up
        if (gameState.combo >= 3 && !gameState.rapidFire) {
          activateRapidFire();
        }
        
        if (audio && audio.playFire) {
          audio.playFire();
        }
      }
    }

    function activateRapidFire() {
      gameState.rapidFire = true;
      gameState.rapidFireTimer = 300; // 5 seconds of rapid fire
      showWaveMessage('RAPID FIRE ACTIVATED!');
    }

    function useSmartBomb() {
      console.log('Smart bomb triggered! Smart bombs remaining:', gameState.smartBombs);
      
      if (gameState.smartBombs <= 0) {
        console.log('No smart bombs remaining');
        return;
      }

      gameState.smartBombs--;
      console.log('Smart bomb used. Remaining:', gameState.smartBombs);
      
      // Destroy all missiles on screen
      let missilesDestroyed = 0;
      gameState.missiles.forEach(missile => {
        if (!missile.destroyed) {
          missile.destroyed = true;
          missilesDestroyed++;
          
          // Create explosion
          gameState.explosions.push(new Explosion(missile.x, missile.y, CONFIG.EXPLOSION_RADIUS, CONFIG.EXPLOSION_DURATION));
          
          // Create particles
          createExplosionParticles(missile.x, missile.y, CONFIG.COLORS.missile);
        }
      });

      // Clear destroyed missiles
      gameState.missiles = gameState.missiles.filter(m => !m.destroyed);

      // Add score
      const points = missilesDestroyed * 50 * gameState.wave;
      gameState.score += points;
      
      console.log(`Smart bomb destroyed ${missilesDestroyed} missiles for ${points} points`);
      
      if (audio && audio.playSmartBomb) {
        audio.playSmartBomb();
      } else {
        console.log('Audio not available for smart bomb sound');
      }
      showScorePopup(CONFIG.CANVAS_WIDTH / 2, CONFIG.CANVAS_HEIGHT / 2, points);
      
      updateHUD();
    }

    function createExplosionParticles(x, y, color) {
      for (let i = 0; i < 25; i++) { // Increased from 15 to 25 particles
        const angle = (Math.PI * 2 * i) / 25;
        const speed = 4 + Math.random() * 6; // Increased speed range
        gameState.particles.push(new Particle(
          x + Math.cos(angle) * 15, // Increased spread
          y + Math.sin(angle) * 15,
          Math.cos(angle) * speed,
          Math.sin(angle) * speed,
          color,
          40 + Math.random() * 30 // Increased lifetime
        ));
      }
    }

    function createBuildingDestructionEffect(x, y) {
      // Create debris particles
      for (let i = 0; i < 20; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = 2 + Math.random() * 4;
        const size = 1 + Math.random() * 3;
        
        gameState.particles.push(new Particle(
          x + (Math.random() - 0.5) * 20,
          y + (Math.random() - 0.5) * 20,
          Math.cos(angle) * speed,
          Math.sin(angle) * speed,
          '#8B4513', // Brown debris color
          60 + Math.random() * 40
        ));
      }
      
      // Create smoke particles
      for (let i = 0; i < 15; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = 1 + Math.random() * 3;
        
        gameState.particles.push(new Particle(
          x + (Math.random() - 0.5) * 15,
          y + (Math.random() - 0.5) * 15,
          Math.cos(angle) * speed,
          Math.sin(angle) * speed - 1, // Smoke rises
          '#696969', // Gray smoke color
          80 + Math.random() * 60
        ));
      }
    }

    function showScorePopup(x, y, points) {
      const popup = document.createElement('div');
      popup.className = 'score-popup';
      popup.style.left = x + 'px';
      popup.style.top = y + 'px';
      popup.textContent = '+' + points;
      
      document.getElementById('gameContainer').appendChild(popup);
      
      setTimeout(() => {
        if (popup.parentNode) {
          popup.parentNode.removeChild(popup);
        }
      }, 1000);
    }

    function endTimeAttack() {
      // Calculate time attack bonus
      const timeBonus = Math.floor(gameState.score * 0.5); // 50% bonus for completing time attack
      gameState.score += timeBonus;
      
      // Show time attack completion message
      showWaveMessage(`TIME ATTACK COMPLETE! +${timeBonus} BONUS`);
      
      // Switch to classic mode for continued play
      gameState.mode = 'classic';
      gameState.timeAttackMode = false;
      
      // Reset timer
      gameState.timeAttackTimer = 300;
      
      // Continue with normal gameplay
      setTimeout(() => {
        nextWave();
      }, 2000);
    }

    function updateHUD() {
      // Update HUD display elements
      const scoreDisplay = document.getElementById('scoreDisplay');
      const waveDisplay = document.getElementById('waveDisplay');
      const citiesDisplay = document.getElementById('citiesDisplay');
      const highScoreDisplay = document.getElementById('highScoreDisplay');
      const missilesDisplay = document.getElementById('missilesDisplay');
      const smartBombsDisplay = document.getElementById('smartBombsDisplay');
      
      if (scoreDisplay) scoreDisplay.textContent = gameState.score;
      if (waveDisplay) waveDisplay.textContent = gameState.wave;
      if (citiesDisplay) citiesDisplay.textContent = gameState.cities;
      if (highScoreDisplay) highScoreDisplay.textContent = gameState.highScore;
      if (missilesDisplay) missilesDisplay.textContent = gameState.missiles.length;
      if (smartBombsDisplay) smartBombsDisplay.textContent = gameState.smartBombs;
      
      // Show time attack timer if in time attack mode
      if (gameState.mode === 'time-attack') {
        const minutes = Math.floor(gameState.timeAttackTimer / 60);
        const seconds = gameState.timeAttackTimer % 60;
        const timeString = `${minutes}:${seconds.toString().padStart(2, '0')}`;
        document.getElementById('waveDisplay').textContent = `TIME: ${timeString}`;
      }
      
      // Update combo display
      if (gameState.combo > 1) {
        document.getElementById('missilesDisplay').textContent = `COMBO: x${gameState.combo}`;
      }
      
      // Update rapid fire display
      if (gameState.rapidFire) {
        document.getElementById('smartBombsDisplay').textContent = 'RAPID FIRE!';
      }
    }

    function updateGame() {
      if (!gameState.running || gameState.paused) return;
      
      // Ensure input and audio managers are ready
      if (!input || !audio) {
        console.warn('Input or audio manager not ready in updateGame, skipping update');
        return;
      }

      // Handle input (including smart bomb)
      handleInput();

      // Update wave timer
      if (gameState.waveTimer > 0) {
        gameState.waveTimer--;
      }

      // Update time attack timer
      if (gameState.mode === 'time-attack' && gameState.timeAttackTimer > 0) {
        gameState.timeAttackTimer--;
        if (gameState.timeAttackTimer <= 0) {
          // Time's up! End time attack mode
          endTimeAttack();
          return;
        }
      }

      // Update combo timer
      if (gameState.comboTimer > 0) {
        gameState.comboTimer--;
        if (gameState.comboTimer <= 0) {
          gameState.combo = 0; // Reset combo
        }
      }

      // Update rapid fire timer
      if (gameState.rapidFireTimer > 0) {
        gameState.rapidFireTimer--;
        if (gameState.rapidFireTimer <= 0) {
          gameState.rapidFire = false; // End rapid fire
          showWaveMessage('RAPID FIRE ENDED');
        }
      }

      // Spawn missiles
      if (gameState.missileSpawnTimer > 0) {
        gameState.missileSpawnTimer--;
      } else {
        spawnMissile();
        gameState.missileSpawnTimer = 200 + Math.random() * 300; // More generous random spawn interval (was 120 + random 180)
      }

      // Update entities
      gameState.missiles = gameState.missiles.filter(missile => missile.update());
      gameState.explosions = gameState.explosions.filter(explosion => explosion.update());
      gameState.particles = gameState.particles.filter(particle => particle.update());

      // Check missile impacts
      checkMissileImpacts();

      // Check wave completion - only complete when all missiles are destroyed and we've spawned the full wave
      if (gameState.missiles.length === 0 && gameState.missilesSpawned >= gameState.missilesPerWave) {
        nextWave();
      }

      updateHUD();
    }

    function checkMissileImpacts() {
      for (let i = gameState.missiles.length - 1; i >= 0; i--) {
        const missile = gameState.missiles[i];
        
        // Check city impacts
        gameState.cityPositions.forEach(city => {
          if (!city.destroyed) {
            const distance = Math.hypot(missile.x - city.x, missile.y - city.y);
            if (distance < CONFIG.CITY_SIZE * 1.8) { // Adjusted for new building width
              city.destroyed = true;
              gameState.cities--;
              gameState.missiles.splice(i, 1);
              
              // Create explosion
              gameState.explosions.push(new Explosion(city.x, city.y, CONFIG.EXPLOSION_RADIUS, CONFIG.EXPLOSION_DURATION));
              createExplosionParticles(city.x, city.y, CONFIG.COLORS.city);
              
              // Create building destruction effect
              createBuildingDestructionEffect(city.x, city.y);
              
              if (audio && audio.playCityDestroyed) {
                audio.playCityDestroyed();
              }
              
              if (gameState.cities <= 0) {
                checkGameOver();
              }
              return;
            }
          }
        });

        // Check base impacts
        gameState.basePositions.forEach(base => {
          if (!base.destroyed) {
            const distance = Math.hypot(missile.x - base.x, missile.y - base.y);
            if (distance < CONFIG.CITY_SIZE * 1.8) { // Adjusted for new building width
              base.destroyed = true;
              gameState.missiles.splice(i, 1);
              
              // Create explosion
              gameState.explosions.push(new Explosion(base.x, base.y, CONFIG.EXPLOSION_RADIUS, CONFIG.EXPLOSION_DURATION));
              createExplosionParticles(base.x, base.y, CONFIG.COLORS.base);
              
              // Create building destruction effect
              createBuildingDestructionEffect(base.x, base.y);
              
              if (audio && audio.playCityDestroyed) {
                audio.playCityDestroyed();
              }
              return;
            }
          }
        });
      }
    }

    function nextWave() {
      gameState.wave++;
      
      // Bonus points for completing wave
      const waveBonus = 1000 * gameState.wave;
      gameState.score += waveBonus;
      
      // Show wave completion message
      showWaveMessage(`WAVE ${gameState.wave - 1} COMPLETE! +${waveBonus} POINTS`);
      
      // Set wave timer
      gameState.waveTimer = 300; // 5 seconds (increased from 3)
      
      // Reset missile spawn timer and counter
      gameState.missileSpawnTimer = 0;
      gameState.missilesSpawned = 0;
      
      // Increase missiles per wave as difficulty increases
      gameState.missilesPerWave = CONFIG.MISSILES_PER_WAVE + Math.floor((gameState.wave - 1) / 2);
      
      // Add smart bomb every 3 waves
      if (gameState.wave % 3 === 0) {
        gameState.smartBombs++;
      }
      
      // Mode-specific wave logic
      if (gameState.mode === 'survival') {
        // Survival mode: cities don't respawn, increasing difficulty
        gameState.missileSpawnTimer = Math.max(30, 120 - gameState.wave * 5);
      } else if (gameState.mode === 'cooperative') {
        // Co-op mode: more missiles but shared resources
        gameState.missileSpawnTimer = Math.max(40, 100 - gameState.wave * 3);
      } else if (gameState.mode === 'time-attack') {
        // Time attack: faster missiles, time limit
        gameState.missileSpawnTimer = Math.max(20, 80 - gameState.wave * 4);
      } else {
        // Classic mode: more forgiving spawn rate
        gameState.missileSpawnTimer = Math.max(60, 150 - gameState.wave * 2);
      }
      
      updateHUD();
    }

    function showWaveMessage(message) {
      const messageDiv = document.createElement('div');
      messageDiv.style.cssText = `
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-family: 'Orbitron', monospace;
        font-size: 2.5rem;
        font-weight: 900;
        color: #00ff41;
        text-shadow: 0 0 40px rgba(0, 255, 65, 0.8);
        background: rgba(0, 0, 17, 0.9);
        border: 3px solid #00ff41;
        border-radius: 20px;
        padding: 25px 50px;
        z-index: 1000;
        pointer-events: none;
        backdrop-filter: blur(10px);
        animation: wave-message 3s ease-in-out forwards, wave-message-glow 1s ease-in-out infinite;
        max-width: 90vw;
        text-align: center;
        word-wrap: break-word;
      `;
      messageDiv.textContent = message;
      
      // Add keyframe animation
      if (!document.querySelector('#wave-message-style')) {
        const style = document.createElement('style');
        style.id = 'wave-message-style';
        style.textContent = `
          @keyframes wave-message {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
            20% { opacity: 1; transform: translate(-50%, -50%) scale(1.1); }
            80% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
          }
          
          @keyframes wave-message-glow {
            0%, 100% { box-shadow: 0 0 20px rgba(0, 255, 65, 0.6); }
            50% { box-shadow: 0 0 40px rgba(0, 255, 65, 0.9); }
          }
        `;
        document.head.appendChild(style);
      }
      
      document.getElementById('gameContainer').appendChild(messageDiv);
      
      setTimeout(() => {
        if (messageDiv.parentNode) {
          messageDiv.parentNode.removeChild(messageDiv);
        }
      }, 3000);
    }

    function checkGameOver() {
      if (gameState.cities <= 0) {
        endGame();
      }
    }

    function handleInput() {
      if (!gameState.running) return;
      
      // Ensure input manager is available
      if (!input) {
        console.warn('Input manager not initialized yet');
        return;
      }

      // Check pause
      if (input.isPausePressed() && !gameState.pausePressed) {
        gameState.paused = !gameState.paused;
        document.getElementById('pausedOverlay').style.display = gameState.paused ? 'flex' : 'none';
        gameState.pausePressed = true;
      } else if (!input.isPausePressed()) {
        gameState.pausePressed = false;
      }

      // Check fullscreen
      if (input.isFullscreenPressed() && !gameState.fullscreenPressed) {
        toggleFullscreen();
        gameState.fullscreenPressed = true;
      } else if (!input.isFullscreenPressed()) {
        gameState.fullscreenPressed = false;
      }

      // Check restart
      if (input.isRestartPressed() && !gameState.restartPressed) {
        restartGame();
        gameState.restartPressed = true;
      } else if (!input.isRestartPressed()) {
        gameState.restartPressed = false;
      }

      // Check smart bomb
      if (input.isSmartBombPressed() && !gameState.smartBombPressed) {
        console.log('Smart bomb input detected, calling useSmartBomb()');
        useSmartBomb();
        gameState.smartBombPressed = true;
      } else if (!input.isSmartBombPressed()) {
        gameState.smartBombPressed = false;
      }
    }

    // Game loop
    function gameLoop() {
      // Ensure input and audio managers are ready
      if (!input || !audio) {
        console.warn('Input or audio manager not ready in game loop, waiting...');
        setTimeout(() => {
          if (input && audio) {
            console.log('Input and audio managers now ready in game loop');
            gameLoop();
          } else {
            console.error('Input or audio manager still not ready after game loop delay');
          }
        }, 100);
        return;
      }
      
      const currentTime = performance.now();
      const deltaTime = currentTime - gameState.lastUpdateTime;
      gameState.lastUpdateTime = currentTime;

      if (gameState.running && !gameState.paused) {
        updateGame();
        render();
      } else if (gameState.running === false) {
        // Game is over, only render static screen
        render();
      }

      // Continue game loop only if game should be running
      if (gameState.running !== false) {
        requestAnimationFrame(gameLoop);
      } else {
        gameState.gameLoopRunning = false;
      }
    }

    function render() {
      // Ensure canvas context is available
      if (!ctx) {
        console.warn('Canvas context not available for rendering');
        return;
      }
      
      ctx.clearRect(0, 0, CONFIG.CANVAS_WIDTH, CONFIG.CANVAS_HEIGHT);

      // Draw background
      ctx.fillStyle = CONFIG.COLORS.background;
      ctx.fillRect(0, 0, CONFIG.CANVAS_WIDTH, CONFIG.CANVAS_HEIGHT);

      // Draw city and base positions
      gameState.cityPositions.forEach(city => {
        if (!city.destroyed) {
          drawBuilding(ctx, city.x, city.y, CONFIG.COLORS.city);
        }
      });

      gameState.basePositions.forEach(base => {
        if (!base.destroyed) {
          drawBuilding(ctx, base.x, base.y, CONFIG.COLORS.base);
        }
      });

      // Draw missiles
      gameState.missiles.forEach(missile => missile.render(ctx));

      // Draw explosions
      gameState.explosions.forEach(explosion => explosion.render(ctx));

      // Draw particles
      gameState.particles.forEach(particle => particle.render(ctx));

      // Draw crosshair indicator
      if (gameState.running && !gameState.paused) {
        drawCrosshair(input.mouseX, input.mouseY);
      }
    }

    function drawBuilding(ctx, x, y, color) {
      const buildingWidth = CONFIG.CITY_SIZE * 1.8;
      const buildingHeight = CONFIG.CITY_SIZE * 2.5;
      
      // Enhanced building shadow with depth
      ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
      ctx.fillRect(x - buildingWidth/2 + 4, y + 4, buildingWidth, buildingHeight);
      
      // Main building structure
      ctx.fillStyle = color;
      ctx.shadowColor = color;
      ctx.shadowBlur = 15;
      ctx.fillRect(x - buildingWidth/2, y, buildingWidth, buildingHeight);
      
      // Building foundation/base
      ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
      ctx.fillRect(x - buildingWidth/2 - 2, y + buildingHeight, buildingWidth + 4, 4);
      
      // Roof details
      ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
      ctx.fillRect(x - buildingWidth/2, y, buildingWidth, 3); // Top edge
      
      // Architectural lines and details
      ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
      ctx.lineWidth = 1;
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
      
      // Vertical architectural lines
      for (let i = 1; i < 4; i++) {
        const lineX = x - buildingWidth/2 + (buildingWidth * i) / 4;
        ctx.beginPath();
        ctx.moveTo(lineX, y);
        ctx.lineTo(lineX, y + buildingHeight);
        ctx.stroke();
      }
      
      // Horizontal floor lines
      for (let i = 1; i < 4; i++) {
        const lineY = y + (buildingHeight * i) / 4;
        ctx.beginPath();
        ctx.moveTo(x - buildingWidth/2, lineY);
        ctx.lineTo(x + buildingWidth/2, lineY);
        ctx.stroke();
      }
      
      // Enhanced windows with frames
      ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
      for (let i = 0; i < 4; i++) {
        for (let j = 0; j < 3; j++) {
          const windowX = x - buildingWidth/2 + 6 + i * (buildingWidth - 12) / 3;
          const windowY = y + 8 + j * (buildingHeight - 16) / 3;
          
          // Window frame
          ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
          ctx.fillRect(windowX - 1, windowY - 1, 5, 5);
          
          // Window glass
          ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
          ctx.fillRect(windowX, windowY, 3, 3);
          
          // Window highlight
          ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
          ctx.fillRect(windowX, windowY, 1, 1);
        }
      }
      
      // Building entrance at bottom
      ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
      const entranceWidth = buildingWidth * 0.4;
      const entranceHeight = 6;
      ctx.fillRect(x - entranceWidth/2, y + buildingHeight - entranceHeight, entranceWidth, entranceHeight);
      
      // Entrance highlight
      ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
      ctx.fillRect(x - entranceWidth/2 + 1, y + buildingHeight - entranceHeight + 1, entranceWidth - 2, 2);
      
      // Reset shadow
      ctx.shadowBlur = 0;
      ctx.lineWidth = 1;
    }

    function drawCrosshair(x, y) {
      // Ensure canvas context is available
      if (!ctx) {
        console.warn('Canvas context not available for crosshair');
        return;
      }
      
      const size = 20;
      const thickness = 2;
      
      ctx.strokeStyle = 'rgba(0, 255, 255, 0.8)';
      ctx.lineWidth = thickness;
      ctx.shadowColor = 'rgba(0, 255, 255, 0.6)';
      ctx.shadowBlur = 5;
      
      // Horizontal line
      ctx.beginPath();
      ctx.moveTo(x - size, y);
      ctx.lineTo(x + size, y);
      ctx.stroke();
      
      // Vertical line
      ctx.beginPath();
      ctx.moveTo(x, y - size);
      ctx.lineTo(x, y + size);
      ctx.stroke();
      
      // Center dot
      ctx.fillStyle = 'rgba(0, 255, 255, 0.9)';
      ctx.beginPath();
      ctx.arc(x, y, 2, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.shadowBlur = 0;
    }

    function startGame() {
      // Ensure input manager is ready
      if (!input) {
        console.error('Input manager not initialized. Cannot start game.');
        return;
      }
      
      gameState.running = true;
      gameState.paused = false;
      gameState.gameLoopRunning = true;
      document.getElementById('menuOverlay').style.display = 'none';
      document.getElementById('hud').style.display = 'flex';
      
      // Focus canvas to ensure keyboard events work
      const canvas = document.getElementById('gameCanvas');
      if (canvas) {
        canvas.focus();
        console.log('Canvas focused on game start');
      }
      
      initializeGame();
      gameLoop();
    }

    function restartGame() {
      // Ensure input manager is ready
      if (!input) {
        console.error('Input manager not initialized. Cannot restart game.');
        return;
      }
      
      // Reset game state
      gameState.running = true;
      gameState.paused = false;
      gameState.score = 0;
      gameState.wave = 1;
      gameState.combo = 0;
      gameState.comboTimer = 0;
      gameState.rapidFire = false;
      gameState.rapidFireTimer = 0;
      gameState.smartBombPressed = false;
      
      // Hide overlays
      document.getElementById('gameOverOverlay').style.display = 'none';
      document.getElementById('pausedOverlay').style.display = 'none';
      
      // Show game elements
      document.getElementById('hud').style.display = 'flex';
      
      // Reinitialize game
      initializeGame();
      
      // Start game loop if not already running
      if (!gameState.gameLoopRunning) {
        gameState.gameLoopRunning = true;
        gameLoop();
      }
    }

    function showMenu() {
      // Ensure input manager is ready
      if (!input) {
        console.error('Input manager not initialized. Cannot show menu.');
        return;
      }
      
      gameState.running = false;
      gameState.paused = false;
      gameState.gameLoopRunning = false;
      document.getElementById('hud').style.display = 'none';
      document.getElementById('menuOverlay').style.display = 'flex';
      document.getElementById('pausedOverlay').style.display = 'none';
      document.getElementById('gameOverOverlay').style.display = 'none';
      document.getElementById('touchControls').style.display = 'none';
    }

    function endGame() {
      gameState.running = false;
      gameState.paused = false;
      
      // Hide game elements
      document.getElementById('hud').style.display = 'none';
      document.getElementById('touchControls').style.display = 'none';
      
      // Show game over overlay with dramatic effect
      const gameOverOverlay = document.getElementById('gameOverOverlay');
      gameOverOverlay.style.display = 'flex';
      
      // Update final stats
      const finalStats = document.getElementById('finalStats');
      finalStats.innerHTML = `
        <p style="color: #00ff41; margin: 10px 0;">Final Score: ${gameState.score.toLocaleString()}</p>
        <p style="color: #00ffff; margin: 10px 0;">High Score: ${gameState.highScore.toLocaleString()}</p>
        <p style="color: #ff6b6b; margin: 10px 0;">Cities Destroyed: ${CONFIG.INITIAL_CITIES - gameState.cities}</p>
        <p style="color: #ffaa00; margin: 10px 0;">Waves Survived: ${gameState.wave - 1}</p>
        <p style="color: #ff00ff; margin: 10px 0;">Smart Bombs Used: ${CONFIG.INITIAL_SMART_BOMBS - gameState.smartBombs}</p>
      `;
      
      // Update high score if needed
      if (gameState.score > gameState.highScore) {
        gameState.highScore = gameState.score;
        localStorage.setItem('missile_command_highscore', gameState.highScore);
        
        // Show new high score celebration
        setTimeout(() => {
          showWaveMessage('NEW HIGH SCORE!');
        }, 1000);
      }
      
      // Play game over sound effect
      if (audio && audio.playGameOver) {
        audio.playGameOver();
      } else {
        console.log('Audio not available for game over sound');
      }
    }

    function toggleFullscreen() {
      const canvas = document.getElementById('gameCanvas');
      if (canvas.requestFullscreen) {
        canvas.requestFullscreen();
      } else if (canvas.mozRequestFullScreen) {
        canvas.mozRequestFullScreen();
      } else if (canvas.webkitRequestFullscreen) {
        canvas.webkitRequestFullscreen();
      } else if (canvas.msRequestFullscreen) {
        canvas.msRequestFullscreen();
      }
    }

    function goHome() {
      window.location.href = '../index.html';
    }

    // Event listeners for menu buttons
    document.getElementById('menuOverlay').addEventListener('click', (e) => {
      if (e.target.classList.contains('btn')) {
        e.target.click(); // Simulate click to trigger onclick
      }
    });

    // Game mode selection
    document.querySelectorAll('.mode-card').forEach(card => {
      card.addEventListener('click', () => {
        // Remove active class from all cards
        document.querySelectorAll('.mode-card').forEach(c => c.classList.remove('active'));
        // Add active class to clicked card
        card.classList.add('active');
        // Set game mode
        gameState.mode = card.dataset.mode;
      });
    });

    document.getElementById('gameOverOverlay').addEventListener('click', (e) => {
      if (e.target.classList.contains('btn')) {
        e.target.click(); // Simulate click to trigger onclick
      }
    });

    document.getElementById('pausedOverlay').addEventListener('click', (e) => {
      if (e.target.classList.contains('btn')) {
        e.target.click(); // Simulate click to trigger onclick
      }
    });

    document.getElementById('touchControls').addEventListener('click', (e) => {
      if (e.target.classList.contains('touch-btn')) {
        const action = e.target.dataset.action;
        if (action === 'fire') {
          fireAtPosition(input.mouseX, input.mouseY);
        } else if (action === 'smart-bomb') {
          useSmartBomb();
        }
      }
    });

    // Initialization
    function initializeUI() {
      console.log('Initializing UI...');
      
      // Ensure input and audio managers are ready
      if (!input) {
        console.warn('Input manager not ready during UI initialization');
      }
      if (!audio) {
        console.warn('Audio manager not ready during UI initialization');
      }
      
      const menuOverlay = document.getElementById('menuOverlay');
      const hud = document.getElementById('hud');
      const pausedOverlay = document.getElementById('pausedOverlay');
      const gameOverOverlay = document.getElementById('gameOverOverlay');
      const touchControls = document.getElementById('touchControls');
      
      if (menuOverlay) {
        menuOverlay.style.display = 'flex';
        console.log('Menu overlay set to display: flex');
      } else {
        console.error('Menu overlay not found!');
      }
      
      if (hud) hud.style.display = 'none';
      if (pausedOverlay) pausedOverlay.style.display = 'none';
      if (gameOverOverlay) gameOverOverlay.style.display = 'none';
      if (touchControls) touchControls.style.display = 'none';
    }

    // Try audio initialization, but fallback to immediate UI setup
    if (audio && audio.init) {
      audio.init().then(() => {
        initializeUI();
      }).catch(() => {
        // If audio fails, still show the UI
        initializeUI();
      });
    } else {
      // If audio is not available, just initialize UI
      console.warn('Audio manager not ready for initialization');
      initializeUI();
    }

    // Fallback initialization after a short delay
    setTimeout(() => {
      // Ensure input and audio managers are ready
      if (!input || !audio) {
        console.warn('Input or audio manager not ready on fallback, waiting...');
        setTimeout(() => {
          if (input && audio) {
            console.log('Input and audio managers now ready on fallback');
            const menuOverlay = document.getElementById('menuOverlay');
            if (menuOverlay && (menuOverlay.style.display === 'none' ||
              menuOverlay.style.display === '')) {
              console.log('Fallback initialization triggered');
              initializeUI();
            }
          } else {
            console.error('Input or audio manager still not ready after fallback delay');
          }
        }, 200);
      } else {
        const menuOverlay = document.getElementById('menuOverlay');
        if (menuOverlay && (menuOverlay.style.display === 'none' ||
          menuOverlay.style.display === '')) {
          console.log('Fallback initialization triggered');
          initializeUI();
        }
      }
    }, 100);

       // Additional fallback after page load
       window.addEventListener('load', () => {
         console.log('Window loaded, checking UI state...');
         
         // Ensure input and audio managers are ready
         if (!input || !audio) {
           console.warn('Input or audio manager not ready on window load, waiting...');
           setTimeout(() => {
             if (input && audio) {
               console.log('Input and audio managers now ready on window load');
               const menuOverlay = document.getElementById('menuOverlay');
               if (menuOverlay && menuOverlay.style.display !== 'flex') {
                 console.log('Window load fallback - forcing menu display');
                 menuOverlay.style.display = 'flex';
               }
             } else {
               console.error('Input or audio manager still not ready after window load delay');
             }
           }, 200);
         } else {
           const menuOverlay = document.getElementById('menuOverlay');
           if (menuOverlay && menuOverlay.style.display !== 'flex') {
             console.log('Window load fallback - forcing menu display');
             menuOverlay.style.display = 'flex';
           }
         }
       });

    // Force menu display after everything loads
           setTimeout(() => {
         console.log('Final fallback - forcing menu display');
         
         // Ensure input and audio managers are ready
         if (!input || !audio) {
           console.warn('Input or audio manager not ready on final fallback, waiting...');
           setTimeout(() => {
             if (input && audio) {
               console.log('Input and audio managers now ready on final fallback');
               const menuOverlay = document.getElementById('menuOverlay');
               if (menuOverlay) {
                 menuOverlay.style.display = 'flex';
                 menuOverlay.style.visibility = 'visible';
                 menuOverlay.style.opacity = '1';
                 console.log('Menu overlay forced to display');
               }
             } else {
               console.error('Input or audio manager still not ready after final fallback delay');
             }
           }, 300);
         } else {
           const menuOverlay = document.getElementById('menuOverlay');
           if (menuOverlay) {
             menuOverlay.style.display = 'flex';
             menuOverlay.style.visibility = 'visible';
             menuOverlay.style.opacity = '1';
             console.log('Menu overlay forced to display');
           }
         }
       }, 500);

    // Handle touch controls visibility and canvas resize
    window.addEventListener('resize', () => {
      // Handle touch controls
      if (window.innerWidth < 768) {
        const touchControls = document.getElementById('touchControls');
        if (touchControls) {
          touchControls.style.display = 'flex';
        }
      } else {
        const touchControls = document.getElementById('touchControls');
        if (touchControls) {
          touchControls.style.display = 'none';
        }
      }
      
      // Handle canvas resize
      resizeCanvas();
    });

    // Enhanced Canvas resize function with responsive features
    function resizeCanvas() {
      const canvas = document.getElementById('gameCanvas');
      const container = document.getElementById('gameContainer');
      
      if (!canvas || !container) {
        console.warn('Canvas or container not found for resize');
        return;
      }
      
      const containerRect = container.getBoundingClientRect();
      
      // Get device pixel ratio for high DPI displays
      const devicePixelRatio = window.devicePixelRatio || 1;
      
      // Calculate scale to fit container while maintaining aspect ratio
      const scaleX = containerRect.width / CONFIG.CANVAS_WIDTH;
      const scaleY = containerRect.height / CONFIG.CANVAS_HEIGHT;
      let scale = Math.min(scaleX, scaleY, 1); // Don't scale up beyond original size
      
      // For very small screens, allow some scaling up to maintain playability
      if (containerRect.width < 400 || containerRect.height < 300) {
        scale = Math.min(scaleX, scaleY, 1.2);
      }
      
      // Apply scale transform with smooth transitions
      canvas.style.transition = 'transform 0.3s ease-out';
      canvas.style.transform = `scale(${scale})`;
      canvas.style.transformOrigin = 'center center';
      
      // Center canvas
      canvas.style.position = 'absolute';
      canvas.style.left = '50%';
      canvas.style.top = '50%';
      canvas.style.marginLeft = `-${CONFIG.CANVAS_WIDTH * scale / 2}px`;
      canvas.style.marginTop = `-${CONFIG.CANVAS_HEIGHT * scale / 2}px`;
      
      // Store scale for input coordinate calculations
      canvas.dataset.scale = scale;
      
      // Adjust touch controls position for mobile
      const touchControls = document.getElementById('touchControls');
      if (touchControls && window.innerWidth < 768) {
        const bottomOffset = Math.max(20, containerRect.height * 0.05);
        const rightOffset = Math.max(20, containerRect.width * 0.05);
        touchControls.style.bottom = `${bottomOffset}px`;
        touchControls.style.right = `${rightOffset}px`;
      }
    }

    // Initial canvas resize
    resizeCanvas();
    
    // Initialize game systems after all functions are defined
    input = new InputManager();
    audio = new AudioManager();

    // Ensure menu is visible immediately
    document.addEventListener('DOMContentLoaded', () => {
      console.log('DOM loaded, initializing UI...');
      
      // Ensure input and audio managers are ready
      if (!input || !audio) {
        console.warn('Input or audio manager not ready, waiting...');
        setTimeout(() => {
          if (input && audio) {
            console.log('Input and audio managers now ready');
            initializeUI();
          } else {
            console.error('Input or audio manager still not ready after delay');
            initializeUI(); // Try anyway
          }
        }, 100);
      } else {
        initializeUI();
      }
      
      console.log('Menu overlay display:', document.getElementById('menuOverlay').style.display);
    });
  </script>
</body>
</html>
