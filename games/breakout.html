<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Neon Breakout - Arkanoid Style</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');
    
    :root {
      --bg-dark: #000011;
      --neon-cyan: #00ffff;
      --neon-pink: #ff00ff;
      --neon-green: #00ff41;
      --neon-orange: #ff6600;
      --neon-purple: #8a2be2;
      --neon-yellow: #ffff00;
      --neon-red: #ff0040;
      --paddle-blue: #0080ff;
      --ball-white: #ffffff;
      --text-light: #e6f1ff;
      --brick-colors: ['#ff0040', '#ff6600', '#ffff00', '#00ff41', '#0080ff', '#8a2be2'];
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    html, body {
      height: 100%;
      background: var(--bg-dark);
      color: var(--text-light);
      font-family: 'Orbitron', monospace;
      overflow: hidden;
      user-select: none;
      -webkit-user-select: none;
      touch-action: none;
    }

    #gameContainer {
      position: fixed;
      inset: 0;
      display: grid;
      place-items: center;
      background: 
        radial-gradient(circle at 25% 25%, rgba(0, 255, 255, 0.1) 0%, transparent 50%),
        radial-gradient(circle at 75% 75%, rgba(255, 0, 255, 0.1) 0%, transparent 50%),
        radial-gradient(circle at 50% 50%, rgba(0, 255, 65, 0.05) 0%, transparent 70%);
    }

    canvas {
      border: 4px solid var(--neon-cyan);
      border-radius: 12px;
      background: linear-gradient(180deg, var(--bg-dark) 0%, #000022 50%, #000033 100%);
      box-shadow: 
        0 0 40px rgba(0, 255, 255, 0.5),
        inset 0 0 30px rgba(0, 255, 255, 0.1);
    }

    .overlay {
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
      background: rgba(0, 0, 17, 0.9);
      backdrop-filter: blur(10px);
      overflow-y: auto;
      padding: 20px 0;
    }

    .menu-card {
      background: linear-gradient(135deg, rgba(0, 255, 255, 0.1), rgba(255, 0, 255, 0.1));
      border: 3px solid var(--neon-cyan);
      border-radius: 20px;
      padding: 30px;
      text-align: center;
      max-width: 600px;
      width: 90vw;
      max-height: 90vh;
      overflow-y: auto;
      box-shadow: 
        0 0 50px rgba(0, 255, 255, 0.4),
        inset 0 0 30px rgba(0, 255, 255, 0.1);
    }

    .title {
      font-size: 3rem;
      font-weight: 900;
      margin-bottom: 15px;
      background: linear-gradient(45deg, var(--neon-cyan), var(--neon-pink), var(--neon-green), var(--neon-orange));
      background-size: 400% 400%;
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      animation: gradient-shift 3s ease-in-out infinite;
      text-shadow: 0 0 40px rgba(0, 255, 255, 0.6);
    }

    @keyframes gradient-shift {
      0%, 100% { background-position: 0% 50%; }
      25% { background-position: 100% 50%; }
      50% { background-position: 100% 100%; }
      75% { background-position: 0% 100%; }
    }

    .subtitle {
      color: var(--text-light);
      margin-bottom: 25px;
      font-size: 1.2rem;
      opacity: 0.9;
    }

    .difficulty-options {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 15px;
      margin-bottom: 25px;
    }

    .difficulty-card {
      background: linear-gradient(135deg, rgba(0, 255, 65, 0.1), rgba(255, 102, 0, 0.1));
      border: 2px solid transparent;
      border-radius: 15px;
      padding: 16px 12px;
      cursor: pointer;
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
    }

    .difficulty-card.active {
      transform: scale(1.05);
    }

    .difficulty-card[data-difficulty="easy"].active {
      border-color: #00ff41 !important;
      background: linear-gradient(135deg, rgba(0, 255, 65, 0.2), rgba(0, 255, 65, 0.1)) !important;
      box-shadow: 0 0 25px rgba(0, 255, 65, 0.4) !important;
    }

    .difficulty-card[data-difficulty="normal"].active {
      border-color: #ff6600 !important;
      background: linear-gradient(135deg, rgba(255, 102, 0, 0.2), rgba(255, 102, 0, 0.1)) !important;
      box-shadow: 0 0 25px rgba(255, 102, 0, 0.4) !important;
    }

    .difficulty-card[data-difficulty="hard"].active {
      border-color: #ff0040 !important;
      background: linear-gradient(135deg, rgba(255, 0, 64, 0.2), rgba(255, 0, 64, 0.1)) !important;
      box-shadow: 0 0 25px rgba(255, 0, 64, 0.4) !important;
    }

    .difficulty-card[data-difficulty="extreme"].active {
      border-color: #ff00ff !important;
      background: linear-gradient(135deg, rgba(255, 0, 255, 0.2), rgba(255, 0, 255, 0.1)) !important;
      box-shadow: 0 0 25px rgba(255, 0, 255, 0.4) !important;
    }

    .difficulty-card:hover {
      transform: translateY(-3px);
      box-shadow: 0 10px 25px rgba(0, 255, 255, 0.3);
    }

    .difficulty-title {
      font-weight: 700;
      font-size: 1.2rem;
      margin-bottom: 8px;
      color: var(--neon-green);
    }

    .difficulty-desc {
      font-size: 0.85rem;
      opacity: 0.8;
      line-height: 1.3;
    }

    .btn {
      background: linear-gradient(135deg, var(--neon-cyan), var(--neon-pink));
      border: none;
      border-radius: 15px;
      padding: 18px 35px;
      color: var(--bg-dark);
      font-family: inherit;
      font-weight: 700;
      font-size: 1.3rem;
      cursor: pointer;
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
      margin: 15px;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .btn:hover {
      transform: translateY(-4px) scale(1.05);
      box-shadow: 0 20px 40px rgba(0, 255, 255, 0.4);
    }

    .btn:active {
      transform: translateY(-2px) scale(1.02);
    }

    .controls-info {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 15px;
      margin-bottom: 25px;
    }

    .control-section {
      background: rgba(0, 0, 0, 0.4);
      border: 1px solid rgba(0, 255, 255, 0.3);
      border-radius: 10px;
      padding: 15px;
    }

    .control-title {
      color: var(--neon-cyan);
      font-weight: 700;
      margin-bottom: 10px;
      font-size: 1.1rem;
    }

    .kbd {
      display: inline-block;
      padding: 4px 8px;
      background: rgba(0, 255, 255, 0.2);
      border: 1px solid rgba(0, 255, 255, 0.4);
      border-radius: 5px;
      font-size: 0.9rem;
      margin: 2px;
      font-weight: 600;
    }

    .hud {
      position: absolute;
      top: 20px;
      left: 20px;
      right: 20px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-weight: 700;
      pointer-events: none;
      z-index: 10;
    }

    .score-panel {
      background: rgba(0, 0, 17, 0.8);
      border: 2px solid var(--neon-cyan);
      border-radius: 12px;
      padding: 15px 20px;
      backdrop-filter: blur(8px);
      min-width: 180px;
    }

    .score-item {
      margin-bottom: 8px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .score-label {
      color: var(--neon-cyan);
    }

    .score-value {
      color: var(--text-light);
      font-size: 1.2rem;
    }

    .lives-display {
      display: flex;
      gap: 5px;
      margin-top: 5px;
    }

    .life-icon {
      width: 12px;
      height: 12px;
      background: var(--paddle-blue);
      border-radius: 50%;
      box-shadow: 0 0 8px var(--paddle-blue);
    }



    .paused-overlay {
      position: absolute;
      inset: 0;
      background: rgba(0, 0, 17, 0.8);
      display: none;
      align-items: center;
      justify-content: center;
      font-size: 3rem;
      font-weight: 900;
      color: var(--neon-cyan);
      text-shadow: 0 0 40px rgba(0, 255, 255, 0.8);
      backdrop-filter: blur(8px);
    }

    .powerup-notification {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 255, 255, 0.2);
      border: 2px solid var(--neon-cyan);
      border-radius: 15px;
      padding: 20px 30px;
      font-size: 1.5rem;
      font-weight: 700;
      color: var(--neon-cyan);
      text-shadow: 0 0 20px var(--neon-cyan);
      opacity: 0;
      transition: opacity 0.3s ease;
      pointer-events: none;
      z-index: 15;
    }

    .powerup-notification.show {
      opacity: 1;
    }

    .touch-paddle {
      position: absolute;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      width: 300px;
      height: 60px;
      background: rgba(0, 128, 255, 0.3);
      border: 2px solid var(--paddle-blue);
      border-radius: 30px;
      display: none;
      align-items: center;
      justify-content: center;
      font-size: 1.2rem;
      color: var(--paddle-blue);
      font-weight: 700;
      cursor: pointer;
      transition: all 0.2s ease;
      user-select: none;
      -webkit-user-select: none;
      touch-action: manipulation;
    }

    .touch-paddle:active {
      background: rgba(0, 128, 255, 0.5);
      transform: translateX(-50%) scale(0.98);
    }

    .hidden {
      display: none !important;
    }

    .back-btn {
      position: fixed;
      bottom: 20px;
      left: 20px;
      background: rgba(255, 0, 64, 0.2);
      border: 2px solid var(--neon-red);
      border-radius: 15px;
      padding: 15px 22px;
      color: var(--neon-red);
      font-family: inherit;
      font-weight: 700;
      cursor: pointer;
      transition: all 0.3s ease;
      z-index: 10;
      width: auto;
      height: auto;
      pointer-events: auto;
    }

    .back-btn:hover {
      background: rgba(255, 0, 64, 0.3);
      transform: translateY(-3px);
      box-shadow: 0 12px 30px rgba(255, 0, 64, 0.3);
    }

    @media (max-width: 768px) {
      .touch-paddle {
        display: flex;
      }
      
      .menu-card {
        padding: 25px;
      }
      
      .title {
        font-size: 2.8rem;
      }
      
      .difficulty-options {
        grid-template-columns: 1fr;
        gap: 15px;
      }
      
      .controls-info {
        grid-template-columns: 1fr;
      }
      
      .back-btn {
        bottom: 15px;
        left: 15px;
        padding: 12px 18px;
        font-size: 0.9rem;
      }
    }

    @media (max-width: 480px) {
      .menu-card {
        padding: 20px;
        margin: 10px;
      }
      
      .title {
        font-size: 2.5rem;
        margin-bottom: 12px;
      }
      
      .subtitle {
        font-size: 1.1rem;
        margin-bottom: 20px;
      }
      
      .difficulty-options {
        grid-template-columns: 1fr;
        gap: 12px;
        margin-bottom: 20px;
      }
      
      .difficulty-card {
        padding: 14px 10px;
      }
      
      .difficulty-title {
        font-size: 1.1rem;
        margin-bottom: 6px;
      }
      
      .difficulty-desc {
        font-size: 0.85rem;
      }
      
      .back-btn {
        bottom: 10px;
        left: 10px;
        padding: 10px 15px;
        font-size: 0.85rem;
      }
    }

    /* Particle effects */
    .brick-particle {
      position: absolute;
      pointer-events: none;
      width: 4px;
      height: 4px;
      border-radius: 50%;
      animation: brick-explode 1s ease-out forwards;
    }

    @keyframes brick-explode {
      0% {
        opacity: 1;
        transform: scale(1);
      }
      100% {
        opacity: 0;
        transform: scale(0) translate(var(--dx), var(--dy));
      }
    }

    .powerup-icon {
      display: inline-block;
      animation: powerup-pulse 2s ease-in-out infinite;
    }

    @keyframes powerup-pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.2); }
    }

    /* Ball trail effect */
    .ball-trail {
      position: absolute;
      pointer-events: none;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--ball-white);
      opacity: 0.3;
      animation: ball-trail-fade 0.5s ease-out forwards;
    }

    @keyframes ball-trail-fade {
      0% { opacity: 0.3; transform: scale(1); }
      100% { opacity: 0; transform: scale(0.5); }
    }
  </style>
</head>
<body>
  <div id="gameContainer">
    <canvas id="gameCanvas" width="900" height="700"></canvas>
    
    <div class="hud" id="hud" style="display: none;">
      <div class="score-panel">
        <div class="score-item">
          <span class="score-label">Score:</span>
          <span class="score-value" id="scoreDisplay">0</span>
        </div>
        <div class="score-item">
          <span class="score-label">Level:</span>
          <span class="score-value" id="levelDisplay">1</span>
        </div>
        <div class="score-item">
          <span class="score-label">Lives:</span>
          <div class="lives-display" id="livesDisplay"></div>
        </div>
      </div>
      
      <div class="score-panel">
        <div class="score-item">
          <span class="score-label">High Score:</span>
          <span class="score-value" id="highScoreDisplay">0</span>
        </div>
        <div class="score-item">
          <span class="score-label">Bricks:</span>
          <span class="score-value" id="bricksDisplay">0</span>
        </div>
        <div class="score-item">
          <span class="score-label">Combo:</span>
          <span class="score-value" id="comboDisplay">x1</span>
        </div>
      </div>
    </div>

    <button class="back-btn" onclick="goHome()" title="Back to Main Menu">
      ← HOME
    </button>

    <div class="paused-overlay" id="pausedOverlay">
      <div>PAUSED<br><small style="font-size: 1rem;">Press P or Start to resume</small></div>
    </div>

    <div class="powerup-notification" id="powerupNotification">
      POWER UP!
    </div>

    <div class="touch-paddle" id="touchPaddle">
      Drag to Move Paddle
    </div>

    <!-- Menu overlay -->
    <div class="overlay" id="menuOverlay">
      <div class="menu-card">
        <h1 class="title">NEON BREAKOUT</h1>
        <p class="subtitle">Break blocks, collect power-ups, achieve glory!</p>
        
        <div class="difficulty-options">
          <div class="difficulty-card" data-difficulty="easy" onclick="selectDifficulty('easy')">
            <div class="difficulty-title">🟢 EASY</div>
            <div class="difficulty-desc">Slow ball<br>Extra lives<br>More power-ups</div>
          </div>
          <div class="difficulty-card active" data-difficulty="normal" onclick="selectDifficulty('normal')">
            <div class="difficulty-title">🟡 NORMAL</div>
            <div class="difficulty-desc">Balanced gameplay<br>Standard speed<br>Fair challenge</div>
          </div>
          <div class="difficulty-card" data-difficulty="hard" onclick="selectDifficulty('hard')">
            <div class="difficulty-title">🔴 HARD</div>
            <div class="difficulty-desc">Fast ball<br>Fewer lives<br>Intense action</div>
          </div>
          <div class="difficulty-card" data-difficulty="extreme" onclick="selectDifficulty('extreme')">
            <div class="difficulty-title">🟣 EXTREME</div>
            <div class="difficulty-desc">Lightning speed<br>One life<br>Pure skill</div>
          </div>
        </div>

        <div class="controls-info">
          <div class="control-section">
            <div class="control-title">Paddle Controls</div>
            <div>
              <span class="kbd">←</span><span class="kbd">→</span> or <span class="kbd">A</span><span class="kbd">D</span><br>
              Mouse movement • Touch/Drag
            </div>
          </div>
          <div class="control-section">
            <div class="control-title">Ball Control</div>
            <div>
              <span class="kbd">Space</span> Launch ball<br>
              <span class="kbd">Enter</span> Release from paddle
            </div>
          </div>
          <div class="control-section">
            <div class="control-title">Game Controls</div>
            <div>
              <span class="kbd">P</span> Pause • <span class="kbd">F</span> Fullscreen<br>
              <span class="kbd">R</span> Restart Level
            </div>
          </div>
        </div>

        <button class="btn" type="button" onclick="startGame();">START GAME</button>
      </div>
    </div>

    <!-- Game Over overlay -->
    <div class="overlay hidden" id="gameOverOverlay">
      <div class="menu-card">
        <h1 class="title">GAME OVER</h1>
        <div id="finalStats" style="margin: 25px 0; font-size: 1.3rem;"></div>
        <div style="display: flex; gap: 15px; justify-content: center; flex-wrap: wrap;">
          <button class="btn" onclick="event.stopPropagation(); restartGame();">PLAY AGAIN</button>
          <button class="btn" onclick="event.stopPropagation(); showMenu();">MAIN MENU</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Home Button -->
  <!-- <a href="../index.html" class="home-btn">
    <span>←</span>
    <span>HOME</span>
  </a> -->

  <script>
    // Game configuration
    const CONFIG = {
      CANVAS_WIDTH: 900,
      CANVAS_HEIGHT: 700,
      PADDLE_WIDTH: 120,
      PADDLE_HEIGHT: 15,
      PADDLE_SPEED: 8,
      BALL_SIZE: 12,
      BALL_SPEED: {
        easy: 5,
        normal: 7,
        hard: 9,
        extreme: 12
      },
      BRICK_WIDTH: 75,
      BRICK_HEIGHT: 25,
      BRICK_ROWS: 8,
      BRICK_COLS: 11,
      BRICK_PADDING: 5,
      BRICK_OFFSET_TOP: 80,
      LIVES: {
        easy: 5,
        normal: 3,
        hard: 2,
        extreme: 1
      },
      POWERUP_CHANCE: {
        easy: 0.3,
        normal: 0.2,
        hard: 0.15,
        extreme: 0.1
      },
      COLORS: {
        paddle: '#0080ff',
        ball: '#ffffff',
        bricks: ['#ff0040', '#ff6600', '#ffff00', '#00ff41', '#0080ff', '#8a2be2'],
        powerups: {
          multiball: '#ffff00',
          largepaddle: '#00ff41',
          slowball: '#0080ff',
          extralife: '#ff00ff',
          laser: '#ff0040',
          sticky: '#8a2be2'
        }
      },
      POINTS: {
        brick: 10,
        powerup: 50,
        levelBonus: 1000
      }
    };

    // Canvas and context - declare early
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    ctx.imageSmoothingEnabled = false;

    // Game loop timing
    let lastTime = 0;

    // Game state
    let gameState = {
      running: false,
      paused: false,
      difficulty: 'normal',
      level: 1,
      score: 0,
      highScore: 0,
      lives: 3,
      paddle: null,
      balls: [],
      bricks: [],
      powerups: [],
      particles: [],
      combo: 1,
      comboTimer: 0,
      ballStuck: true,
      powerupActive: {},
      powerupTimers: {},
      gameSpeed: 16, // 60fps
      lastUpdateTime: 0,
      pausePressed: false,
      fullscreenPressed: false,
      restartPressed: false
    };

    // Input handling
    class InputManager {
      constructor() {
        this.keys = new Set();
        this.mouseX = 0;
        this.mouseActive = false;
        this.touchX = 0;
        this.touchActive = false;
        this.gamepadIndex = -1;
        this.setupEventListeners();
      }

      setupEventListeners() {
        document.addEventListener('keydown', (e) => {
          this.keys.add(e.code);
          if (['ArrowLeft', 'ArrowRight', 'Space'].includes(e.code)) {
            e.preventDefault();
          }
        });

        document.addEventListener('keyup', (e) => {
          this.keys.delete(e.code);
        });

        // Mouse control - only when mouse button is held down
        canvas.addEventListener('mousedown', (e) => {
          this.mouseActive = true;
          const rect = canvas.getBoundingClientRect();
          this.mouseX = (e.clientX - rect.left) * (CONFIG.CANVAS_WIDTH / rect.width);
          e.preventDefault();
        });

        canvas.addEventListener('mousemove', (e) => {
          if (this.mouseActive) {
            const rect = canvas.getBoundingClientRect();
            this.mouseX = (e.clientX - rect.left) * (CONFIG.CANVAS_WIDTH / rect.width);
          }
        });

        canvas.addEventListener('mouseup', (e) => {
          this.mouseActive = false;
          e.preventDefault();
        });

        canvas.addEventListener('mouseleave', (e) => {
          this.mouseActive = false;
        });

        // Touch control
        const touchPaddle = document.getElementById('touchPaddle');
        touchPaddle.addEventListener('touchstart', (e) => {
          e.preventDefault();
          this.touchActive = true;
          this.updateTouchPosition(e.touches[0]);
        });

        touchPaddle.addEventListener('touchmove', (e) => {
          e.preventDefault();
          if (this.touchActive) {
            this.updateTouchPosition(e.touches[0]);
          }
        });

        touchPaddle.addEventListener('touchend', (e) => {
          e.preventDefault();
          this.touchActive = false;
        });

        // Gamepad support
        window.addEventListener('gamepadconnected', (e) => {
          console.log('Gamepad connected:', e.gamepad.id);
          this.gamepadIndex = e.gamepad.index;
        });

        window.addEventListener('gamepaddisconnected', (e) => {
          console.log('Gamepad disconnected');
          this.gamepadIndex = -1;
        });
      }

      updateTouchPosition(touch) {
        const rect = document.getElementById('gameContainer').getBoundingClientRect();
        this.touchX = ((touch.clientX - rect.left) / rect.width) * CONFIG.CANVAS_WIDTH;
      }

      getPaddleInput() {
        let targetX = gameState.paddle.x;
        let inputActive = false;

        // Gamepad input (check first to give priority)
        if (this.gamepadIndex >= 0) {
          const gamepads = navigator.getGamepads();
          const gamepad = gamepads[this.gamepadIndex];
          if (gamepad) {
            // Use left stick X-axis (index 0) or D-pad
            const rawLeftStickX = gamepad.axes[0];
            const dpadLeft = gamepad.buttons[14] && gamepad.buttons[14].pressed;
            const dpadRight = gamepad.buttons[15] && gamepad.buttons[15].pressed;
            
            // Apply proper deadzone and normalize the stick value
            let leftStickX = 0;
            const deadzone = 0.15;
            if (Math.abs(rawLeftStickX) > deadzone) {
              // Normalize the value to remove deadzone area
              leftStickX = (Math.abs(rawLeftStickX) - deadzone) / (1 - deadzone);
              leftStickX *= Math.sign(rawLeftStickX); // Restore original sign
            }
            
            if (leftStickX !== 0) {
              // Use analog stick - much more responsive
              targetX += leftStickX * CONFIG.PADDLE_SPEED * 3.0;
              inputActive = true;
            } else if (dpadLeft) {
              targetX -= CONFIG.PADDLE_SPEED;
              inputActive = true;
            } else if (dpadRight) {
              targetX += CONFIG.PADDLE_SPEED;
              inputActive = true;
            }
          }
        }

        // Only use other inputs if gamepad is not providing input
        if (!inputActive) {
          // Keyboard input
          if (this.keys.has('ArrowLeft') || this.keys.has('KeyA')) {
            targetX -= CONFIG.PADDLE_SPEED;
            inputActive = true;
          }
          if (this.keys.has('ArrowRight') || this.keys.has('KeyD')) {
            targetX += CONFIG.PADDLE_SPEED;
            inputActive = true;
          }

          // Mouse input (only when mouse button is held down)
          if (this.mouseActive) {
            targetX = this.mouseX;
            inputActive = true;
          }

          // Touch input
          if (this.touchActive) {
            targetX = this.touchX;
            inputActive = true;
          }
        }

        // If no input is active, stay at current position
        if (!inputActive) {
          targetX = gameState.paddle.x;
        }

        return Math.max(CONFIG.PADDLE_WIDTH / 2, 
               Math.min(CONFIG.CANVAS_WIDTH - CONFIG.PADDLE_WIDTH / 2, targetX));
      }

      isLaunchPressed() {
        let launched = this.keys.has('Space') || this.keys.has('Enter');
        
        // Gamepad launch (A button)
        if (this.gamepadIndex >= 0) {
          const gamepads = navigator.getGamepads();
          const gamepad = gamepads[this.gamepadIndex];
          if (gamepad && gamepad.buttons[0] && gamepad.buttons[0].pressed) {
            launched = true;
          }
        }
        
        return launched;
      }

      isPausePressed() {
        let paused = this.keys.has('KeyP');
        
        // Gamepad pause (Start button)
        if (this.gamepadIndex >= 0) {
          const gamepads = navigator.getGamepads();
          const gamepad = gamepads[this.gamepadIndex];
          if (gamepad && gamepad.buttons[9] && gamepad.buttons[9].pressed) {
            paused = true;
          }
        }
        
        return paused;
      }

      isFullscreenPressed() {
        return this.keys.has('KeyF');
      }

      isRestartPressed() {
        return this.keys.has('KeyR');
      }
    }

    // Audio system
    class AudioManager {
      constructor() {
        this.context = null;
        this.enabled = false;
      }

      async init() {
        try {
          this.context = new (window.AudioContext || window.webkitAudioContext)();
          if (this.context.state === 'suspended') {
            await this.context.resume();
          }
          this.enabled = true;
        } catch (e) {
          console.warn('Audio not available');
        }
      }

      playTone(frequency, duration = 0.1, type = 'square', volume = 0.1) {
        if (!this.enabled || !this.context) return;

        const oscillator = this.context.createOscillator();
        const gainNode = this.context.createGain();

        oscillator.connect(gainNode);
        gainNode.connect(this.context.destination);

        oscillator.frequency.value = frequency;
        oscillator.type = type;
        gainNode.gain.value = volume;

        oscillator.start();
        oscillator.stop(this.context.currentTime + duration);
      }

      playPaddleHit() {
        this.playTone(440, 0.1, 'square', 0.15);
      }

      playBrickHit() {
        this.playTone(880, 0.1, 'square', 0.12);
        setTimeout(() => this.playTone(660, 0.05, 'square', 0.08), 50);
      }

      playWallHit() {
        this.playTone(220, 0.1, 'square', 0.1);
      }

      playPowerUp() {
        this.playTone(1320, 0.2, 'sine', 0.15);
        setTimeout(() => this.playTone(1760, 0.2, 'sine', 0.15), 100);
      }

      playLifeLost() {
        for (let i = 0; i < 5; i++) {
          setTimeout(() => {
            this.playTone(440 - i * 80, 0.2, 'sawtooth', 0.1);
          }, i * 100);
        }
      }

      playLevelComplete() {
        for (let i = 0; i < 8; i++) {
          setTimeout(() => {
            this.playTone(440 + i * 110, 0.15, 'sine', 0.1);
          }, i * 100);
        }
      }
    }

    // Game entities
    class Paddle {
      constructor() {
        this.x = CONFIG.CANVAS_WIDTH / 2;
        this.y = CONFIG.CANVAS_HEIGHT - 50;
        this.width = CONFIG.PADDLE_WIDTH;
        this.height = CONFIG.PADDLE_HEIGHT;
        this.baseWidth = CONFIG.PADDLE_WIDTH;
      }

      update() {
        this.x = input.getPaddleInput();
        
        // Apply power-up effects
        if (gameState.powerupActive.largepaddle) {
          this.width = this.baseWidth * 1.5;
        } else {
          this.width = this.baseWidth;
        }

        // Check powerup collisions
        for (let i = gameState.powerups.length - 1; i >= 0; i--) {
          const powerup = gameState.powerups[i];
          if (this.isCollidingWith(powerup)) {
            powerup.collect();
            gameState.powerups.splice(i, 1);
            break;
          }
        }
      }

      isCollidingWith(rect) {
        return this.x + this.width/2 >= rect.x &&
               this.x - this.width/2 <= rect.x + rect.width &&
               this.y + this.height/2 >= rect.y &&
               this.y - this.height/2 <= rect.y + rect.height;
      }

      render(ctx) {
        const gradient = ctx.createLinearGradient(this.x - this.width/2, this.y, this.x + this.width/2, this.y);
        gradient.addColorStop(0, CONFIG.COLORS.paddle);
        gradient.addColorStop(0.5, '#ffffff');
        gradient.addColorStop(1, CONFIG.COLORS.paddle);
        
        ctx.fillStyle = gradient;
        ctx.shadowColor = CONFIG.COLORS.paddle;
        ctx.shadowBlur = 15;
        
        ctx.fillRect(this.x - this.width/2, this.y - this.height/2, this.width, this.height);
        ctx.shadowBlur = 0;
      }

      getBounds() {
        return {
          left: this.x - this.width / 2,
          right: this.x + this.width / 2,
          top: this.y - this.height / 2,
          bottom: this.y + this.height / 2
        };
      }
    }

    class Ball {
      constructor(x, y, vx, vy) {
        this.x = x || CONFIG.CANVAS_WIDTH / 2;
        this.y = y || CONFIG.CANVAS_HEIGHT - 90; // Move further from paddle
        this.vx = vx || 0;
        this.vy = vy || 0;
        this.size = CONFIG.BALL_SIZE;
        this.speed = CONFIG.BALL_SPEED[gameState.difficulty];
        this.stuck = gameState.ballStuck;
        this.trail = [];
        this.sticky = false;
        this.stickyTimer = 0;
        this.collisionCooldown = 0; // Prevent rapid bouncing
      }

      update() {
        // Reduce collision cooldown
        if (this.collisionCooldown > 0) {
          this.collisionCooldown--;
        }

        if (this.stuck) {
          // Ball follows paddle when stuck - position it safely above
          this.x = gameState.paddle.x;
          this.y = gameState.paddle.y - gameState.paddle.height/2 - this.size/2 - 8; // Safe distance above paddle
          
          if (input.isLaunchPressed() && !gameState.launchPressed) {
            this.launch();
            gameState.launchPressed = true;
            gameState.ballStuck = false; // Ensure stuck state is cleared
          }
          return;
        }

        // Handle sticky ball
        if (this.sticky && this.stickyTimer > 0) {
          this.stickyTimer--;
          if (this.stickyTimer <= 0) {
            this.sticky = false;
          } else {
            return; // Don't move while sticky
          }
        }

        // Add to trail
        this.trail.push({ x: this.x, y: this.y, time: Date.now() });
        this.trail = this.trail.filter(point => Date.now() - point.time < 200);

        // Apply power-up effects
        let currentSpeed = this.speed;
        if (gameState.powerupActive.slowball) {
          currentSpeed *= 0.6;
        }

        // Normalize velocity and apply speed
        const velocity = Math.hypot(this.vx, this.vy);
        if (velocity > 0) {
          this.vx = (this.vx / velocity) * currentSpeed;
          this.vy = (this.vy / velocity) * currentSpeed;
        }

        // Update position
        this.x += this.vx;
        this.y += this.vy;

        // Wall collisions
        if (this.x - this.size/2 <= 0 || this.x + this.size/2 >= CONFIG.CANVAS_WIDTH) {
          this.vx = -this.vx;
          this.x = Math.max(this.size/2, Math.min(CONFIG.CANVAS_WIDTH - this.size/2, this.x));
          audio.playWallHit();
        }

        if (this.y - this.size/2 <= 0) {
          this.vy = -this.vy;
          this.y = this.size/2;
          audio.playWallHit();
        }

        // Paddle collision
        this.checkPaddleCollision();

        // Brick collisions
        this.checkBrickCollisions();

        // Power-up collisions
        this.checkPowerupCollisions();

        // Check if ball is lost
        if (this.y > CONFIG.CANVAS_HEIGHT + 50) {
          this.lost = true;
        }
      }

      launch() {
        this.stuck = false;
        gameState.ballStuck = false;
        const angle = Math.PI / 4 + (Math.random() - 0.5) * Math.PI / 6; // Random angle upward
        this.vx = Math.cos(angle) * this.speed;
        this.vy = -Math.sin(angle) * this.speed;
      }

      checkPaddleCollision() {
        const paddle = gameState.paddle.getBounds();
        
        if (this.x >= paddle.left && this.x <= paddle.right &&
            this.y + this.size/2 >= paddle.top && this.y - this.size/2 <= paddle.bottom &&
            this.vy > 0) {
          
          // Calculate hit position (-1 to 1)
          const hitPos = (this.x - gameState.paddle.x) / (gameState.paddle.width / 2);
          
          // Adjust angle based on hit position
          const angle = hitPos * Math.PI / 3; // Max 60 degrees
          this.vx = Math.sin(angle) * this.speed;
          this.vy = -Math.cos(angle) * this.speed;
          
          this.y = paddle.top - this.size/2;
          
          // Handle sticky paddle
          if (gameState.powerupActive.sticky) {
            this.sticky = true;
            this.stickyTimer = 60; // 1 second at 60fps
          }
          
          audio.playPaddleHit();
        }
      }

      checkBrickCollisions() {
        // Skip collision check if in cooldown (prevents rapid bouncing)
        if (this.collisionCooldown > 0) {
          return;
        }

        for (let i = gameState.bricks.length - 1; i >= 0; i--) {
          const brick = gameState.bricks[i];
          if (!brick.destroyed && this.isCollidingWith(brick)) {
            brick.hit();
            
            // Set collision cooldown to prevent rapid bouncing
            this.collisionCooldown = 5; // Increased cooldown for better control
            
            // Determine collision side for better physics
            const ballCenterX = this.x;
            const ballCenterY = this.y;
            const brickCenterX = brick.x + brick.width / 2;
            const brickCenterY = brick.y + brick.height / 2;
            
            const deltaX = ballCenterX - brickCenterX;
            const deltaY = ballCenterY - brickCenterY;
            const absX = Math.abs(deltaX);
            const absY = Math.abs(deltaY);
            
            // Check for narrow gaps and prevent ball from squeezing through
            const ballRadius = this.size / 2;
            const requiredGap = ballRadius * 2 + 4; // Ball diameter + safety margin
            
            // Find nearby bricks to check for gaps
            const nearbyBricks = gameState.bricks.filter(b => 
              !b.destroyed && b !== brick &&
              Math.abs(b.x - brick.x) < brick.width + requiredGap &&
              Math.abs(b.y - brick.y) < brick.height + requiredGap
            );
            
            // Enhanced collision response with gap prevention
            const gap = 4; // Larger gap to prevent squeezing
            
            if (absX > absY) {
              // Hit from side - check for vertical gaps
              const checkingFromRight = deltaX > 0;
              let validPosition = true;
              
              // Check if there's a brick blocking the escape route
              for (const nearby of nearbyBricks) {
                if (checkingFromRight) {
                  // Ball trying to escape to the right
                  const escapeX = brick.x + brick.width + ballRadius + gap;
                  if (nearby.x <= escapeX + ballRadius && 
                      nearby.x + nearby.width >= escapeX - ballRadius &&
                      Math.abs(nearby.y - brick.y) < requiredGap) {
                    validPosition = false;
                    break;
                  }
                } else {
                  // Ball trying to escape to the left
                  const escapeX = brick.x - ballRadius - gap;
                  if (nearby.x <= escapeX + ballRadius && 
                      nearby.x + nearby.width >= escapeX - ballRadius &&
                      Math.abs(nearby.y - brick.y) < requiredGap) {
                    validPosition = false;
                    break;
                  }
                }
              }
              
              if (validPosition) {
                this.vx = -this.vx;
                if (deltaX > 0) {
                  this.x = brick.x + brick.width + ballRadius + gap;
                } else {
                  this.x = brick.x - ballRadius - gap;
                }
              } else {
                // Force vertical bounce instead of horizontal squeeze
                this.vy = -this.vy;
                if (deltaY > 0) {
                  this.y = brick.y + brick.height + ballRadius + gap;
                } else {
                  this.y = brick.y - ballRadius - gap;
                }
              }
            } else {
              // Hit from top/bottom - check for horizontal gaps
              const checkingFromBottom = deltaY > 0;
              let validPosition = true;
              
              // Check if there's a brick blocking the escape route
              for (const nearby of nearbyBricks) {
                if (checkingFromBottom) {
                  // Ball trying to escape downward
                  const escapeY = brick.y + brick.height + ballRadius + gap;
                  if (nearby.y <= escapeY + ballRadius && 
                      nearby.y + nearby.height >= escapeY - ballRadius &&
                      Math.abs(nearby.x - brick.x) < requiredGap) {
                    validPosition = false;
                    break;
                  }
                } else {
                  // Ball trying to escape upward
                  const escapeY = brick.y - ballRadius - gap;
                  if (nearby.y <= escapeY + ballRadius && 
                      nearby.y + nearby.height >= escapeY - ballRadius &&
                      Math.abs(nearby.x - brick.x) < requiredGap) {
                    validPosition = false;
                    break;
                  }
                }
              }
              
              if (validPosition) {
                this.vy = -this.vy;
                if (deltaY > 0) {
                  this.y = brick.y + brick.height + ballRadius + gap;
                } else {
                  this.y = brick.y - ballRadius - gap;
                }
              } else {
                // Force horizontal bounce instead of vertical squeeze
                this.vx = -this.vx;
                if (deltaX > 0) {
                  this.x = brick.x + brick.width + ballRadius + gap;
                } else {
                  this.x = brick.x - ballRadius - gap;
                }
              }
            }
            
            // Ensure minimum velocity to prevent getting stuck
            const minVelocity = 2.5;
            if (Math.abs(this.vx) < minVelocity) {
              this.vx = this.vx > 0 ? minVelocity : -minVelocity;
            }
            if (Math.abs(this.vy) < minVelocity) {
              this.vy = this.vy > 0 ? minVelocity : -minVelocity;
            }
            
            // Apply combo scoring
            gameState.score += Math.floor(CONFIG.POINTS.brick * gameState.combo);
            gameState.comboTimer = 120; // 2 seconds
            
            audio.playBrickHit();
            break; // Only process one collision per frame
          }
        }
      }

      checkPowerupCollisions() {
        // Powerups should be collected by paddle, not ball
      }

      isCollidingWith(rect) {
        // More precise collision detection with velocity prediction
        const ballLeft = this.x - this.size/2;
        const ballRight = this.x + this.size/2;
        const ballTop = this.y - this.size/2;
        const ballBottom = this.y + this.size/2;
        
        // Check current position
        const currentCollision = ballRight >= rect.x &&
                                ballLeft <= rect.x + rect.width &&
                                ballBottom >= rect.y &&
                                ballTop <= rect.y + rect.height;
        
        if (currentCollision) return true;
        
        // Check next frame position to prevent tunneling
        const nextX = this.x + this.vx;
        const nextY = this.y + this.vy;
        const nextBallLeft = nextX - this.size/2;
        const nextBallRight = nextX + this.size/2;
        const nextBallTop = nextY - this.size/2;
        const nextBallBottom = nextY + this.size/2;
        
        return nextBallRight >= rect.x &&
               nextBallLeft <= rect.x + rect.width &&
               nextBallBottom >= rect.y &&
               nextBallTop <= rect.y + rect.height;
      }

      render(ctx) {
        // Draw trail
        ctx.globalAlpha = 0.3;
        this.trail.forEach((point, index) => {
          const alpha = index / this.trail.length;
          ctx.globalAlpha = alpha * 0.3;
          ctx.fillStyle = CONFIG.COLORS.ball;
          ctx.beginPath();
          ctx.arc(point.x, point.y, this.size/2 * alpha, 0, Math.PI * 2);
          ctx.fill();
        });
        ctx.globalAlpha = 1;

        // Draw ball
        ctx.fillStyle = CONFIG.COLORS.ball;
        ctx.shadowColor = CONFIG.COLORS.ball;
        ctx.shadowBlur = 20;
        
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size/2, 0, Math.PI * 2);
        ctx.fill();
        
        // Add glow effect
        ctx.globalCompositeOperation = 'screen';
        ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size/3, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalCompositeOperation = 'source-over';
        
        ctx.shadowBlur = 0;
      }
    }

    class Brick {
      constructor(x, y, type) {
        this.x = x;
        this.y = y;
        this.width = CONFIG.BRICK_WIDTH;
        this.height = CONFIG.BRICK_HEIGHT;
        this.type = type;
        
        // Simple health system based on brick type
        this.health = type + 1; // Red=1, Orange=2, Yellow=3, Green=4, Blue=5, Purple=6
        this.maxHealth = this.health;
        
        this.destroyed = false;
        this.color = CONFIG.COLORS.bricks[type];
      }

      hit() {
        this.health--;
        if (this.health <= 0) {
          this.destroyed = true;
          this.explode();
          
          // Chance to spawn power-up
          if (Math.random() < CONFIG.POWERUP_CHANCE[gameState.difficulty]) {
            this.spawnPowerup();
          }
        }
      }

      explode() {
        // Create particle effect
        createBrickParticles(this.x + this.width/2, this.y + this.height/2, this.color);
      }

      spawnPowerup() {
        // Weighted powerup selection (extralife is much rarer)
        const rand = Math.random();
        let type;
        if (rand < 0.3) {
          type = 'largepaddle';
        } else if (rand < 0.5) {
          type = 'slowball';
        } else if (rand < 0.7) {
          type = 'multiball';
        } else if (rand < 0.85) {
          type = 'sticky';
        } else {
          type = 'extralife'; // Only 15% chance
        }
        gameState.powerups.push(new Powerup(this.x + this.width/2, this.y + this.height/2, type));
      }

      render(ctx) {
        if (this.destroyed) return;

        const alpha = this.health / this.maxHealth;
        const gradient = ctx.createLinearGradient(this.x, this.y, this.x + this.width, this.y + this.height);
        gradient.addColorStop(0, this.color);
        gradient.addColorStop(0.5, '#ffffff');
        gradient.addColorStop(1, this.color);
        
        ctx.globalAlpha = alpha;
        ctx.fillStyle = gradient;
        ctx.shadowColor = this.color;
        ctx.shadowBlur = 10;
        
        ctx.fillRect(this.x, this.y, this.width, this.height);
        
        // Add border
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
        ctx.lineWidth = 1;
        ctx.strokeRect(this.x, this.y, this.width, this.height);
        
        ctx.globalAlpha = 1;
        ctx.shadowBlur = 0;
      }
    }

    class Powerup {
      constructor(x, y, type) {
        this.x = x;
        this.y = y;
        this.width = 20;
        this.height = 20;
        this.type = type;
        this.vy = 3;
        this.color = CONFIG.COLORS.powerups[type];
        this.icon = this.getIcon();
        this.pulse = 0;
      }

      getIcon() {
        const icons = {
          multiball: '●●●',
          largepaddle: '═══',
          slowball: '⏲',
          extralife: '♥',
          laser: '⚡',
          sticky: '◉'
        };
        return icons[this.type] || '?';
      }

      update() {
        this.y += this.vy;
        this.pulse += 0.2;
        
        // Remove if off screen
        if (this.y > CONFIG.CANVAS_HEIGHT) {
          return false;
        }
        return true;
      }

      collect() {
        gameState.score += CONFIG.POINTS.powerup;
        this.activate();
        audio.playPowerUp();
        showPowerupNotification(this.type);
      }

      activate() {
        switch (this.type) {
          case 'multiball':
            // Create additional balls
            for (let i = 0; i < 2; i++) {
              const ball = gameState.balls[0];
              if (ball) {
                const angle = (Math.PI / 6) * (i - 0.5);
                const newBall = new Ball(ball.x, ball.y);
                newBall.vx = Math.cos(angle) * ball.speed;
                newBall.vy = Math.sin(angle) * ball.speed;
                newBall.stuck = false;
                gameState.balls.push(newBall);
              }
            }
            break;
            
          case 'largepaddle':
            gameState.powerupActive.largepaddle = true;
            gameState.powerupTimers.largepaddle = 600; // 10 seconds
            break;
            
          case 'slowball':
            gameState.powerupActive.slowball = true;
            gameState.powerupTimers.slowball = 480; // 8 seconds
            break;
            
          case 'extralife':
            gameState.lives++;
            break;
            
          case 'sticky':
            gameState.powerupActive.sticky = true;
            gameState.powerupTimers.sticky = 900; // 15 seconds
            break;
        }
      }

      render(ctx) {
        const scale = 1 + Math.sin(this.pulse) * 0.2;
        
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.scale(scale, scale);
        
        ctx.fillStyle = this.color;
        ctx.shadowColor = this.color;
        ctx.shadowBlur = 15;
        
        ctx.fillRect(-this.width/2, -this.height/2, this.width, this.height);
        
        // Draw icon
        ctx.fillStyle = '#000';
        ctx.font = '12px monospace';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(this.icon, 0, 0);
        
        ctx.restore();
        ctx.shadowBlur = 0;
      }
    }

    // Initialize game systems
    const input = new InputManager();
    const audio = new AudioManager();

    // Utility functions
    function createBrickParticles(x, y, color) {
      for (let i = 0; i < 8; i++) {
        const particle = document.createElement('div');
        particle.className = 'brick-particle';
        particle.style.left = x + 'px';
        particle.style.top = y + 'px';
        particle.style.background = color;
        
        const angle = (Math.PI * 2 * i) / 8;
        const distance = 30 + Math.random() * 20;
        const dx = Math.cos(angle) * distance;
        const dy = Math.sin(angle) * distance;
        
        particle.style.setProperty('--dx', dx + 'px');
        particle.style.setProperty('--dy', dy + 'px');
        
        document.getElementById('gameContainer').appendChild(particle);
        
        setTimeout(() => {
          if (particle.parentNode) {
            particle.parentNode.removeChild(particle);
          }
        }, 1000);
      }
    }

    function showPowerupNotification(type) {
      const notification = document.getElementById('powerupNotification');
      const messages = {
        multiball: 'MULTI-BALL!',
        largepaddle: 'LARGE PADDLE!',
        slowball: 'SLOW BALL!',
        extralife: 'EXTRA LIFE!',
        sticky: 'STICKY PADDLE!'
      };
      
      notification.textContent = messages[type] || 'POWER UP!';
      notification.classList.add('show');
      
      setTimeout(() => {
        notification.classList.remove('show');
      }, 2000);
    }

    // Game functions
    function initializeGame() {
      // Load high score
      gameState.highScore = parseInt(localStorage.getItem('breakout_highscore') || '0');
      
      // Create paddle
      gameState.paddle = new Paddle();
      
      // Create ball
      gameState.balls = [new Ball()];
      gameState.ballStuck = true;
      
      // Create bricks
      createBricks();
      
      // Reset state
      gameState.powerups = [];
      gameState.particles = [];
      gameState.combo = 1;
      gameState.comboTimer = 0;
      gameState.powerupActive = {};
      gameState.powerupTimers = {};
      
      // Set difficulty-based values
      gameState.lives = CONFIG.LIVES[gameState.difficulty];
      
      updateHUD();
    }

    function getBrickTypeForLevel(level, row) {
      // Define brick type distribution based on level
      let typeWeights;
      
      if (level === 1) {
        // Level 1: Mostly easy bricks (80% red/orange, 20% others)
        typeWeights = [0.5, 0.3, 0.15, 0.05, 0.0, 0.0]; // Red=50%, Orange=30%, Yellow=15%, Green=5%, Blue=0%, Purple=0%
      } else if (level === 2) {
        // Level 2: Introduce some yellow/green
        typeWeights = [0.4, 0.3, 0.2, 0.1, 0.0, 0.0]; // Red=40%, Orange=30%, Yellow=20%, Green=10%, Blue=0%, Purple=0%
      } else if (level === 3) {
        // Level 3: More variety, introduce blue
        typeWeights = [0.3, 0.25, 0.25, 0.15, 0.05, 0.0]; // Red=30%, Orange=25%, Yellow=25%, Green=15%, Blue=5%, Purple=0%
      } else if (level <= 5) {
        // Levels 4-5: Introduce purple, reduce easy bricks
        typeWeights = [0.2, 0.2, 0.25, 0.2, 0.1, 0.05]; // Red=20%, Orange=20%, Yellow=25%, Green=20%, Blue=10%, Purple=5%
      } else if (level <= 8) {
        // Levels 6-8: More challenging distribution
        typeWeights = [0.1, 0.15, 0.2, 0.25, 0.2, 0.1]; // Red=10%, Orange=15%, Yellow=20%, Green=25%, Blue=20%, Purple=10%
      } else {
        // High levels: Mostly tough bricks
        typeWeights = [0.05, 0.1, 0.15, 0.25, 0.25, 0.2]; // Red=5%, Orange=10%, Yellow=15%, Green=25%, Blue=25%, Purple=20%
      }
      
      // Row-based modifier (top rows slightly easier, bottom rows slightly harder)
      const rowModifier = row / (CONFIG.BRICK_ROWS - 1); // 0.0 at top, 1.0 at bottom
      
      // Adjust weights based on row position
      const adjustedWeights = typeWeights.map((weight, index) => {
        if (index <= 2) { // Easy bricks (red, orange, yellow)
          return weight * (1.2 - rowModifier * 0.4); // More likely at top
        } else { // Hard bricks (green, blue, purple)
          return weight * (0.8 + rowModifier * 0.4); // More likely at bottom
        }
      });
      
      // Convert weights to cumulative for random selection
      let cumulative = 0;
      const cumulativeWeights = adjustedWeights.map(weight => cumulative += weight);
      
      // Random selection based on weights
      const random = Math.random() * cumulative;
      for (let i = 0; i < cumulativeWeights.length; i++) {
        if (random <= cumulativeWeights[i]) {
          return i;
        }
      }
      
      return 0; // Fallback to red brick
    }

    function createBricks() {
      gameState.bricks = [];
      const startX = (CONFIG.CANVAS_WIDTH - (CONFIG.BRICK_COLS * (CONFIG.BRICK_WIDTH + CONFIG.BRICK_PADDING) - CONFIG.BRICK_PADDING)) / 2;
      
      // Level-based gap probability for more interesting layouts
      let gapChance;
      if (gameState.level === 1) {
        gapChance = 0.05; // Very few gaps on level 1 - keep it simple
      } else if (gameState.level <= 3) {
        gapChance = 0.1; // Some gaps on early levels
      } else if (gameState.level <= 6) {
        gapChance = 0.15; // More gaps on mid levels
      } else {
        gapChance = 0.2; // Lots of gaps on high levels - more strategic
      }
      
      for (let row = 0; row < CONFIG.BRICK_ROWS; row++) {
        for (let col = 0; col < CONFIG.BRICK_COLS; col++) {
          // Random gaps - skip some bricks
          if (Math.random() < gapChance) {
            continue; // Skip this brick, creating a gap
          }
          
          // Ensure we don't create complete empty rows (keep at least 3 bricks per row)
          const rowBrickCount = gameState.bricks.filter(b => 
            Math.abs(b.y - (CONFIG.BRICK_OFFSET_TOP + row * (CONFIG.BRICK_HEIGHT + CONFIG.BRICK_PADDING))) < 5
          ).length;
          
          if (rowBrickCount < 3 && col >= CONFIG.BRICK_COLS - 3) {
            // Force create brick if row is too empty and we're near the end
          } else if (Math.random() < gapChance && rowBrickCount >= 3) {
            continue; // Allow gap only if row has enough bricks
          }
          
          const x = startX + col * (CONFIG.BRICK_WIDTH + CONFIG.BRICK_PADDING);
          const y = CONFIG.BRICK_OFFSET_TOP + row * (CONFIG.BRICK_HEIGHT + CONFIG.BRICK_PADDING);
          
          // Level-based brick type distribution
          const type = getBrickTypeForLevel(gameState.level, row);
          gameState.bricks.push(new Brick(x, y, type));
        }
      }
      
      // Ensure we have at least 30 bricks total for playability
      if (gameState.bricks.length < 30) {
        // Add some random bricks if we have too few
        const missingBricks = 30 - gameState.bricks.length;
        for (let i = 0; i < missingBricks; i++) {
          const row = Math.floor(Math.random() * CONFIG.BRICK_ROWS);
          const col = Math.floor(Math.random() * CONFIG.BRICK_COLS);
          const x = startX + col * (CONFIG.BRICK_WIDTH + CONFIG.BRICK_PADDING);
          const y = CONFIG.BRICK_OFFSET_TOP + row * (CONFIG.BRICK_HEIGHT + CONFIG.BRICK_PADDING);
          const type = getBrickTypeForLevel(gameState.level, row);
          
          // Only add if position is not already occupied
          const existingBrick = gameState.bricks.find(b => 
            Math.abs(b.x - x) < 5 && Math.abs(b.y - y) < 5
          );
          if (!existingBrick) {
            gameState.bricks.push(new Brick(x, y, type));
          }
        }
      }
    }

    function updateGame() {
      if (!gameState.running || gameState.paused) return;

      // Update paddle
      gameState.paddle.update();

      // Update balls
      for (let i = gameState.balls.length - 1; i >= 0; i--) {
        gameState.balls[i].update();
        if (gameState.balls[i].lost) {
          gameState.balls.splice(i, 1);
        }
      }

      // If no balls left, lose a life
      if (gameState.balls.length === 0) {
        loseLife();
      }

      // Update power-ups
      for (let i = gameState.powerups.length - 1; i >= 0; i--) {
        if (!gameState.powerups[i].update()) {
          gameState.powerups.splice(i, 1);
        }
      }

      // Update power-up timers
      for (const [key, timer] of Object.entries(gameState.powerupTimers)) {
        gameState.powerupTimers[key]--;
        if (gameState.powerupTimers[key] <= 0) {
          delete gameState.powerupActive[key];
          delete gameState.powerupTimers[key];
        }
      }

      // Update combo timer
      if (gameState.comboTimer > 0) {
        gameState.comboTimer--;
        if (gameState.comboTimer <= 0) {
          gameState.combo = 1;
        } else {
          gameState.combo = Math.min(8, gameState.combo + 0.01);
        }
      }

      // Check win condition
      const activeBricks = gameState.bricks.filter(brick => !brick.destroyed);
      if (activeBricks.length === 0) {
        nextLevel();
      }

      updateHUD();
    }

    function loseLife() {
      gameState.lives--;
      audio.playLifeLost();
      
      if (gameState.lives <= 0) {
        endGame();
      } else {
        // Reset ball
        gameState.balls = [new Ball()];
        gameState.ballStuck = true;
        gameState.balls[0].stuck = true; // Ensure ball instance knows it's stuck
        gameState.launchPressed = false; // Reset launch state
        gameState.powerupActive = {};
        gameState.powerupTimers = {};
        gameState.powerups = [];
      }
    }

    function nextLevel() {
      gameState.level++;
      gameState.score += CONFIG.POINTS.levelBonus;
      audio.playLevelComplete();
      
      // Clear power-ups
      gameState.powerups = [];
      gameState.powerupActive = {};
      gameState.powerupTimers = {};
      
      // Create new bricks
      createBricks();
      
      // Reset ball
      gameState.balls = [new Ball()];
      gameState.ballStuck = true;
      gameState.balls[0].stuck = true; // Ensure ball instance knows it's stuck
      gameState.launchPressed = false; // Reset launch state
      
      // Increase difficulty progressively
      gameState.balls[0].speed = Math.min(15, CONFIG.BALL_SPEED[gameState.difficulty] + gameState.level * 0.5);
      
      // Make paddle faster on higher levels
      CONFIG.PADDLE_SPEED = Math.min(12, 8 + gameState.level * 0.3);
      
      // Reduce powerup frequency on higher levels
      const basePowerupChance = CONFIG.POWERUP_CHANCE[gameState.difficulty];
      CONFIG.POWERUP_CHANCE[gameState.difficulty] = Math.max(0.05, basePowerupChance - gameState.level * 0.01);
    }

    function handleInput() {
      if (!gameState.running) return;

      // Handle launch press state
      if (!input.isLaunchPressed()) {
        gameState.launchPressed = false;
      }

      // Check pause
      if (input.isPausePressed() && !gameState.pausePressed) {
        gameState.paused = !gameState.paused;
        document.getElementById('pausedOverlay').style.display = gameState.paused ? 'flex' : 'none';
        gameState.pausePressed = true;
      } else if (!input.isPausePressed()) {
        gameState.pausePressed = false;
      }

      // Check fullscreen
      if (input.isFullscreenPressed() && !gameState.fullscreenPressed) {
        toggleFullscreen();
        gameState.fullscreenPressed = true;
      } else if (!input.isFullscreenPressed()) {
        gameState.fullscreenPressed = false;
      }

      // Check restart
      if (input.isRestartPressed() && !gameState.restartPressed) {
        restartGame();
        gameState.restartPressed = true;
      } else if (!input.isRestartPressed()) {
        gameState.restartPressed = false;
      }
    }

    function render() {
      // Clear canvas with gradient background
      const gradient = ctx.createLinearGradient(0, 0, 0, CONFIG.CANVAS_HEIGHT);
      gradient.addColorStop(0, '#000011');
      gradient.addColorStop(0.5, '#000022');
      gradient.addColorStop(1, '#000033');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, CONFIG.CANVAS_WIDTH, CONFIG.CANVAS_HEIGHT);

      // Draw game entities
      gameState.bricks.forEach(brick => brick.render(ctx));
      gameState.powerups.forEach(powerup => powerup.render(ctx));
      gameState.paddle.render(ctx);
      gameState.balls.forEach(ball => ball.render(ctx));

      // Draw borders
      ctx.strokeStyle = 'rgba(0, 255, 255, 0.3)';
      ctx.lineWidth = 2;
      ctx.strokeRect(1, 1, CONFIG.CANVAS_WIDTH - 2, CONFIG.CANVAS_HEIGHT - 2);
    }

    function updateHUD() {
      document.getElementById('scoreDisplay').textContent = Math.floor(gameState.score).toLocaleString();
      document.getElementById('levelDisplay').textContent = gameState.level;
      document.getElementById('highScoreDisplay').textContent = Math.floor(gameState.highScore).toLocaleString();
      document.getElementById('bricksDisplay').textContent = gameState.bricks.filter(b => !b.destroyed).length;
      document.getElementById('comboDisplay').textContent = 'x' + Math.floor(gameState.combo);
      
      // Update lives display
      const livesDisplay = document.getElementById('livesDisplay');
      livesDisplay.innerHTML = '';
      for (let i = 0; i < gameState.lives; i++) {
        const lifeIcon = document.createElement('div');
        lifeIcon.className = 'life-icon';
        livesDisplay.appendChild(lifeIcon);
      }
    }

    function endGame() {
      gameState.running = false;
      
      // Update high score
      if (gameState.score > gameState.highScore) {
        gameState.highScore = gameState.score;
        localStorage.setItem('breakout_highscore', gameState.highScore.toString());
      }
      
      const statsHtml = `
        <div style="color: ${gameState.score > 0 ? '#00ff41' : '#ff0040'}; font-size: 2rem; margin-bottom: 15px;">
          ${gameState.score > 0 ? 'Game Complete!' : 'Game Over!'}
        </div>
        <div style="font-size: 1.4rem; margin-bottom: 15px;">Level ${gameState.level} Reached</div>
        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 15px;">
          <div style="padding: 15px; border: 2px solid #00ffff; border-radius: 10px;">
            <div style="color: #00ffff; font-weight: 700;">Final Score</div>
            <div style="font-size: 1.5rem;">${Math.floor(gameState.score).toLocaleString()}</div>
          </div>
          <div style="padding: 15px; border: 2px solid #ffff00; border-radius: 10px;">
            <div style="color: #ffff00; font-weight: 700;">High Score</div>
            <div style="font-size: 1.5rem;">${Math.floor(gameState.highScore).toLocaleString()}</div>
          </div>
          <div style="padding: 15px; border: 2px solid #ff00ff; border-radius: 10px;">
            <div style="color: #ff00ff; font-weight: 700;">Max Combo</div>
            <div style="font-size: 1.5rem;">x${Math.floor(gameState.combo)}</div>
          </div>
        </div>
      `;
      
      document.getElementById('finalStats').innerHTML = statsHtml;
      document.getElementById('gameOverOverlay').classList.remove('hidden');
    }

    // Game loop
    function gameLoop(currentTime) {
      if (currentTime - lastTime >= gameState.gameSpeed) {
        handleInput();
        updateGame();
        lastTime = currentTime;
      }
      
      render();
      
      if (gameState.running) {
        requestAnimationFrame(gameLoop);
      }
    }

    // UI functions
    function showMenu() {
      gameState.running = false;
      document.getElementById('menuOverlay').classList.remove('hidden');
      document.getElementById('gameOverOverlay').classList.add('hidden');
      document.getElementById('hud').style.display = 'none';
    }

    function startGame() {
      audio.init();
      gameState.running = true;
      gameState.paused = false;
      gameState.level = 1;
      gameState.score = 0;
      document.getElementById('menuOverlay').classList.add('hidden');
      document.getElementById('gameOverOverlay').classList.add('hidden');
      document.getElementById('pausedOverlay').style.display = 'none';
      document.getElementById('hud').style.display = 'flex';
      
      initializeGame();
      requestAnimationFrame(gameLoop);
    }

    function restartGame() {
      startGame();
    }

    function goHome() {
      console.log('goHome() called');
      console.trace('Call stack for goHome');
      window.location.href = '../index.html';
    }

    async function toggleFullscreen() {
      try {
        if (!document.fullscreenElement) {
          await canvas.requestFullscreen();
        } else {
          await document.exitFullscreen();
        }
      } catch (e) {
        console.warn('Fullscreen not supported');
      }
    }

    // Difficulty selection function (using onclick instead of addEventListener)
    function selectDifficulty(difficulty) {
      // Remove active from all cards
      const cards = document.querySelectorAll('.difficulty-card');
      cards.forEach(card => {
        card.classList.remove('active');
      });
      
      // Add active to clicked card
      const selectedCard = document.querySelector(`[data-difficulty="${difficulty}"]`);
      if (selectedCard) {
        selectedCard.classList.add('active');
        gameState.difficulty = difficulty;
      }
    }

    // Initialize
    showMenu();
    
    // Handle visibility change to pause game
    document.addEventListener('visibilitychange', () => {
      if (document.hidden && gameState.running && !gameState.paused) {
        gameState.paused = true;
        document.getElementById('pausedOverlay').style.display = 'flex';
      }
    });
  </script>
</body>
</html>
