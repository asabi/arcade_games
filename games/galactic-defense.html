<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Galactic Defense - Space Tower Defense</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');
    
    :root {
      --bg-space: #000011;
      --defense-turret: #00ffff;
      --enemy-red: #ff0040;
      --projectile-blue: #0080ff;
      --powerup-green: #00ff41;
      --shield-purple: #8a2be2;
      --text-light: #e6f1ff;
      --neon-orange: #ff6600;
      --neon-yellow: #ffff00;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    html, body {
      height: 100%;
      background: var(--bg-space);
      color: var(--text-light);
      font-family: 'Orbitron', monospace;
      overflow: hidden;
      user-select: none;
      -webkit-user-select: none;
      touch-action: none;
    }

    #gameContainer {
      position: fixed;
      inset: 0;
      display: grid;
      place-items: center;
      background: 
        radial-gradient(circle at 20% 30%, rgba(0, 255, 255, 0.1) 0%, transparent 30%),
        radial-gradient(circle at 80% 70%, rgba(255, 0, 64, 0.1) 0%, transparent 30%),
        radial-gradient(circle at 50% 20%, rgba(138, 43, 226, 0.05) 0%, transparent 40%);
    }

    canvas {
      border: 4px solid var(--defense-turret);
      border-radius: 15px;
      background: 
        radial-gradient(2px 2px at 20% 30%, white, transparent),
        radial-gradient(2px 2px at 40% 70%, white, transparent),
        radial-gradient(1px 1px at 90% 40%, white, transparent),
        radial-gradient(1px 1px at 70% 90%, white, transparent),
        var(--bg-space);
      background-size: 200px 200px, 300px 300px, 150px 150px, 250px 250px;
      box-shadow: 
        0 0 50px rgba(0, 255, 255, 0.5),
        inset 0 0 50px rgba(0, 255, 255, 0.1);
    }

    .overlay {
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
      background: rgba(0, 0, 17, 0.9);
      backdrop-filter: blur(12px);
      overflow-y: auto;
      padding: 20px 0;
    }

    .menu-card {
      background: linear-gradient(135deg, rgba(0, 255, 255, 0.1), rgba(255, 0, 64, 0.1));
      border: 3px solid var(--defense-turret);
      border-radius: 25px;
      padding: 30px;
      text-align: center;
      max-width: 650px;
      width: 90vw;
      max-height: 90vh;
      overflow-y: auto;
      box-shadow: 
        0 0 60px rgba(0, 255, 255, 0.4),
        inset 0 0 40px rgba(0, 255, 255, 0.1);
    }

    .title {
      font-size: 3rem;
      font-weight: 900;
      margin-bottom: 15px;
      background: linear-gradient(45deg, var(--defense-turret), var(--enemy-red), var(--projectile-blue), var(--powerup-green));
      background-size: 400% 400%;
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      animation: gradient-flow 4s ease-in-out infinite;
    }

    .subtitle {
      font-size: 1.2rem;
      color: var(--text-light);
      margin-bottom: 25px;
      letter-spacing: 1px;
    }

    .controls {
      background: rgba(0, 255, 255, 0.1);
      border: 2px solid var(--defense-turret);
      border-radius: 15px;
      padding: 20px;
      margin: 20px 0;
      text-align: left;
    }

    .controls h3 {
      color: var(--defense-turret);
      margin-bottom: 15px;
      font-size: 1.1rem;
    }

    .control-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin: 10px 0;
      padding: 8px 0;
      border-bottom: 1px solid rgba(0, 255, 255, 0.2);
    }

    .key {
      background: rgba(0, 255, 255, 0.2);
      border: 1px solid var(--defense-turret);
      border-radius: 6px;
      padding: 4px 8px;
      font-family: monospace;
      font-weight: bold;
      color: var(--defense-turret);
      min-width: 30px;
      text-align: center;
    }

    .btn {
      background: linear-gradient(135deg, var(--defense-turret), var(--projectile-blue));
      border: none;
      border-radius: 25px;
      color: #000000;
      font-family: 'Orbitron', monospace;
      font-weight: 700;
      font-size: 1.1rem;
      padding: 15px 30px;
      margin: 10px;
      cursor: pointer;
      transition: all 0.3s ease;
      text-transform: uppercase;
      letter-spacing: 1px;
      box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
    }

    .btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 0 30px rgba(0, 255, 255, 0.5);
    }

    .btn:active {
      transform: translateY(0);
    }

    .stats {
      position: absolute;
      top: 20px;
      left: 20px;
      background: rgba(0, 0, 0, 0.7);
      border: 2px solid var(--defense-turret);
      border-radius: 10px;
      padding: 15px;
      color: var(--text-light);
      font-size: 0.9rem;
      backdrop-filter: blur(10px);
    }

    .stat-item {
      margin: 5px 0;
      display: flex;
      justify-content: space-between;
      min-width: 150px;
    }

    .stat-label {
      color: var(--defense-turret);
      font-weight: bold;
    }

    .stat-value {
      color: var(--text-light);
    }

    .game-over {
      background: linear-gradient(135deg, rgba(255, 0, 64, 0.1), rgba(255, 0, 255, 0.1));
      border-color: var(--enemy-red);
    }

    .game-over .title {
      background: linear-gradient(45deg, var(--enemy-red), var(--neon-orange));
      background-size: 400% 400%;
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .game-over .btn {
      background: linear-gradient(135deg, var(--enemy-red), var(--neon-orange));
      color: #ffffff;
    }

    /* Home Button - matches Asteroids style */
    .home-btn {
      position: fixed;
      bottom: 20px;
      left: 20px;
      background: linear-gradient(135deg, #ff0040, #ff2056);
      border: 2px solid #ff4070;
      border-radius: 8px;
      padding: 8px 16px;
      color: white;
      font-family: 'Orbitron', monospace;
      font-weight: 700;
      font-size: 0.85rem;
      cursor: pointer;
      transition: all 0.3s ease;
      z-index: 1000;
      text-decoration: none;
      display: flex;
      align-items: center;
      gap: 6px;
      backdrop-filter: blur(8px);
      box-shadow: 
        0 2px 10px rgba(255, 0, 64, 0.4),
        inset 0 0 15px rgba(255, 255, 255, 0.1);
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .home-btn:hover {
      background: linear-gradient(135deg, #ff2060, #ff4080);
      border-color: #ff6090;
      transform: translateY(-1px);
      box-shadow: 
        0 4px 15px rgba(255, 0, 64, 0.6),
        inset 0 0 20px rgba(255, 255, 255, 0.15);
    }

    .home-btn:active {
      transform: translateY(0px);
    }

    .home-btn:focus {
      outline: 2px solid rgba(255, 255, 255, 0.5);
      outline-offset: 2px;
    }

    @keyframes gradient-flow {
      0%, 100% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
    }

    .hidden {
      display: none !important;
    }
    
    @media (max-width: 768px) {
      .title {
        font-size: 2rem;
      }
      
      .subtitle {
        font-size: 1rem;
      }
      
      .menu-card {
        padding: 20px;
        margin: 10px;
      }
      
      .controls {
        padding: 15px;
      }
    }

    @media (max-width: 768px) {
      .home-btn {
        bottom: 15px;
        left: 15px;
        padding: 6px 12px;
        font-size: 0.75rem;
      }
    }

    @media (max-width: 480px) {
      .home-btn {
        bottom: 10px;
        left: 10px;
        padding: 5px 10px;
        font-size: 0.7rem;
        gap: 4px;
      }
    }
  </style>
</head>
<body>
  <div id="gameContainer">
    <canvas id="gameCanvas" width="1000" height="700"></canvas>
    
    <!-- Main Menu -->
    <div id="mainMenu" class="overlay">
      <div class="menu-card">
        <h1 class="title">GALACTIC DEFENSE</h1>
        <p class="subtitle">Defend the Galaxy from Alien Invaders</p>
        
        <div class="controls">
          <h3>üéÆ Controls</h3>
          <div class="control-item">
            <span>Move Turret</span>
            <span class="key">‚Üê ‚Üí</span>
          </div>
          <div class="control-item">
            <span>Fire</span>
            <span class="key">Space</span>
          </div>
          <div class="control-item">
            <span>Pause</span>
            <span class="key">P</span>
          </div>
        </div>
        
        <button id="startBtn" class="btn">Start Game</button>
      </div>
    </div>

    <!-- Pause Menu -->
    <div id="pauseMenu" class="overlay hidden">
      <div class="menu-card">
        <h1 class="title">PAUSED</h1>
        <p class="subtitle">Game is paused</p>
        <button id="resumeBtn" class="btn">Resume</button>
        <button id="restartBtn" class="btn">Restart</button>
        <button id="quitBtn" class="btn">Main Menu</button>
      </div>
    </div>

    <!-- Game Over Menu -->
    <div id="gameOverMenu" class="overlay hidden">
      <div class="menu-card game-over">
        <h1 class="title">GAME OVER</h1>
        <p class="subtitle">The galaxy has fallen</p>
        <div id="finalStats"></div>
        <button id="playAgainBtn" class="btn">Play Again</button>
        <button id="mainMenuBtn" class="btn">Main Menu</button>
      </div>
    </div>

    <!-- Game Stats -->
    <div id="gameStats" class="stats hidden">
      <div class="stat-item">
        <span class="stat-label">Score:</span>
        <span id="scoreValue" class="stat-value">0</span>
      </div>
      <div class="stat-item">
        <span class="stat-label">Wave:</span>
        <span id="waveValue" class="stat-value">1</span>
      </div>
      <div class="stat-item">
        <span class="stat-label">Lives:</span>
        <span id="livesValue" class="stat-value">3</span>
      </div>
    </div>
  </div>

  <!-- Home Button -->
  <a href="../index.html" class="home-btn">
    <span>‚Üê</span>
    <span>HOME</span>
  </a>

  <script>
    // Game configuration
    const CONFIG = {
      CANVAS_WIDTH: 1000,
      CANVAS_HEIGHT: 700,
      TURRET_SIZE: 20,
      TURRET_SPEED: 5,
      PROJECTILE_SPEED: 8,
      PROJECTILE_SIZE: 4,
      ENEMY_SIZE: 25,
      ENEMY_SPEED: 1.5,
      SPAWN_RATE: 0.008,
      WAVE_INCREASE: 0.002,
      LIVES: 5,
      COLORS: {
        turret: '#00ffff',
        projectile: '#0080ff',
        enemy: '#ff0040',
        powerup: '#00ff41',
        shield: '#8a2be2'
      }
    };

    // Game state
    let gameState = {
      running: false,
      paused: false,
      score: 0,
      wave: 1,
      lives: CONFIG.LIVES,
      turret: { x: 500, y: 650, width: CONFIG.TURRET_SIZE, height: CONFIG.TURRET_SIZE },
      projectiles: [],
      enemies: [],
      powerups: [],
      particles: [],
      gameSpeed: 16,
      lastUpdateTime: 0,
      spawnTimer: 0
    };

    // Input handling
    class InputManager {
      constructor() {
        this.keys = new Set();
        this.setupEventListeners();
      }

      setupEventListeners() {
        document.addEventListener('keydown', (e) => {
          this.keys.add(e.code);
          if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Space'].includes(e.code)) {
            e.preventDefault();
          }
        });

        document.addEventListener('keyup', (e) => {
          this.keys.delete(e.code);
        });
      }

      isKeyPressed(key) {
        return this.keys.has(key);
      }
    }

    // Game objects
    class Turret {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.width = CONFIG.TURRET_SIZE;
        this.height = CONFIG.TURRET_SIZE;
        this.color = CONFIG.COLORS.turret;
        this.fireCooldown = 0;
      }

      update(input) {
        // Move left/right
        if (input.isKeyPressed('ArrowLeft')) {
          this.x = Math.max(0, this.x - CONFIG.TURRET_SPEED);
        }
        if (input.isKeyPressed('ArrowRight')) {
          this.x = Math.min(CONFIG.CANVAS_WIDTH - this.width, this.x + CONFIG.TURRET_SPEED);
        }

        // Fire projectile
        if (input.isKeyPressed('Space') && this.fireCooldown <= 0) {
          this.fire();
          this.fireCooldown = 6;
        }

        if (this.fireCooldown > 0) this.fireCooldown--;
      }

      fire() {
        gameState.projectiles.push(new Projectile(
          this.x + this.width / 2,
          this.y,
          CONFIG.COLORS.projectile
        ));
      }

      draw(ctx) {
        ctx.fillStyle = this.color;
        ctx.fillRect(this.x, this.y, this.width, this.height);
        
        // Draw turret barrel
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(this.x + this.width / 2 - 2, this.y - 10, 4, 10);
      }
    }

    class Projectile {
      constructor(x, y, color) {
        this.x = x;
        this.y = y;
        this.width = CONFIG.PROJECTILE_SIZE;
        this.height = CONFIG.PROJECTILE_SIZE;
        this.color = color;
        this.speed = CONFIG.PROJECTILE_SPEED;
      }

      update() {
        this.y -= this.speed;
      }

      draw(ctx) {
        ctx.fillStyle = this.color;
        ctx.fillRect(this.x - this.width / 2, this.y, this.width, this.height);
      }

      isOffScreen() {
        return this.y < -this.height;
      }
    }

    class Enemy {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.width = CONFIG.ENEMY_SIZE;
        this.height = CONFIG.ENEMY_SIZE;
        this.color = CONFIG.COLORS.enemy;
        this.speed = CONFIG.ENEMY_SPEED + Math.random() * 2;
        this.health = 1;
      }

      update() {
        this.y += this.speed;
      }

      draw(ctx) {
        ctx.fillStyle = this.color;
        ctx.fillRect(this.x, this.y, this.width, this.height);
        
        // Draw alien eyes
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(this.x + 5, this.y + 5, 3, 3);
        ctx.fillRect(this.x + 12, this.y + 5, 3, 3);
      }

      isOffScreen() {
        return this.y > CONFIG.CANVAS_HEIGHT;
      }

      collidesWith(projectile) {
        return this.x < projectile.x + projectile.width &&
               this.x + this.width > projectile.x &&
               this.y < projectile.y + projectile.height &&
               this.y + this.height > projectile.y;
      }
    }

    class Powerup {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.width = 20;
        this.height = 20;
        this.color = CONFIG.COLORS.powerup;
        this.speed = 1;
        this.type = Math.random() < 0.5 ? 'shield' : 'rapidFire';
      }

      update() {
        this.y += this.speed;
      }

      draw(ctx) {
        ctx.fillStyle = this.color;
        ctx.fillRect(this.x, this.y, this.width, this.height);
        
        // Draw powerup symbol
        ctx.fillStyle = '#ffffff';
        if (this.type === 'shield') {
          ctx.fillRect(this.x + 8, this.y + 5, 4, 10);
        } else {
          ctx.fillRect(this.x + 5, this.y + 8, 10, 4);
        }
      }

      isOffScreen() {
        return this.y > CONFIG.CANVAS_HEIGHT;
      }
    }

    class Particle {
      constructor(x, y, color) {
        this.x = x;
        this.y = y;
        this.vx = (Math.random() - 0.5) * 4;
        this.vy = (Math.random() - 0.5) * 4;
        this.color = color;
        this.life = 30;
        this.maxLife = 30;
      }

      update() {
        this.x += this.vx;
        this.y += this.vy;
        this.life--;
      }

      draw(ctx) {
        ctx.globalAlpha = this.life / this.maxLife;
        ctx.fillStyle = this.color;
        ctx.fillRect(this.x, this.y, 3, 3);
        ctx.globalAlpha = 1;
      }

      isDead() {
        return this.life <= 0;
      }
    }

    // Game functions
    function init() {
      const canvas = document.getElementById('gameCanvas');
      const ctx = canvas.getContext('2d');
      
      canvas.width = CONFIG.CANVAS_WIDTH;
      canvas.height = CONFIG.CANVAS_HEIGHT;
      
      gameState.turret = new Turret(500, 650);
      gameState.projectiles = [];
      gameState.enemies = [];
      gameState.powerups = [];
      gameState.particles = [];
      
      input = new InputManager();
      
      // Button event listeners
      document.getElementById('startBtn').addEventListener('click', startGame);
      document.getElementById('resumeBtn').addEventListener('click', resumeGame);
      document.getElementById('restartBtn').addEventListener('click', restartGame);
      document.getElementById('quitBtn').addEventListener('click', showMainMenu);
      document.getElementById('playAgainBtn').addEventListener('click', restartGame);
      document.getElementById('mainMenuBtn').addEventListener('click', showMainMenu);
      
      showMainMenu();
    }

    function startGame() {
      gameState.running = true;
      gameState.paused = false;
      gameState.score = 0;
      gameState.wave = 1;
      gameState.lives = CONFIG.LIVES;
      gameState.spawnTimer = 0;
      
      hideElement('mainMenu');
      showElement('gameStats');
      
      gameLoop();
    }

    function pauseGame() {
      gameState.paused = true;
      showElement('pauseMenu');
    }

    function resumeGame() {
      gameState.paused = false;
      hideElement('pauseMenu');
      gameLoop();
    }

    function restartGame() {
      startGame();
    }

    function showMainMenu() {
      gameState.running = false;
      gameState.paused = false;
      hideElement('gameStats');
      hideElement('pauseMenu');
      hideElement('gameOverMenu');
      showElement('mainMenu');
    }

    function gameOver() {
      gameState.running = false;
      hideElement('gameStats');
      
      const finalStats = document.getElementById('finalStats');
      finalStats.innerHTML = `
        <div style="margin: 20px 0; padding: 15px; background: rgba(0,255,255,0.1); border-radius: 10px;">
          <div style="margin: 10px 0;">Final Score: ${gameState.score}</div>
          <div style="margin: 10px 0;">Waves Survived: ${gameState.wave}</div>
        </div>
      `;
      
      showElement('gameOverMenu');
    }

    function gameLoop() {
      if (!gameState.running || gameState.paused) return;
      
      update();
      render();
      
      setTimeout(gameLoop, gameState.gameSpeed);
    }

    function update() {
      // Handle input
      if (input.isKeyPressed('KeyP')) {
        pauseGame();
        return;
      }

      // Update turret
      gameState.turret.update(input);

      // Spawn enemies with capped difficulty and minimum delay
      const currentSpawnRate = CONFIG.SPAWN_RATE + (gameState.wave * CONFIG.WAVE_INCREASE);
      const maxSpawnRate = 0.015; // Cap the maximum spawn rate
      const minDelay = 0.5; // Minimum delay between spawns
      
      gameState.spawnTimer += Math.min(currentSpawnRate, maxSpawnRate);
      
      if (gameState.spawnTimer >= 1) {
        gameState.spawnTimer = 0;
        const x = Math.random() * (CONFIG.CANVAS_WIDTH - CONFIG.ENEMY_SIZE);
        gameState.enemies.push(new Enemy(x, -CONFIG.ENEMY_SIZE));
        
        // Add small delay to prevent overwhelming spawns
        setTimeout(() => {
          gameState.spawnTimer = minDelay;
        }, 100);
      }

      // Spawn powerups more frequently
      if (Math.random() < 0.003) {
        const x = Math.random() * (CONFIG.CANVAS_WIDTH - 20);
        gameState.powerups.push(new Powerup(x, -20));
      }

      // Update projectiles
      gameState.projectiles = gameState.projectiles.filter(proj => {
        proj.update();
        return !proj.isOffScreen();
      });

      // Update enemies
      gameState.enemies = gameState.enemies.filter(enemy => {
        enemy.update();
        
        // Check if enemy reached the bottom
        if (enemy.isOffScreen()) {
          gameState.lives--;
          if (gameState.lives <= 0) {
            gameOver();
            return false;
          }
          return false;
        }
        
        return true;
      });

      // Update powerups
      gameState.powerups = gameState.powerups.filter(powerup => {
        powerup.update();
        return !powerup.isOffScreen();
      });

      // Update particles
      gameState.particles = gameState.particles.filter(particle => {
        particle.update();
        return !particle.isDead();
      });

      // Check collisions
      checkCollisions();

      // Update wave - more gradual progression
      if (gameState.enemies.length === 0 && gameState.score > gameState.wave * 150) {
        gameState.wave++;
      }

      // Update UI
      updateUI();
    }

    function checkCollisions() {
      // Projectile vs Enemy collisions
      gameState.projectiles.forEach((proj, projIndex) => {
        gameState.enemies.forEach((enemy, enemyIndex) => {
          if (enemy.collidesWith(proj)) {
            // Remove projectile and enemy
            gameState.projectiles.splice(projIndex, 1);
            gameState.enemies.splice(enemyIndex, 1);
            
            // Add score
            gameState.score += 10;
            
            // Create explosion particles
            for (let i = 0; i < 8; i++) {
              gameState.particles.push(new Particle(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2, '#ffff00'));
            }
          }
        });
      });

      // Turret vs Powerup collisions
      gameState.powerups.forEach((powerup, index) => {
        if (gameState.turret.x < powerup.x + powerup.width &&
            gameState.turret.x + gameState.turret.width > powerup.x &&
            gameState.turret.y < powerup.y + powerup.height &&
            gameState.turret.y + gameState.turret.height > powerup.y) {
          
          gameState.powerups.splice(index, 1);
          
          if (powerup.type === 'shield') {
            gameState.lives = Math.min(gameState.lives + 1, CONFIG.LIVES + 2);
          } else {
            // Rapid fire effect
            gameState.turret.fireCooldown = 0;
          }
        }
      });
    }

    function render() {
      const canvas = document.getElementById('gameCanvas');
      const ctx = canvas.getContext('2d');
      
      // Clear canvas
      ctx.fillStyle = CONFIG.COLORS.bg || '#000011';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // Draw background stars
      drawBackground(ctx);
      
      // Draw game objects
      gameState.turret.draw(ctx);
      
      gameState.projectiles.forEach(proj => proj.draw(ctx));
      gameState.enemies.forEach(enemy => enemy.draw(ctx));
      gameState.powerups.forEach(powerup => powerup.draw(ctx));
      gameState.particles.forEach(particle => particle.draw(ctx));
    }

    function drawBackground(ctx) {
      ctx.fillStyle = '#ffffff';
      for (let i = 0; i < 100; i++) {
        const x = (i * 37) % CONFIG.CANVAS_WIDTH;
        const y = (i * 73) % CONFIG.CANVAS_HEIGHT;
        const size = (i % 3) + 1;
        ctx.fillRect(x, y, size, size);
      }
    }

    function updateUI() {
      document.getElementById('scoreValue').textContent = gameState.score;
      document.getElementById('waveValue').textContent = gameState.wave;
      document.getElementById('livesValue').textContent = gameState.lives;
    }

    function showElement(id) {
      document.getElementById(id).classList.remove('hidden');
    }

    function hideElement(id) {
      document.getElementById(id).classList.add('hidden');
    }

    function goHome() {
      window.location.href = '../index.html';
    }

    // Initialize game
    let input;
    init();
  </script>
</body>
</html>
