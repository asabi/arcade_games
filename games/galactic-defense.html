<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Galactic Defense - Space Tower Defense</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');
    
    :root {
      --bg-space: #000011;
      --defense-turret: #00ffff;
      --enemy-red: #ff0040;
      --projectile-blue: #0080ff;
      --powerup-green: #00ff41;
      --shield-purple: #8a2be2;
      --text-light: #e6f1ff;
      --neon-orange: #ff6600;
      --neon-yellow: #ffff00;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    html, body {
      height: 100%;
      background: var(--bg-space);
      color: var(--text-light);
      font-family: 'Orbitron', monospace;
      overflow: hidden;
      user-select: none;
      -webkit-user-select: none;
      touch-action: none;
      /* Force crisp text rendering globally */
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      text-rendering: optimizeLegibility;
    }

    #gameContainer {
      position: fixed;
      inset: 0;
      display: grid;
      place-items: center;
      background: 
        radial-gradient(circle at 20% 30%, rgba(0, 255, 255, 0.1) 0%, transparent 30%),
        radial-gradient(circle at 80% 70%, rgba(255, 0, 64, 0.1) 0%, transparent 30%),
        radial-gradient(circle at 50% 20%, rgba(138, 43, 226, 0.05) 0%, transparent 40%);
      /* Force crisp text rendering */
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      text-rendering: optimizeLegibility;
    }

    canvas {
      border: 4px solid var(--defense-turret);
      border-radius: 15px;
      background: 
        radial-gradient(2px 2px at 20% 30%, white, transparent),
        radial-gradient(2px 2px at 40% 70%, white, transparent),
        radial-gradient(1px 1px at 90% 40%, white, transparent),
        radial-gradient(1px 1px at 70% 90%, white, transparent),
        var(--bg-space);
      background-size: 200px 200px, 300px 300px, 150px 150px, 250px 250px;
      box-shadow: 
        0 0 50px rgba(0, 255, 255, 0.5),
        inset 0 0 50px rgba(0, 255, 255, 0.1);
    }

    .overlay {
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
      background: rgba(0, 0, 17, 0.9);
      backdrop-filter: blur(12px);
      overflow-y: auto;
      padding: 20px 0;
    }

    .menu-card {
      background: linear-gradient(135deg, rgba(0, 255, 255, 0.1), rgba(255, 0, 64, 0.1));
      border: 3px solid var(--defense-turret);
      border-radius: 25px;
      padding: 30px;
      text-align: center;
      max-width: 650px;
      width: 90vw;
      max-height: 90vh;
      overflow-y: auto;
      box-shadow: 
        0 0 60px rgba(0, 255, 255, 0.4),
        inset 0 0 40px rgba(0, 255, 255, 0.1);
    }

    .title {
      font-size: 3rem;
      font-weight: 900;
      margin-bottom: 15px;
      background: linear-gradient(45deg, var(--defense-turret), var(--enemy-red), var(--projectile-blue), var(--powerup-green));
      background-size: 400% 400%;
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      animation: gradient-flow 4s ease-in-out infinite;
    }

    .subtitle {
      font-size: 1.2rem;
      color: var(--text-light);
      margin-bottom: 25px;
      letter-spacing: 1px;
    }

    .controls {
      background: rgba(0, 255, 255, 0.1);
      border: 2px solid var(--defense-turret);
      border-radius: 15px;
      padding: 20px;
      margin: 20px 0;
      text-align: left;
    }

    .controls h3 {
      color: var(--defense-turret);
      margin-bottom: 15px;
      font-size: 1.1rem;
    }

    .control-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin: 10px 0;
      padding: 8px 0;
      border-bottom: 1px solid rgba(0, 255, 255, 0.2);
    }

    .key {
      background: rgba(0, 255, 255, 0.2);
      border: 1px solid var(--defense-turret);
      border-radius: 6px;
      padding: 4px 8px;
      font-family: monospace;
      font-weight: bold;
      color: var(--defense-turret);
      min-width: 30px;
      text-align: center;
    }

    .btn {
      background: linear-gradient(135deg, var(--defense-turret), var(--projectile-blue));
      border: none;
      border-radius: 25px;
      color: #000000;
      font-family: 'Orbitron', monospace;
      font-weight: 700;
      font-size: 1.1rem;
      padding: 15px 30px;
      margin: 10px;
      cursor: pointer;
      transition: all 0.3s ease;
      text-transform: uppercase;
      letter-spacing: 1px;
      box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
    }

    .btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 0 30px rgba(0, 255, 255, 0.5);
    }

    .btn:active {
      transform: translateY(0);
    }

    .stats {
      position: absolute;
      top: 20px;
      left: 20px;
      background: #000000;
      border: 2px solid #00ffff;
      border-radius: 10px;
      padding: 15px;
      color: #ffffff;
      font-size: 0.9rem;
      /* Completely new CSS to ensure no blur */
      box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
      /* Force crisp text rendering */
      -webkit-font-smoothing: antialiased !important;
      -moz-osx-font-smoothing: grayscale !important;
      text-rendering: optimizeLegibility !important;
      /* Explicitly prevent any blur effects */
      filter: none !important;
      backdrop-filter: none !important;
      /* Additional clarity */
      z-index: 1000;
      font-family: 'Courier New', monospace !important;
    }

    .stat-item {
      margin: 5px 0;
      display: flex;
      justify-content: space-between;
      min-width: 150px;
      /* Ensure crisp text */
      -webkit-font-smoothing: antialiased !important;
      -moz-osx-font-smoothing: grayscale !important;
      text-rendering: optimizeLegibility !important;
    }

    .stat-label {
      color: #00ffff !important;
      font-weight: bold !important;
      font-family: 'Courier New', monospace !important;
      -webkit-font-smoothing: antialiased !important;
      -moz-osx-font-smoothing: grayscale !important;
      text-rendering: optimizeLegibility !important;
      /* Force crisp rendering */
      filter: none !important;
      backdrop-filter: none !important;
      /* Additional clarity */
      font-size: 0.9rem !important;
      line-height: 1.2 !important;
    }

    .stat-value {
      color: #00ffff !important;
      font-weight: bold !important;
      font-family: 'Courier New', monospace !important;
      letter-spacing: 1px !important;
      -webkit-font-smoothing: antialiased !important;
      -moz-osx-font-smoothing: grayscale !important;
      text-shadow: 0 0 2px #00ffff !important;
      text-rendering: optimizeLegibility !important;
      font-smooth: never !important;
      transform: translateZ(0) !important;
      /* Force crisp rendering */
      filter: none !important;
      backdrop-filter: none !important;
      /* Additional clarity */
      font-size: 1rem !important;
      line-height: 1.2 !important;
      /* Override any potential inherited blur */
      backdrop-filter: none !important;
      -webkit-backdrop-filter: none !important;
      /* Force hardware acceleration */
      will-change: auto !important;
      backface-visibility: hidden !important;
    }

    .game-over {
      background: linear-gradient(135deg, rgba(255, 0, 64, 0.1), rgba(255, 0, 255, 0.1));
      border-color: var(--enemy-red);
    }

    .game-over .title {
      background: linear-gradient(45deg, var(--enemy-red), var(--neon-orange));
      background-size: 400% 400%;
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .game-over .btn {
      background: linear-gradient(135deg, var(--enemy-red), var(--neon-orange));
      color: #ffffff;
    }

    /* Home Button - matches Asteroids style */
    .home-btn {
      position: fixed;
      bottom: 20px;
      left: 20px;
      background: linear-gradient(135deg, #ff0040, #ff2056);
      border: 2px solid #ff4070;
      border-radius: 8px;
      padding: 8px 16px;
      color: white;
      font-family: 'Orbitron', monospace;
      font-weight: 700;
      font-size: 0.85rem;
      cursor: pointer;
      transition: all 0.3s ease;
      z-index: 1000;
      text-decoration: none;
      display: flex;
      align-items: center;
      gap: 6px;
      backdrop-filter: blur(8px);
      box-shadow: 
        0 2px 10px rgba(255, 0, 64, 0.4),
        inset 0 0 15px rgba(255, 255, 255, 0.1);
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .home-btn:hover {
      background: linear-gradient(135deg, #ff2060, #ff4080);
      border-color: #ff6090;
      transform: translateY(-1px);
      box-shadow: 
        0 4px 15px rgba(255, 0, 64, 0.6),
        inset 0 0 20px rgba(255, 255, 255, 0.15);
    }

    .home-btn:active {
      transform: translateY(0px);
    }

    .home-btn:focus {
      outline: 2px solid rgba(255, 255, 255, 0.5);
      outline-offset: 2px;
    }

    @keyframes gradient-flow {
      0%, 100% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
    }

    .hidden {
      display: none !important;
    }
    
    /* Side Panels */
    .side-panel {
      position: absolute;
      top: 0;
      width: 200px;
      height: 100%;
      background: linear-gradient(90deg, 
        rgba(0, 255, 255, 0.1) 0%, 
        rgba(0, 0, 0, 0.3) 50%, 
        transparent 100%);
      /* Temporarily disabled backdrop-filter to test if it affects stats */
      /* backdrop-filter: blur(5px); */
      border: 1px solid rgba(0, 255, 255, 0.3);
      z-index: 10;
    }
    
    .left-panel {
      left: 0;
      border-right: 2px solid rgba(0, 255, 255, 0.5);
    }
    
    .right-panel {
      right: 0;
      border-left: 2px solid rgba(0, 255, 255, 0.5);
      background: linear-gradient(270deg, 
        rgba(0, 255, 255, 0.1) 0%, 
        rgba(0, 0, 0, 0.3) 50%, 
        transparent 100%);
    }
    
    .panel-content {
      padding: 20px;
      height: 100%;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
    }
    
    /* Energy Bar */
    .energy-bar {
      width: 100%;
      height: 8px;
      background: rgba(0, 0, 0, 0.5);
      border: 1px solid var(--defense-turret);
      border-radius: 4px;
      overflow: hidden;
    }
    
    .energy-fill {
      height: 100%;
      background: linear-gradient(90deg, var(--defense-turret), var(--powerup-green));
      width: 75%;
      animation: energy-pulse 2s ease-in-out infinite;
    }
    
    @keyframes energy-pulse {
      0%, 100% { opacity: 0.8; }
      50% { opacity: 1; }
    }
    
    /* Space Station */
    .space-station {
      display: flex;
      flex-direction: column;
      align-items: center;
      margin: 20px 0;
    }
    
    .station-core {
      width: 20px;
      height: 20px;
      background: var(--defense-turret);
      border-radius: 50%;
      animation: station-rotate 8s linear infinite;
    }
    
    .station-ring {
      width: 40px;
      height: 40px;
      border: 2px solid var(--defense-turret);
      border-radius: 50%;
      margin-top: -10px;
      animation: station-rotate 12s linear infinite reverse;
    }
    
    @keyframes station-rotate {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }
    
    /* Floating Debris */
    .floating-debris {
      position: relative;
      height: 100px;
    }
    
    .debris {
      position: absolute;
      width: 4px;
      height: 4px;
      background: var(--neon-orange);
      border-radius: 50%;
      animation: float-debris 6s ease-in-out infinite;
    }
    
    .debris:nth-child(1) {
      left: 20px;
      animation-delay: 0s;
    }
    
    .debris:nth-child(2) {
      left: 60px;
      animation-delay: 2s;
    }
    
    .debris:nth-child(3) {
      left: 100px;
      animation-delay: 4s;
    }
    
    @keyframes float-debris {
      0%, 100% { transform: translateY(0px) rotate(0deg); opacity: 0.5; }
      50% { transform: translateY(-20px) rotate(180deg); opacity: 1; }
    }
    
    /* Radar Dish */
    .radar-dish {
      display: flex;
      flex-direction: column;
      align-items: center;
      margin: 20px 0;
    }
    
    .dish-base {
      width: 30px;
      height: 15px;
      background: var(--defense-turret);
      border-radius: 15px 15px 0 0;
    }
    
    .dish-scan {
      width: 50px;
      height: 25px;
      border: 2px solid var(--defense-turret);
      border-radius: 25px 25px 0 0;
      margin-top: -5px;
      animation: radar-scan 3s ease-in-out infinite;
    }
    
    @keyframes radar-scan {
      0% { transform: scaleY(1); opacity: 0.7; }
      50% { transform: scaleY(1.2); opacity: 1; }
      100% { transform: scaleY(1); opacity: 0.7; }
    }
    
    /* Data Stream */
    .data-stream {
      position: relative;
      height: 80px;
    }
    
    .data-line {
      position: absolute;
      height: 2px;
      background: var(--powerup-green);
      animation: data-flow 4s linear infinite;
    }
    
    .data-line:nth-child(1) {
      width: 60px;
      left: 0;
      animation-delay: 0s;
    }
    
    .data-line:nth-child(2) {
      width: 40px;
      left: 20px;
      animation-delay: 1.5s;
    }
    
    .data-line:nth-child(3) {
      width: 80px;
      left: 10px;
      animation-delay: 3s;
    }
    
    @keyframes data-flow {
      0% { transform: translateX(-100px); opacity: 0; }
      50% { opacity: 1; }
      100% { transform: translateX(100px); opacity: 0; }
    }
    
    /* Warning Lights */
    .warning-lights {
      display: flex;
      justify-content: space-around;
      margin-top: auto;
    }
    
    .light {
      width: 8px;
      height: 8px;
      background: var(--enemy-red);
      border-radius: 50%;
      animation: warning-blink 1.5s ease-in-out infinite;
    }
    
    .light:nth-child(2) {
      animation-delay: 0.5s;
    }
    
    .light:nth-child(3) {
      animation-delay: 1s;
    }
    
    @keyframes warning-blink {
      0%, 100% { opacity: 0.3; transform: scale(1); }
      50% { opacity: 1; transform: scale(1.2); }
    }
    
    @media (max-width: 768px) {
      .title {
        font-size: 2rem;
      }
      
      .subtitle {
        font-size: 1rem;
      }
      
      .menu-card {
        padding: 20px;
        margin: 10px;
      }
      
      .controls {
        padding: 15px;
      }
      
      /* Hide side panels on mobile */
      .side-panel {
        display: none;
      }
      
      /* Center canvas on mobile */
      #gameCanvas {
        margin: 0 auto;
      }
    }

    @media (max-width: 768px) {
      .home-btn {
        bottom: 15px;
        left: 15px;
        padding: 6px 12px;
        font-size: 0.75rem;
      }
    }

    @media (max-width: 480px) {
      .home-btn {
        bottom: 10px;
        left: 10px;
        padding: 5px 10px;
        font-size: 0.7rem;
        gap: 4px;
      }
    }
  </style>
</head>
<body>
  <div id="gameContainer">
    <!-- Left Side Panel -->
    <div class="side-panel left-panel">
      <div class="panel-content">
        <div class="energy-bar">
          <div class="energy-fill"></div>
        </div>
        <div class="space-station">
          <div class="station-core"></div>
          <div class="station-ring"></div>
        </div>
        <div class="floating-debris">
          <div class="debris"></div>
          <div class="debris"></div>
          <div class="debris"></div>
        </div>
      </div>
    </div>
    
    <!-- Right Side Panel -->
    <div class="side-panel right-panel">
      <div class="panel-content">
        <div class="radar-dish">
          <div class="dish-base"></div>
          <div class="dish-scan"></div>
        </div>
        <div class="data-stream">
          <div class="data-line"></div>
          <div class="data-line"></div>
          <div class="data-line"></div>
        </div>
        <div class="warning-lights">
          <div class="light"></div>
          <div class="light"></div>
          <div class="light"></div>
        </div>
      </div>
    </div>
    
    <canvas id="gameCanvas" width="600" height="700"></canvas>
    
    <!-- Main Menu -->
    <div id="mainMenu" class="overlay">
      <div class="menu-card">
        <h1 class="title">GALACTIC DEFENSE</h1>
        <p class="subtitle">Defend the Galaxy from Alien Invaders</p>
        
        <div class="controls">
          <h3>🎮 Controls</h3>
          <div class="control-item">
            <span>Move Turret</span>
            <span class="key">← →</span>
          </div>
          <div class="control-item">
            <span>Fire</span>
            <span class="key">Space</span>
          </div>
          <div class="control-item">
            <span>Pause</span>
            <span class="key">P</span>
          </div>
        </div>
        
        <button id="startBtn" class="btn">Start Game</button>
      </div>
    </div>

    <!-- Pause Menu -->
    <div id="pauseMenu" class="overlay hidden">
      <div class="menu-card">
        <h1 class="title">PAUSED</h1>
        <p class="subtitle">Game is paused</p>
        <button id="resumeBtn" class="btn">Resume</button>
        <button id="restartBtn" class="btn">Restart</button>
        <button id="quitBtn" class="btn">Main Menu</button>
      </div>
    </div>

    <!-- Game Over Menu -->
    <div id="gameOverMenu" class="overlay hidden">
      <div class="menu-card game-over">
        <h1 class="title">GAME OVER</h1>
        <p class="subtitle">The galaxy has fallen</p>
        <div id="finalStats"></div>
        <button id="playAgainBtn" class="btn">Play Again</button>
        <button id="mainMenuBtn" class="btn">Main Menu</button>
      </div>
    </div>

    <!-- Game Stats -->
    <div id="gameStats" class="stats hidden">
      <div class="stat-item">
        <span class="stat-label">Score:</span>
        <span id="scoreValue" class="stat-value">0</span>
      </div>
      <div class="stat-item">
        <span class="stat-label">Wave:</span>
        <span id="waveValue" class="stat-value">1</span>
      </div>
      <div class="stat-item">
        <span class="stat-label">Lives:</span>
        <span id="livesValue" class="stat-value">3</span>
      </div>
    </div>
  </div>

  <!-- Home Button -->
  <a href="../index.html" class="home-btn">
    <span>←</span>
    <span>HOME</span>
  </a>

  <script>
    // Game configuration
    const CONFIG = {
      CANVAS_WIDTH: 600,
      CANVAS_HEIGHT: 700,
      TURRET_SIZE: 20,
      TURRET_SPEED: 6,
      PROJECTILE_SPEED: 8,
      PROJECTILE_SIZE: 4,
      ENEMY_SIZE: 25,
      ENEMY_SPEED: 1.5,
      SPAWN_RATE: 0.008,
      WAVE_INCREASE: 0.002,
      LIVES: 5,
      COLORS: {
        turret: '#00ffff',
        projectile: '#0080ff',
        enemy: '#ff0040',
        powerup: '#00ff41',
        shield: '#8a2be2'
      }
    };

    // Game state
    let gameState = {
      running: false,
      paused: false,
      score: 0,
      wave: 1,
      lives: CONFIG.LIVES,
      turret: { x: 500, y: 650, width: CONFIG.TURRET_SIZE, height: CONFIG.TURRET_SIZE },
      projectiles: [],
      enemies: [],
      powerups: [],
      particles: [],
      gameSpeed: 16,
      lastUpdateTime: 0,
      spawnTimer: 0
    };

    // Input handling
    class InputManager {
      constructor() {
        this.keys = new Set();
        this.setupEventListeners();
      }

      setupEventListeners() {
        document.addEventListener('keydown', (e) => {
          this.keys.add(e.code);
          if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Space'].includes(e.code)) {
            e.preventDefault();
          }
        });

        document.addEventListener('keyup', (e) => {
          this.keys.delete(e.code);
        });
      }

      isKeyPressed(key) {
        return this.keys.has(key);
      }
    }

    // Game objects
    class Turret {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.width = CONFIG.TURRET_SIZE;
        this.height = CONFIG.TURRET_SIZE;
        this.color = CONFIG.COLORS.turret;
        this.fireCooldown = 0;
      }

      update(input) {
        // Move left/right
        if (input.isKeyPressed('ArrowLeft')) {
          this.x = Math.max(0, this.x - CONFIG.TURRET_SPEED);
        }
        if (input.isKeyPressed('ArrowRight')) {
          this.x = Math.min(CONFIG.CANVAS_WIDTH - this.width, this.x + CONFIG.TURRET_SPEED);
        }

        // Fire projectile
        if (input.isKeyPressed('Space') && this.fireCooldown <= 0) {
          this.fire();
          this.fireCooldown = 6;
        }

        if (this.fireCooldown > 0) this.fireCooldown--;
      }

      fire() {
        gameState.projectiles.push(new Projectile(
          this.x + this.width / 2,
          this.y,
          CONFIG.COLORS.projectile
        ));
        
        // Create small muzzle flash effect
        for (let i = 0; i < 5; i++) {
          gameState.particles.push(new Particle(
            this.x + this.width / 2 + (Math.random() - 0.5) * 8,
            this.y + this.height,
            '#00ffff',
            'normal'
          ));
        }
      }

      draw(ctx) {
        ctx.fillStyle = this.color;
        ctx.fillRect(this.x, this.y, this.width, this.height);
        
        // Draw turret barrel
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(this.x + this.width / 2 - 2, this.y - 10, 4, 10);
      }
    }

    class Projectile {
      constructor(x, y, color) {
        this.x = x;
        this.y = y;
        this.width = CONFIG.PROJECTILE_SIZE;
        this.height = CONFIG.PROJECTILE_SIZE;
        this.color = color;
        this.speed = CONFIG.PROJECTILE_SPEED;
      }

      update() {
        this.y -= this.speed;
      }

      draw(ctx) {
        ctx.fillStyle = this.color;
        ctx.fillRect(this.x - this.width / 2, this.y, this.width, this.height);
      }

      isOffScreen() {
        return this.y < -this.height;
      }
    }

    class Enemy {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.width = CONFIG.ENEMY_SIZE;
        this.height = CONFIG.ENEMY_SIZE;
        this.color = CONFIG.COLORS.enemy;
        this.speed = CONFIG.ENEMY_SPEED + Math.random() * 2;
        this.health = 1;
      }

      update() {
        this.y += this.speed;
      }

      draw(ctx) {
        ctx.fillStyle = this.color;
        ctx.fillRect(this.x, this.y, this.width, this.height);
        
        // Draw alien eyes
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(this.x + 5, this.y + 5, 3, 3);
        ctx.fillRect(this.x + 12, this.y + 5, 3, 3);
      }

      isOffScreen() {
        return this.y > CONFIG.CANVAS_HEIGHT;
      }

      collidesWith(projectile) {
        return this.x < projectile.x + projectile.width &&
               this.x + this.width > projectile.x &&
               this.y < projectile.y + projectile.height &&
               this.y + this.height > projectile.y;
      }
    }

    class Powerup {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.width = 20;
        this.height = 20;
        this.color = CONFIG.COLORS.powerup;
        this.speed = 1;
        this.type = Math.random() < 0.5 ? 'shield' : 'rapidFire';
      }

      update() {
        this.y += this.speed;
      }

      draw(ctx) {
        ctx.fillStyle = this.color;
        ctx.fillRect(this.x, this.y, this.width, this.height);
        
        // Draw powerup symbol
        ctx.fillStyle = '#ffffff';
        if (this.type === 'shield') {
          ctx.fillRect(this.x + 8, this.y + 5, 4, 10);
        } else {
          ctx.fillRect(this.x + 5, this.y + 8, 10, 4);
        }
      }

      isOffScreen() {
        return this.y > CONFIG.CANVAS_HEIGHT;
      }
    }

    class Particle {
      constructor(x, y, color, type = 'normal') {
        this.x = x;
        this.y = y;
        this.type = type;
        this.color = color;
        this.life = type === 'explosion' ? 45 : 30;
        this.maxLife = this.life;
        this.size = type === 'explosion' ? Math.random() * 4 + 2 : 3;
        
        // Enhanced movement for explosion particles
        if (type === 'explosion') {
          const speed = Math.random() * 8 + 4;
          const angle = Math.random() * Math.PI * 2;
          this.vx = Math.cos(angle) * speed;
          this.vy = Math.sin(angle) * speed;
          this.gravity = 0.1;
          this.friction = 0.98;
        } else {
          this.vx = (Math.random() - 0.5) * 6;
          this.vy = (Math.random() - 0.5) * 6;
          this.gravity = 0;
          this.friction = 0.99;
        }
      }

      update() {
        this.x += this.vx;
        this.y += this.vy;
        
        if (this.type === 'explosion') {
          this.vy += this.gravity;
          this.vx *= this.friction;
          this.vy *= this.friction;
        }
        
        this.life--;
      }

      draw(ctx) {
        const alpha = this.life / this.maxLife;
        ctx.globalAlpha = alpha;
        
        if (this.type === 'explosion') {
          // Glowing explosion effect
          ctx.shadowColor = this.color;
          ctx.shadowBlur = 10 * alpha;
          ctx.fillStyle = this.color;
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
          ctx.fill();
          
          // Inner bright core
          ctx.shadowBlur = 5 * alpha;
          ctx.fillStyle = '#ffffff';
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.size * 0.5, 0, Math.PI * 2);
          ctx.fill();
        } else {
          // Normal particle effect
          ctx.fillStyle = this.color;
          ctx.fillRect(this.x, this.y, this.size, this.size);
        }
        
        ctx.globalAlpha = 1;
        ctx.shadowBlur = 0;
      }

      isDead() {
        return this.life <= 0;
      }
    }

    // Game functions
    function init() {
      const canvas = document.getElementById('gameCanvas');
      const ctx = canvas.getContext('2d');
      
      canvas.width = CONFIG.CANVAS_WIDTH;
      canvas.height = CONFIG.CANVAS_HEIGHT;
      
      gameState.turret = new Turret(300, 650);
      gameState.projectiles = [];
      gameState.enemies = [];
      gameState.powerups = [];
      gameState.particles = [];
      
      input = new InputManager();
      
      // Button event listeners
      document.getElementById('startBtn').addEventListener('click', startGame);
      document.getElementById('resumeBtn').addEventListener('click', resumeGame);
      document.getElementById('restartBtn').addEventListener('click', restartGame);
      document.getElementById('quitBtn').addEventListener('click', showMainMenu);
      document.getElementById('playAgainBtn').addEventListener('click', restartGame);
      document.getElementById('mainMenuBtn').addEventListener('click', showMainMenu);
      
      showMainMenu();
    }

    function startGame() {
      gameState.running = true;
      gameState.paused = false;
      gameState.score = 0;
      gameState.wave = 1;
      gameState.lives = CONFIG.LIVES;
      gameState.spawnTimer = 0;
      
      hideElement('mainMenu');
      showElement('gameStats');
      
      gameLoop();
    }

    function pauseGame() {
      gameState.paused = true;
      showElement('pauseMenu');
    }

    function resumeGame() {
      gameState.paused = false;
      hideElement('pauseMenu');
      gameLoop();
    }

    function restartGame() {
      startGame();
    }

    function showMainMenu() {
      gameState.running = false;
      gameState.paused = false;
      hideElement('gameStats');
      hideElement('pauseMenu');
      hideElement('gameOverMenu');
      showElement('mainMenu');
    }

    function gameOver() {
      gameState.running = false;
      hideElement('gameStats');
      
      const finalStats = document.getElementById('finalStats');
      finalStats.innerHTML = `
        <div style="margin: 20px 0; padding: 15px; background: rgba(0,255,255,0.1); border-radius: 10px;">
          <div style="margin: 10px 0;">Final Score: ${gameState.score}</div>
          <div style="margin: 10px 0;">Waves Survived: ${gameState.wave}</div>
        </div>
      `;
      
      showElement('gameOverMenu');
    }

    function gameLoop() {
      if (!gameState.running || gameState.paused) return;
      
      update();
      render();
      
      setTimeout(gameLoop, gameState.gameSpeed);
    }

    function update() {
      // Handle input
      if (input.isKeyPressed('KeyP')) {
        pauseGame();
        return;
      }

      // Update turret
      gameState.turret.update(input);

      // Spawn enemies with capped difficulty and minimum delay
      const currentSpawnRate = CONFIG.SPAWN_RATE + (gameState.wave * CONFIG.WAVE_INCREASE);
      const maxSpawnRate = 0.015; // Cap the maximum spawn rate
      const minDelay = 0.5; // Minimum delay between spawns
      
      gameState.spawnTimer += Math.min(currentSpawnRate, maxSpawnRate);
      
      if (gameState.spawnTimer >= 1) {
        gameState.spawnTimer = 0;
        const x = Math.random() * (CONFIG.CANVAS_WIDTH - CONFIG.ENEMY_SIZE);
        gameState.enemies.push(new Enemy(x, -CONFIG.ENEMY_SIZE));
        
        // Add small delay to prevent overwhelming spawns
        setTimeout(() => {
          gameState.spawnTimer = minDelay;
        }, 100);
      }

      // Spawn powerups more frequently
      if (Math.random() < 0.003) {
        const x = Math.random() * (CONFIG.CANVAS_WIDTH - 20);
        gameState.powerups.push(new Powerup(x, -20));
      }

      // Update projectiles
      gameState.projectiles = gameState.projectiles.filter(proj => {
        proj.update();
        return !proj.isOffScreen();
      });

      // Update enemies
      gameState.enemies = gameState.enemies.filter(enemy => {
        enemy.update();
        
        // Check if enemy reached the bottom
        if (enemy.isOffScreen()) {
          // Create explosion effect at turret position when enemy damages it
          createExplosion(gameState.turret.x + gameState.turret.width/2, gameState.turret.y + gameState.turret.height/2, '#ff0040');
          
          gameState.lives--;
          if (gameState.lives <= 0) {
            gameOver();
            return false;
          }
          return false;
        }
        
        return true;
      });

      // Update powerups
      gameState.powerups = gameState.powerups.filter(powerup => {
        powerup.update();
        return !powerup.isOffScreen();
      });

      // Update particles
      gameState.particles = gameState.particles.filter(particle => {
        particle.update();
        return !particle.isDead();
      });

      // Check collisions
      checkCollisions();

      // Update wave - more gradual progression
      if (gameState.enemies.length === 0 && gameState.score > gameState.wave * 150) {
        gameState.wave++;
      }

      // Update UI
      updateUI();
    }

    function createExplosion(x, y, color) {
      // Create multiple explosion particles
      for (let i = 0; i < 15; i++) {
        gameState.particles.push(new Particle(x, y, color, 'explosion'));
      }
      
      // Create additional smaller particles for debris effect
      for (let i = 0; i < 8; i++) {
        gameState.particles.push(new Particle(x, y, '#ffff00', 'normal'));
      }
      
      // Check for nearby enemies to damage them
      gameState.enemies.forEach((enemy, index) => {
        const distance = Math.sqrt(
          Math.pow(enemy.x + enemy.width/2 - x, 2) + 
          Math.pow(enemy.y + enemy.height/2 - y, 2)
        );
        
        // Damage enemies within explosion radius
        if (distance < 80) {
          // Remove enemy if very close to explosion
          if (distance < 40) {
            gameState.enemies.splice(index, 1);
            gameState.score += 15; // Bonus for explosion kill
          } else {
            // Damage enemy (reduce size to show damage)
            enemy.width = Math.max(15, enemy.width - 5);
            enemy.height = Math.max(15, enemy.height - 5);
          }
        }
      });
    }

    function checkCollisions() {
      // Projectile vs Enemy collisions
      gameState.projectiles.forEach((proj, projIndex) => {
        gameState.enemies.forEach((enemy, enemyIndex) => {
          if (enemy.collidesWith(proj)) {
            // Remove projectile and enemy
            gameState.projectiles.splice(projIndex, 1);
            gameState.enemies.splice(enemyIndex, 1);
            
            // Add score
            gameState.score += 10;
            
            // Create explosion effect
            createExplosion(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2, CONFIG.COLORS.enemy);
          }
        });
      });

      // Turret vs Powerup collisions
      gameState.powerups.forEach((powerup, index) => {
        if (gameState.turret.x < powerup.x + powerup.width &&
            gameState.turret.x + gameState.turret.width > powerup.x &&
            gameState.turret.y < powerup.y + powerup.height &&
            gameState.turret.y + gameState.turret.height > powerup.y) {
          
          gameState.powerups.splice(index, 1);
          
          if (powerup.type === 'shield') {
            gameState.lives = Math.min(gameState.lives + 1, CONFIG.LIVES + 2);
          } else {
            // Rapid fire effect
            gameState.turret.fireCooldown = 0;
          }
        }
      });
      
      // Turret vs Enemy collisions
      gameState.enemies.forEach((enemy, index) => {
        if (gameState.turret.x < enemy.x + enemy.width &&
            gameState.turret.x + gameState.turret.width > enemy.x &&
            gameState.turret.y < enemy.y + enemy.height &&
            gameState.turret.y + gameState.turret.height > enemy.y) {
          
          // Create explosion effect
          createExplosion(gameState.turret.x + gameState.turret.width/2, gameState.turret.y + gameState.turret.height/2, '#ff0040');
          
          // Remove enemy
          gameState.enemies.splice(index, 1);
          
          // Damage turret
          gameState.lives--;
          if (gameState.lives <= 0) {
            gameOver();
          }
        }
      });
    }

    function render() {
      const canvas = document.getElementById('gameCanvas');
      const ctx = canvas.getContext('2d');
      
      // Clear canvas
      ctx.fillStyle = CONFIG.COLORS.bg || '#000011';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // Draw background stars
      drawBackground(ctx);
      
      // Draw game objects
      gameState.turret.draw(ctx);
      
      gameState.projectiles.forEach(proj => proj.draw(ctx));
      gameState.enemies.forEach(enemy => enemy.draw(ctx));
      gameState.powerups.forEach(powerup => powerup.draw(ctx));
      gameState.particles.forEach(particle => particle.draw(ctx));
    }

    function drawBackground(ctx) {
      // Draw static stars
      ctx.fillStyle = '#ffffff';
      for (let i = 0; i < 100; i++) {
        const x = (i * 37) % CONFIG.CANVAS_WIDTH;
        const y = (i * 73) % CONFIG.CANVAS_HEIGHT;
        const size = (i % 3) + 1;
        ctx.fillRect(x, y, size, size);
      }
      
      // Create ambient floating particles occasionally
      if (Math.random() < 0.02 && gameState.particles.length < 50) {
        gameState.particles.push(new Particle(
          Math.random() * CONFIG.CANVAS_WIDTH,
          CONFIG.CANVAS_HEIGHT + 10,
          '#4444ff',
          'normal'
        ));
      }
    }

    function updateUI() {
      document.getElementById('scoreValue').textContent = gameState.score;
      document.getElementById('waveValue').textContent = gameState.wave;
      document.getElementById('livesValue').textContent = gameState.lives;
    }

    function showElement(id) {
      document.getElementById(id).classList.remove('hidden');
    }

    function hideElement(id) {
      document.getElementById(id).classList.add('hidden');
    }

    function goHome() {
      window.location.href = '../index.html';
    }

    // Initialize game
    let input;
    init();
  </script>
</body>
</html>
